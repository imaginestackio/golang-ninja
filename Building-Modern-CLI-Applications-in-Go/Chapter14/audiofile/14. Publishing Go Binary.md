# Publishing Your Go Binary as a Homebrew Formula with GoReleaser

In this chapter, we’ll look at GoReleaser and GitHub Actions and how they can be used in tandem to automate the release of a Go binary as a Homebrew formula. First, we’ll look at **GoReleaser**, a popular open source tool that streamlines the creation, testing, and distribution of Go binaries. We’ll look at its various configurations and options as well as how it works with GitHub Actions.

Following that, we’ll look at **GitHub Actions**, a CI/CD platform that lets you automate software development workflows and integrate with other tools such as GoReleaser. We’ll look at how to use it to ensure consistent and reliable builds, tests, and deployments.

After we’ve mastered both tools, we’ll concentrate on triggering releases, creating a Homebrew tap, and integrating with Homebrew for simple installation and testing. **Homebrew**, a popular package manager for macOS, can be used for easy installation and management of your CLI application. Releasing your software to Homebrew not only simplifies the installation process for macOS users, but also gives you access to a wider audience. You can reach a sizable community of macOS developers and consumers that prefer using a package manager for program installation, such as Homebrew. Users can quickly find and install your software with just one command, increasing its usability and accessibility. This can help you reach a larger audience than you otherwise would and boost the visibility, usage, and adoption of your program.

By the end of this chapter, you’ll have a firm grasp of how to combine GoReleaser and GitHub Actions to create an automated and efficient release process, and that includes publishing to Homebrew. With this knowledge, you will be able to tailor your own workflow to your specific requirements. The following topics will be covered:

-   GoReleaser workflow
-   Trigger release
-   Installing with Homebrew and Testing

Just Imagine

# Technical requirements

For this chapter, you will need to do the following:

-   You can also find the code examples on GitHub at [https://github.com/ImagineDevOps DevOps/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile](https://github.com/ImagineDevOps DevOps/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile)
-   A GitHub account
-   Install the GoReleaser tool at [https://goreleaser.com/install/](https://goreleaser.com/install/)

Just Imagine

# GoReleaser workflow

Releasing software may be a lengthy and challenging process, particularly for projects with several dependencies and platforms. In addition to saving time, automating the release process lowers the possibility of human error and guarantees reliable and effective releases. GoReleaser is a popular choice for automating the release process for Go developers. However, there are also other choices, such as CircleCI, GitLab CI, and GitHub Actions, each of which has particular advantages and features. In this section, we’ll examine the advantages of automating the release procedure and look in more detail at a few of these choices, specifically GoReleaser and GitHub Actions.

When compared to alternatives, GoReleaser stands out for the following reasons:

-   **Easy to use**: Setup is simple and intuitive, making it easy for developers to get started with release automation. Their CLI quickly initializes a repository with a default configuration that can often work out of the box.
-   **Platform support**: A variety of operating systems, including the major OSs, and cloud services are supported.
-   **Customization at each step**: Programmers have the ability to customize at every step of the release process including building, testing, and publishing to various platforms.
-   **Release artifacts**: A wide range of release artifacts may be produced, including Debian packages, Docker images, and binary files.
-   **Versatile**: Combining with CI/CD pipelines, such as GitHub Actions, enables developers to fully automate their release procedure.
-   **Open source**: Programmers may access the source code of the GoReleaser project and alter it to suit their own needs.
-   **Community support**: GoReleaser offers a sizable and active user base, making it simple for developers to contribute to the project and find answers to their questions.

While there are many benefits to using GoReleaser, there are, however, a few reasons to not use GoReleaser for your project that you may need to consider:

-   **Reliance on Github**: This may not be ideal if you prefer to use different tools or workflows.
-   **Specific platform requirements**: While GoReleaser supports many popular OSs or cloud providers, you may require a platform that is not supported.
-   **Complex release requirements**: While there is customization allowed in every step, there’s a possibility GoReleaser may not be flexible enough to serve your specific level of complexity.

In conclusion, while there are other options out there, choose a tool that works for your specific use case. We do feel like GoReleaser is a great tool to use for the audiofile CLI use case, so let’s continue.

## Defining the workflow

Having analyzed the pros and cons of using GoReleaser, let’s dive into its workflow by first sketching the overall process and then delving into each stage in greater detail:

1.  Configure your project to use GoReleaser.
2.  Configure GitHub Actions.
3.  Set up your GitHub repositories.
4.  Set up your GitHub token for Actions.
5.  Tag and push the code.

It might make more sense to view this with a visual, so this is what we are trying to accomplish:

![Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.1_B18883.jpg)

Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser

Let’s dive deeper and gain a more thorough understanding of each step involved in the workflow now that we have a general idea of how it works; we will explore using GoReleaser with GitHub Actions and learn how to automate your own releases.

### Configuring your project to use GoReleaser

With the GoReleaser tool installed, you can now initialize your CLI repository. In this case, we’ll initialize the root of the audiofile CLI project repository by executing the following command:

```markup
goreleaser init
```

You should notice that a new file has been generated: `goreleaser.yml`. Before even inspecting the file, we can run a local-only release to confirm that there are no issues with the configuration by executing the following command:

```markup
goreleaser release --snapshot --clean
```

The output from the command gives you a clear idea of all the steps involved in the release. We will walk through these steps in the next section, _Trigger release_. At the very end of the output, you should see a message indicating a successful release, similar to this:

```markup
  • release succeeded after 10s
```

While the default configuration succeeded, we’ll need to look deeper into the configuration settings and modify and add appropriately to customize our release process. First, let’s look at the default `.goreleaser.yaml` file together and break it down.

#### Global hooks

At the very top of the file, we see some default global hooks. **Hooks** allow you to run custom scripts. In GoReleaser, the `before` field allows you to specify which custom scripts to run before the release process begins:

```markup
before:
  hooks:
    - go mod tidy
    - go generate ./...
```

In the preceding example, we configured the automation to run the `go mod tidy` and `go generate ./...` commands prior to the release process. However, you might run scripts that perform tasks such as the following:

-   Updating the version number in your project’s code
-   Generating a changelog
-   Running automated tests to ensure that your code is working as expected
-   Building your project and creating release artifacts
-   Pushing changes to your version control system

The scripts you call from the `before` hooks section in GoReleaser can be written in any language, as long as they can be executed from the command line. For example, you might write scripts in Go, Python, Bash, or any other language that supports shell execution.

#### Builds and environment variables

Next, we see some default builds and some environment variables set. The `builds` field allows you to determine the combination of operating systems, defined by the `GOOS` field, architectures defined by the `GOARCH` field, and architecture mode, defined by the `GOARM` field. It also allows you to add additional fields, such as the `env` field, which allows you to set environment variables for the builds. Additional aspects that can be defined include the binary, flags, hook and more:

```markup
builds:
  - env:
    - CGO_ENABLED=0
  goos:
    - linux
    - windows
    - darwin
```

In the preceding example that exists within the default configuration, we defined the environment variable, `CGO_ENABLED`, to be set to `0`, and then configure the build process to generate binaries for the Linux, Windows, and Darwin operating systems.

Note

The `env` field can be set at a global level so that the environment variable is available at all stages of the release process, or it may be specified, such as in the previous case, within the build context alone.

The final configuration ends up having a few more modifications, such as specifying a few additional architectures, `amd64` and `arm64`, and removing `go generate ./...` before hook, which is unnecessary. Also, we’ve modified the `builds` field by setting build flags to use the `pro` and `dev` flags:

```markup
flags:
  - -tags=pro dev
```

While there are many other options you can set under the `builds` field, we will not cover them in this section. We encourage you to view the full list of customizations available at [https://goreleaser.com/customization/builds/](https://goreleaser.com/customization/builds/).

#### Archives

Next, we view some default `archives` settings. In GoReleaser, an **archive** is a compressed file that contains your application’s binaries, `README`, and `LICENSE` files. The objective is to package your application’s critical components into a single file, essentially making it easier to distribute and deploy. The default configuration sets the `archives` field to the following:

```markup
archives:
  - format: tar.gz
    name_template: >-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else if eq .Arch "386" }}i386
      {{- else }}{{ .Arch }}{{ end }}
      {{- if .Arm }}v{{ .Arm }}{{ end }}
  format_overrides:
  - goos: windows
    format: zip
```

Within the preceding defaults for the `archives` field, you can see that the default archive format is `tar.gz` for all operating systems except for when `GOOS` is set to Windows. In that case, the archive format is `zip`. The name of the file is defined by a template. To learn more about the GoReleaser naming template, visit [https://goreleaser.com/customization/templates/](https://goreleaser.com/customization/templates/) as there are many fields to customize the name of your archive. Let’s at least review the keys used in the `naming_template` field:

-   `.ProjectName` – the project name. If not set, GoReleaser will use the name of the directory containing the Go project. In our case, it is `audiofile`.
-   `.Os` – `GOOS` value.
-   `.Arch` – `GOARCH` value.
-   `.Arm` – `GOARM` value.

Now that we understand what these template keys refer to, let’s suppose that we generate an archive for our audiofile CLI project, for Linux, with an `amd64` architecture. The resulting name of the archive file would be `audiofile_Linux_x86x64.tar.gz`.

#### Checksum

GoReleaser automatically creates and includes a file called `project 1.0.0 checksums.txt` with the release package. **Checksums** allow your users to ensure that the files they’ve downloaded are complete and accurate. Similar to the `archives` field, you can use `naming_template` to generate the name of the `checksum` file. However, within our configuration, the default value for the `checksum` field is simply `checksums.txt`:

```markup
checksum:
  name_template: 'checksums.txt'
```

Defining a `checksum` file is important since it helps ensure the integrity of the data being distributed. The `checksum` file contains a one-of-a-kind code that can be used to verify that the downloaded files are identical to the original files. If the `checksum` file is not provided, the released files may be modified or corrupted throughout the download process. This can result in unpredictable behavior in your application and problems for your users. To avoid this, always provide a `checksum` file with your releases so that everyone knows they’re getting the correct version of your product.

#### Snapshot

The `snapshot` field in the GoReleaser configuration file specifies whether a release is a “snapshot” or a stable release. A **snapshot** is a non-production version of a software project that is made available for testing and feedback.

The generated release artifacts will be marked as snapshots if the `snapshot` field is set to `true`. This means that the version number will be suffixed with `-SNAPSHOT`, and the release will not be published to any remote repository, such as GitHub Releases. If the `snapshot` field is set to `false` or is not supplied, the release is considered stable and is published normally. Like the previous two fields, `archives` and `checksum`, the `snapshot` field also has a `name_template` that can be used:

```markup
snapshot:
  name_template: "{{ incpatch .Version }}-next"
```

If not set, the default version, `0.0.1`, is set. Based on the previous template, the name of the snapshot will be `0.0.1-next`. `incpatch`, according to the GoReleaser documentation, increments the patch of the given reversion, with a side note that it will panic if it’s not a semantic version. A **semantic version**, also known as **SemVer**, is a version numbering scheme that uses a format of `major.minor.patch` to convey the level of changes in a software release.

#### Changelog

The `changelog` field defines the path of your project’s changelog file. A **changelog** file contains a list of all the changes, improvements, and bug fixes made to a software project, typically organized by version.

The aim is to record these changes so that users and developers can easily discover what’s new in a specific release. The changelog also aids with debugging and support by documenting the development process. Let’s look at the default configuration for the `changelog` field:

```markup
changelog:
  sort: asc
  filters:
    exclude:
      - '^docs:'
      - '^test:'
```

In the preceding block of the configuration, we defined the behavior of the changelog generation process. Using the `sort` field, we specify the order in which the entries of the changelog should be displayed, in this case, `asc`, for ascending. The `filters` field specifies, with the `exclude` subfield, a list of regular expressions matched against commits to be excluded. To view all the options available for the `changelog` field, visit `https://goreleaser.com/customization/changelog/`.

So, now that we’ve finished analyzing the default GoReleaser configuration, let’s determine what we’d want to consider adding.

#### Release

The following code block in the GoReleaser configuration dictates that if there are any changes present within a Git repository, it automatically generates a pre-release. The pre-released version will have a version number that includes a pre-release suffix, such as `1.0.0-beta.1`:

```markup
release:
  prerelease: auto
```

This automated process provides a convenient way for developers to create early versions of their software for testing purposes. By utilizing pre-releases, they can quickly and effortlessly gather feedback on the latest changes and make any necessary modifications before releasing a final version to the public.

#### Universal binaries

ImagineDevOps  having just one file that can work on multiple architectures of an operating system, such as an install that works on a macOS machine with either an M1 or Intel chip. That’s what a **universal binary** is, also known as **fat binaries**. Instead of having separate binaries for different architectures, you’d have just one universal binary that can work on both. This makes it a lot more convenient for developers to spread their software across different platforms, and for users to just download a single file and run it on their system without having to worry about compatibility issues:

```markup
universal_binaries:
  - replace: true
```

We tell GoReleaser to use universal binaries by adding the `universal_binaries` field and setting the `replace` value to `true`.

#### Brews

The `brews` field allows developers to specify the details for creating and publishing Homebrew as part of their release process. Let’s take a look at the following addition to our configuration for the audiofile CLI project:

```markup
brews:
  -
  name: audiofile
  homepage: https://github.com/marianina8
  tap:
    owner: marianina8
    name: homebrew-audiofile
  commit_author:
    name: marianina8
```

Let’s at least define what these fields are defining for the Homebrew creation and publishing process. A **tap repository** is a GitHub repository that contains one or more formula files, which define how to install a particular package on Homebrew. Note that the tap repository, although defined in the configuration, will be created in _Step 3_, _Setting up your_ _GitHub repositories_:

-   `name` – Defaults to the project name, audiofile.
-   `homepage` – Your CLI application’s homepage. This defaults to empty, but set it to your GitHub repository name.
-   `tap` – Defines the GitHub/GitLab repository to publish the formula to. The `owner` field is the owner of the repository. The `name` field is the name of the repository.
-   `commit_author` – This is the Git author that shows up when committing to the repository. It defaults to `goreleaserbot`, but in our case, we set it to our GitHub handle.

You can view all the available customizations available for the `brew` field at [https://goreleaser.com/customization/homebrew/](https://goreleaser.com/customization/homebrew/).

Onto the next step!

### Configuring GitHub Actions

Within this section, we’ll learn about GitHub Actions and how they can be integrated with the GoReleaser tool. First, **Github Actions**, as you may recall, is a CI/CD tool, but get ready for this, it also has an incredible feature that allows you to set off an execution of whatever code you like on your repository when a certain event occurs! You may already know this actually, but for those who now know, new doors of opportunity are opening. Let’s discuss the main components of GitHub Actions:

-   **Events**: Any GitHub event, such as pushing code, creating a new branch, opening a PR, a pull request, or commenting on an issue. Events trigger workflows.
-   **Runners**: A runner is a process that starts executing a workflow when triggered by an event. There is a one-to-one relationship between a runner and a job.
-   **Workflows**: Workflows are composed of a series of jobs that can run sequentially or in parallel. They are defined in the .`/.``github/workflows` directory.
-   **Jobs**: A single job is a series of tasks. A task could be a script or another GitHub action.
-   **Actions**: An action is a task. Some tasks may perform complex tasks such as publishing a Go package to Homebrew, or simple tasks, such as setting an environment variable.

The following diagram may help to indicate the relationship between the four major components of GitHub Actions:

![Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.2_B18883.jpg)

Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions

Now that we’ve grasped the concept of GitHub Actions, let’s see how we can take events, such as pushing tags, to trigger a GoReleaser job, which performs the complex task of publishing a Go package to Homebrew for us. First, we need to create the configuration file. From the root of the repository, do the following:

1.  Create a folder called `.github`.
2.  Create a subfolder inside of the `.github` folder, called `workflows`.
3.  Create a `release.yml` file.

The GoReleaser website provides a default configuration for GitHub Actions on their website at [https://goreleaser.com/ci/actions/](https://goreleaser.com/ci/actions/). You may copy and paste this from their website to give you a good starting point. We’ll make a few modifications, but before we do, let’s walk through the default configuration together. Let’s begin by discussing the fields that exist within the GitHub Actions `release.yml` file.

#### On

The `on` field within the Github Actions repository specifies the events that trigger the workflow. It could be a single event or multiple. Let’s go through some of the events:

-   `Push`: The `push` field is used to tell the action to trigger a push. For example, this can be customized to specify pushing to a branch or tag. The syntax for this field is defined as follows:

`on.push.<branches|tags|branches-ignore|tags-ignore>.<paths|paths-ignore>`

-   Use the `branches` filter to include specific branch names and the `branches-ignore` filter to exclude certain branch names. Remember, don’t use both `branches` and `branches-ignore` in the same workflow event.
-   Use the `tags` filter for including specific tag names and `tags-ignore` for excluding certain tag names. Again, be careful, don’t use both `tags` and `tags-ignore` in the same workflow! Apparently, the workflow won’t run if that’s the case.
-   The `paths` and `paths-ignore` fields can be used to specify if code has changed within a particular path. The value of those fields may be set to glob patterns that use the `*` and `**` wildcard characters. The `paths` and `paths-ignore` filters allow you to control what paths are included or excluded from path pattern matching.
-   `Pull request`: The `pull_request` field is used to tell the action to trigger a pull request. Like the previous field, we can specify the `branches` filter to include specific branch names or the `branches-ignore` filter to exclude branch names. Similarly, the `paths` and `paths-ignore` fields may also be set. The `branches` and `branches-ignore` fields also accept glob patterns.
-   `event_name`: The `event_name` field defines the type of activity that will trigger a workflow to be executed. Within GitHub, there are events that can be triggered from more than one activity. The syntax of the full defined event that includes this field is defined as follows:

`on.<event_name>.types`

There is quite a long list of available events that can be used, including the two that we covered earlier, `push` and `pull_request`, but also `check_run`, `label`, `release`, and many more.

There’s a lot more that can be done with GitHub Actions, so to see the full list of options to customize the `on` field, visit [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).

Now that we have a good understanding of GitHub Actions, let’s look at the default configuration and see what it has set for the `on` field:

```markup
on:
  push:
    # run only against tags
    tags:
    - '*'
```

Perfect! This is pretty much exactly what we need. The preceding block of code specifies running the workflow triggered by tags being pushed.

#### Permissions

The `permissions` field is used to define the level of access that the GitHub Actions workflow has to various resources within your GitHub repository. Essentially, it helps you control what your workflow can and can’t do within your repository. Let’s take a look at the default configuration for the `permissions` field:

```markup
permissions:
  contents: write
  # packages: write
  # issues: write
```

The last two lines are commented out, but we can still discuss them. Within the preceding code, there are three permission types specified: `contents`, `packages`, and `issues`. Since these permissions are all set to `write`, but the latter two are commented out, then we limit the workflow permissions to `contents: write` to the repository. Based on the documentation on GoReleaser, the `contents:write` permission is required in order to upload archives as GitHub releases or to publish to Homebrew.

If you want to push Docker images to GitHub, you’ll need to enable the `packages: write` permission. If you use milestone closing capacity, you’ll need the `issues: write` permission enabled.

#### Jobs

The `jobs` field defines the individual tasks that make up your workflow. It is basically the blueprint of the workflow, defining each job and specifying in which order they will be executed. Let’s take a look at the default value set within our configuration file:

```markup
jobs:
  goreleaser:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - run: git fetch --force --tags
      - uses: actions/setup-go@v3
        with:
          go-version: '>=1.20.0'
          cache: true
      - uses: goreleaser/goreleaser-action@v4
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

Now, let’s clarify the preceding code. There is only one job, named `goreleaser`, defined under the `jobs` field. The `goreleaser` job has the following steps defined in order:

1.  **Checkout code** – the first step uses the `actions/checkout@v3` action to check out the code from your GitHub repository. The `fetch-depth` parameter is set to `0`, which ensures that all branches and tags are fetched from the repository.
2.  **Fetch git tags** – the second step runs the `git fetch --force --tags` command, which fetches all tags from the Git repository.
3.  **Set up Go environment** – the third step uses the `actions/setup-go@v3` action to set up a Go environment. The `go-version` parameter is set to `>=1.20.0`, which specifies the minimum version of Go required for this job. The `cache` parameter is set to `true`, which tells GitHub Actions to cache the Go environment, speeding up subsequent runs of this job.
4.  **Release with GoReleaser** – the final step uses the `goreleaser/goreleaser-action@v4` action to release the code with GoReleaser. The `distribution` parameter is set to `goreleaser`, which specifies the type of distribution to be used. The `version` parameter is set to `latest`, which specifies the latest version of GoReleaser to be used. The `args` parameter is set to `release --clean`, which specifies the command-line arguments to be passed to GoReleaser when the release is performed.

The only modification that we’ll need to do to the default configuration is to modify the `with.version` field for the `goreleaser/goreleaser-action` step. Currently, the default value is set to `latest`. Let’s replace it with `${{ env.GITHUB_REF_NAME }}`. The environment variable, `env.GITHUB_REF_NAME`, is automatically set by GitHub and represents the branch or tag name for the current Git reference.

Final note, at the bottom of the configuration file, the environment variables are set to be used when `goreleaser` runs. `secrets.GITHUB_TOKEN` must be replaced with `secrets.PUBLISHER_TOKEN`. This token will be used when publishing to our other repository, the Homebrew tap repository. We’ve completed the configuration of our GitHub Actions, so now we can move on to the next step.

### Setting up your GitHub repositories

If you’ve been following along with the audiofile CLI repository, then the repository already exists on GitHub. However, if you are creating your own CLI application in tandem, now is the time to make sure the repository exists on GitHub.

Besides pushing your CLI application’s repository to GitHub, we’ll also need to create the Homebrew tap repository that was defined earlier in the GoReleaser configuration file. A Homebrew **tap repository** is a second location, in our case a repository hosted on GitHub, that is separate from the official Homebrew repository, which hosts additional formula for Homebrew to install on macOS. Taps make it easier for users to install new applications, that do not exist in the `homebrew/core` repository, onto their computers.

Let’s follow the steps to creating a new Homebrew tap repository:

1.  Sign in to GitHub [https://github.com](https://github.com).
2.  Click the **New repository** button from your GitHub dashboard.
3.  Enter the repository details. In our example, enter the name, homebrew-audiofile, that matches what we set within the GoReleaser configuration. Make sure that the repository is set to `Public` as well.
4.  Create the repository by clicking on the **Create** **repository** button.
5.  Clone the repository to your local machine.

There’s no reason to add any files at this point. The GoReleaser tool, once we run the release process, will push the formula to this repository, but first, we need to create a token to use.

### Setting up your GitHub Token for Actions

In order to make the GoReleaser and GitHub Actions workflow work, we need to create a GitHub token and Actions secret.

To create a GitHub Token, click on your user menu and select the **Settings** option:

![Figure 14.3 – User menu with the Settings option selected](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.3_B18883.jpg)

Figure 14.3 – User menu with the Settings option selected

Once you are on the **Settings** page, scroll down the menu to see the last option, **Developer Settings**. When you select **Developer Settings**, you should now see the **Personal access tokens** option in the menu on the left side.

![Figure 14.4 – The Developer Settings page with Generate new token options](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.4_B18883.jpg)

Figure 14.4 – The Developer Settings page with Generate new token options

Click on the **Generate new token** button. You might need to authenticate again if you have a two-factor authentication setup, but then you should be routed to the **New personal access token (classic)** page. From this page, take the following steps to create your GitHub token:

1.  Enter a value for the **Note** field, a description of what the token will be used for. Let’s put in `audiofile` since this will be used for the audiofile CLI project.
2.  In the **Select scopes** section, select **repo**. This will give it permission to run actions against your repositories. Then, scroll to the bottom and click the **Generate** **token** button.

![Figure 14.5 – The Personal access tokens page once the token has been generated](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.5_B18883.jpg)

Figure 14.5 – The Personal access tokens page once the token has been generated

1.  Copy the generated token (which has been blocked out within the preceding screenshot).
2.  Go back to your CLI repository; in our case, we went back to the [https://github.com/marianina8/audiofile](https://github.com/marianina8/audiofile).
3.  Click on **Settings**.
4.  From the menu on the left side, click on **Secrets and Variables**, which expands to show more options. Click on the **Actions** option.
5.  Click on **New repository secret**, which is in the top right corner of the screen.

![Figure 14.6 – Actions secrets and variables page](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.6_B18883.jpg)

Figure 14.6 – Actions secrets and variables page

1.  From the **Actions secrets/New secret** page, enter the **Name** of your secret. This should match what we entered within the GoReleaser configuration. If you recall, the `env.GITHUB_TOKEN` value in the template was set to `secrets.PUBLISHER_TOKEN`. Enter the `PUBLISHER_TOKEN` value into the **Name** field.
2.  Paste the secret you copied in _step 3_ into the **Secret** field.
3.  Click the **Add** **secret** button.
4.  Confirm that the secret now exists in your **Actions secrets and** **variables** page.

![Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.7_B18883.jpg)

Figure 14.7 – Repository secrets showing newly created PUBLISHER\_TOKEN

Now that the publisher token is set, let’s move on to the final step.

Just Imagine

# Trigger release

Now that the configuration files have been set up for GoReleaser and GitHub Actions, and the publisher tokens to give access to make changes to the repositories are also created and shared, we are ready to trigger a release with the next step of the workflow: tag and push the code. Before we do so, let’s take a step back and discuss what happens when you trigger the goReleaser job:

-   **Preparation**: GoReleaser checks the configuration files, validates the environment, and sets up the necessary environment variables
-   **Building**: Builds the Go binary and compiles it for multiple platforms (such as Windows, Linux, and macOS)
-   **Versioning**: Generates a new version number based on the existing version and the user’s configuration
-   **Creating the release artifacts**: Generates the release artifacts, such as tarballs, deb/rpm packages, and zip files for each platform
-   **Creating a Git tag**: Creates a new Git tag for the release, which is used to reference the release in the future
-   **Uploading the artifacts**: Uploads the generated release artifacts to the specified locations, such as a GitHub release, a file server, or a cloud storage service
-   **Updating Homebrew formulas**: If you are using Homebrew, it will update the Homebrew formulas to reflect the new release
-   **Notifying stakeholders**: If set up to do so, GoReleaser can notify stakeholders about the new release through various channels, such as email, Slack, or webhooks

Note that the previous steps may vary based on the specific configuration and plugins used with GoReleaser. Moving on, let’s trigger it with the push of a tag.

## Tag and push the code

At this point, make sure all the code changes you have been pushed to the remote repository for your CLI project:

1.  Tag your CLI with the appropriate version. For our CLI project, within the audiofile repository, we run the following Git command:
    
    ```markup
    git tag -a v0.1 -m "Initial deploy"
    ```
    
2.  Now push the tag to the repository. This should trigger the GitHub Actions to take place:
    
    ```markup
    git push origin v0.1
    ```
    
3.  Visit the CLI repository, and you’ll now notice a yellow dot appear at the top of the file listing:

![Figure 14.8 – Repository showing yellow dot](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.8_B18883.jpg)

Figure 14.8 – Repository showing yellow dot

1.  Click on the yellow dot, and a popup will appear. To view the details of the GoReleaser process, click on the **Details** link:

![Figure 14.9 – Details popup of goReleaser process](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.9_B18883.jpg)

Figure 14.9 – Details popup of goReleaser process

1.  Clicking on the **Details** link will take you to a page where you can watch the GoReleaser workflow progressing through each task:

![Figure 14.10 – List of tasks and their progress within the goreleaser job](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.10_B18883.jpg)

Figure 14.10 – List of tasks and their progress within the goreleaser job

1.  Once it successfully completes, from the CLI repository, click on the tag listed under the **Releases** section on the right-hand side of the page. From there, you’ll see the changelog and list of **Assets**:

![Figure 14.11 – List of assets generated from the goreleaser job](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.11_B18883.jpg)

Figure 14.11 – List of assets generated from the goreleaser job

Looks like all the builds were successfully generated and archived and are available as assets on the **Releases** page. What if it can be installed successfully with Homebrew? For the final confirmation, let’s jump to the next section.

Just Imagine

# Installing with Homebrew and Testing

Since the GoReleaser job ran successfully, we should be able to install the CLI application with Homebrew. Let’s begin by telling Homebrew to tap the repository we’ve created for the formula:

```markup
brew tap marianina8/audiofile
```

You should see the following output generated from the previous command:

```markup
==> Tapping marianina8/audiofile
Cloning into '/opt/homebrew/Library/Taps/marianina8/homebrew-audiofile'...
remote: Enumerating objects: 6, done.
remote: Counting objects: 100% (6/6), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 3 (delta 0), pack-reused 0
Receiving objects: 100% (6/6), done.
Tapped 1 formula (13 files, 6.3KB).
```

As we know, tapping the repository adds to the list of Homebrew formulas to install. Next, let’s try installing the audiofile CLI:

```markup
brew install marianina8/audiofile/audiofile
```

You should see the following output generated for the installation of the application:

```markup
==> Fetching marianina8/audiofile/audiofile
==> Downloading https://github.com/marianina8/audiofile/releases/download/v0.2/audiofile_Darwin_all.tar.gz
==> Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/483881004/ccc2302f-a4a5-454a
######################################################################## 100.0%
==> Installing audiofile from marianina8/audiofile
  /opt/homebrew/Cellar/audiofile/0.2: 4 files, 19.2MB, built in 3 seconds
==> Running `brew cleanup audiofile`...
Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.
Hide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).
```

Now, for the final test, let’s run the `audiofile` command and see the output:

![Figure 14.12 – Output of the audiofile command installed by Homebrew](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.12_B18883.jpg)

Figure 14.12 – Output of the audiofile command installed by Homebrew

Let’s now try some of the commands; first, let’s start the API in one terminal window:

```markup
mmontagnino@Marians-MacCourse-Pro audiofile % audiofile api
Starting API at http://localhost:8000
Press Ctrl-C to stop.
```

In another terminal, let’s run the player by calling the following:

```markup
audiofile player
```

You should see the following:

![Figure 14.13 – The audiofile player](https://static.packt-cdn.com/products/9781804611654/graphics/image/Figure_14.13_B18883.jpg)

Figure 14.13 – The audiofile player

We’ve been able to install with the Homebrew package manager and play around with the audiofile to know that it works well. This concludes our chapter on publishing your Go binary as a Homebrew formula with GoReleaser. While Homebrew is just one package manager, you can follow a similar process for **GoFish**, a cross-platform systems package manager that allows users to easily install applications on Linux and Windows. Combined, you’ll be able to expand your user base and make it easy for your users to install and update your CLI application.

Just Imagine

# Summary

In this chapter, we took a closer look at how GoReleaser and GitHub Actions can work together to make releasing a CLI application a breeze. First, we got to know GoReleaser, a handy tool that makes building, testing, and deploying Go binary packages a snap. We went over the default configuration file and also talked about some simple tweaks you can make to fit your needs. Then, we explored GitHub Actions and how to integrate them with GoReleaser.

By the end of this chapter, we had a good understanding of how to use these tools to create a seamless and efficient release process, complete with publishing on Homebrew. Releasing through Homebrew opens up the possibility of reaching more users who prefer to use package managers.

Just Imagine

# Questions

1.  When are `before` hooks run? Are there `after` hooks?
2.  What is the `PUBLISHER_TOKEN` GitHub token used for?
3.  Can you trigger a GitHub Action workflow on a pull request?

Just Imagine

# Further reading

-   GoReleaser documentation can be found at [https://goreleaser.com/](https://goreleaser.com/)[](https://goreleaser.com/%0A)
-   GitHub Actions documentation can be found at [https://docs.github.com/en/actions](https://docs.github.com/en/actions)[](https://docs.github.com/en/actions%0A)
-   Homebrew documentation can be found at [https://docs.brew.sh/](https://docs.brew.sh/)[](https://docs.brew.sh/%0A)

Just Imagine

# Answers

1.  The `before` hooks field specifies scripts that are run before the release process. Yes, although not discussed in this chapter, there are `after` hooks, too!
2.  The `PUBLISHER_TOKEN` GitHub token is set as an environment variable on the goreleaser job in the `release.yml` file that defines the GitHub Actions release workflow. The token is configured within GitHub to give repository access to GitHub Actions, allowing the `goreleaser` job to publish the Homebrew formula to the `homebrew-audiofile` tap repository.
3.  Yes, among many other triggers described in this chapter, pull requests can also trigger GitHub Action workflows.