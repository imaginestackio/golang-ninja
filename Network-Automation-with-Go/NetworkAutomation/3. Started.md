# Getting Started with Go

In this chapter, we dive into the Go basics and the characteristics that make it comparable to a dynamically typed language, but with the efficiency and safety of a statically typed, compiled language.

We also explore different Go packages to manipulate data in different formats and how to scale programs with Go’s concurrency model. Being able to manipulate data effectively and take advantage of all the resources of systems running multi-core processors are key elements to keep in mind when automating networks.

During this chapter, we cover the following key topics:

-   Go variable types
-   Go’s arithmetic, comparison, and logical operators
-   Control flow
-   Functions in Go
-   Interfaces in Go
-   Input and output operations
-   Decoding and encoding with Go
-   Concurrency

Bookmark

# Technical requirements

We assume basic familiarity with the command line, Git, and GitHub. You can find the code examples for this chapter in the book’s GitHub repository at [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go), under the `ch03` folder.

To run the examples, perform the following steps:

1.  Install Go 1.17 or later for your operating system. You can follow the instructions in [_Chapter 1_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_01.xhtml#_idTextAnchor015), _Introduction_, in the _Installing Go_ section, or go to [https://go.dev/doc/install](https://go.dev/doc/install).
2.  Clone the book’s GitHub repository with `git` `clone` [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go.git](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go.git).
3.  Change the directory to an example folder:
    
    ```markup
    cd Network-Automation-with-Go/ch03/json.
    ```
    
4.  Execute `go` `run main.go`.

Bookmark

# Go’s type system

Go is a statically typed language, which means the compiler must know the types of all variables to build a program. The compiler looks for a special variable declaration signature and allocates enough memory to store its value:

```markup
func main() {
    var n int
    n = 42
}
```

By default, Go initializes the memory with the zero value corresponding to its type. In the preceding example, we declare `n`, which has an initial value of `0`. We later assign a new value of `42`:

![Table 3.1 – Zero values](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.1.jpg)

Table 3.1 – Zero values

As its name suggests, a variable can change its value, but only as long as its type remains the same. If you try to assign a value with a different type or redeclare a variable, the compiler complains with an appropriate error message.

If we append a line with `n = "Hello"` to the last code example, the program wouldn’t compile, and it would return the following error message: `cannot use "Hello" (type untyped string) as type int` `in assignment`.

You can use type inference as a shortcut for variable declarations. In that case, you omit an explicit type argument in your declaration. Just keep in mind that Go has limited support for type inference inside of a function.

Instead of explicitly defining a type for each variable, you can use a special short assignment symbol, `:=`, and let the compiler guess the variable type based on its value, as in the next example, where the compiler assumes the variable `n` is of type `int`:

```markup
func main() {
    n := 42
}
```

Just like with variables, the compiler can also infer a constant type. The value of constants cannot change throughout the program and we generally use them to represent real-world values such as the number _π_ (**Pi**), static names of objects or places, and so on:

```markup
const Book = "Network Automation with Go"
```

Now, let’s have a closer look at the different types available in Go and their common use cases.

## Basic types

According to Go’s language specification, there are four groups of basic or primitive types predeclared globally and available to all Go programs by default:

-   Numeric
-   Strings
-   Boolean
-   Error

### Numeric

Go defines several numeric types to store integers and real numbers of different sizes. Type names normally contain information about their sign and the size of the value (in bits). The only notable exceptions are `int` and `uint` types, whose values depend on the machine and normally default to 32 bits for 32-bit CPUs, or 64 bits for 64-bit CPU architectures:

![Table 3.2 – Numeric type variables](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.2.jpg)

Table 3.2 – Numeric type variables

Here are some examples of how to instantiate variables of numeric types. These are all valid options, and you can use whichever is most appropriate for the range of values you need to store or produce. You can test this code from `ch03/type-definition/main.go` (in the _Further reading_ section). Notice we use type inference for `a`, so its type is `int` and its size is 8 bytes on a 64-bit machine. The second variable (`b`) is an unsigned 32-bit integer (4 bytes). The last variable (`c`) is a floating-point number (4 bytes):

```markup
func main() {
    a := -1
    var b uint32
    b = 4294967295
    var c float32 = 42.1
}
```

You can also convert a `v` value to the `T` type with the expression `T(v)`, as in the next example. Here, `b` results from converting `a`, an integer, to an unsigned 32-bit integer, and finally, `c` is a floating-point number from converting `b`:

```markup
func main() {
    a := 4294967295
    b := uint32(a)
    c := float32(b)
}
```

Once you have defined a type for a variable, any new operation has to match this type on both sides of the assignment operator (`=`). You could not append `b = int64(c)` at the end of the preceding example, as `b` would be of the `uint32` type.

Type conversion is always explicit in Go, unlike other programming languages that may do this implicitly and sometimes call this type casting.

### Strings

Go supports two styles of string literals: you can enclose the characters with double-quotes to make it an interpreted literal, or use back-quotes for raw string literals, as in the next example:

```markup
func main() {
    d := "interpreted\nliteral"
    e := `raw
literal`
    fmt.Println(d)
    fmt.Println(e)
}
```

Notice the escape sequence in `d`. Go interprets this to generate a new line character within the string. The following is the output of this program, which you can find at `ch03/string-literals/main.go` (in the _Further_ _reading_ section):

```markup
ch03/string-literals$ go run main.go
interpreted
literal
raw
literal
```

You can compare strings with the `==` and `!=` operators. You can concatenate strings with the `+` and `+=` operators. The example at `ch03/string-concatenate/main.go` (in the _Further reading_ section) shows these operators in action:

```markup
func main() {
    s1 := "Net"
    s2 := `work`
    if s1 != s2 {
        fmt.Println(s1 + s2 + " Automation")
    }
}
```

Until this point, nothing seems to be too different from other programing languages. But in Go, a string is actually a slice of bytes, or to be more precise, a sequence of UTF-8 Unicode points. In memory, Go represents this as a two-word structure containing a pointer to the string data and its length.

Let’s define a new string, `n`, with the `Network Automation` string literal in `ch03/string-memory/main.go` (in the _Further reading_ section). We can store each character as one or more bytes using the variable-width character encoding UTF-8. For English, we use one byte per character, so the string literal in this case is 18 bytes long:

```markup
func main() {
    n := "Network Automation"
    fmt.Println(len(n))
    w := n[3:7]
    fmt.Println(w)
}
```

We can define another string as a subset of another. For this, we specify the lower bound in the original string and the upper bound. The index count starts at zero and the resulting string doesn’t include the character in the upper bound index. For `n[3:7]`, we set the boundaries at characters “`w`” and “ “. The program prints the following:

```markup
ch03/string-memory$ go run main.go
18
work
```

While the `n` and `w` variables reference strings of different lengths, the variable size of both is the same, just like for any other string variable. A string variable is a two-word structure. A word is usually 32 or 64 bits depending on the CPU architecture. Two 64-bit words are 16 bytes (2 x 8-byte), so for 64-bit platforms, a string is a 16-byte data structure. Out of those 16 bytes, 8 bytes are a pointer to the actual string data (a slice), and the remaining 8 bytes are to store the length of the string slice. _Figure 3__.1_ shows what this looks like in memory:

![Figure 3.1 – What a string looks like in memory](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.3.jpg)

Figure 3.1 – What a string looks like in memory

It’s OK that more than one string references the same underlying slice, as this slice is immutable, meaning that you can’t change its contents. While the slice stores the string data, you can’t change a character of the string by referencing an index of the slice, because it’s immutable.

By contrast, if you want to change the value of a string variable, let’s say you need to assign a different text to it, Go points the string data structure to a new underlying slice with the new string content you supply. All this happens behind the scenes, so you don’t need to worry about this.

### Boolean

The `bool` data type uses one byte of memory, and it stores a value of either `true` or `false`. As in other programming languages, you can use variables of the `bool` type in conditional statements to change the control flow of a program. The `if` conditional explicitly requires a `bool` type:

```markup
func main() {
    condition := true
    if condition {
        fmt.Printf("Type: %T, Value: %t \n",
                    condition, condition)
    }
}
```

If you run this program at `ch03/boolean/main.go` (in the _Further reading_ section), you get the following output:

```markup
ch03/boolean$ go run main.go
Type: bool, Value: true
```

Because the condition is `true`, we print the `condition` variable type and value.

### Error

Go has a unique approach to error handling and defines a special `error` type to represent a failure condition. You can generate errors, change them, print them on a screen, or use them to change the control flow of a program. The next code sample shows the two most common ways of generating a new variable of the `Error` type:

```markup
func main() {
    // Creates a variable of 'error' type
    err1 := errors.New("This is a new error")
    // string formatting when building an error message
    msg := "another error message"
    err2 := fmt.Errorf("This is %s", msg)
}
```

You can make any user-defined type an error, as long as it implements a special `Error()` method that returns a `string`. We talk more about implementing methods in the _Interfaces_ section later in this chapter.

One common way of error handling is to allow it to bubble up until a point in a program where you can decide how to react to it — whether to fail and stop the execution or log and retry. Regardless of that, the use of errors is pervasive in Go, and all functions that can fail return an error as their last argument, so the following pattern is very common in Go programs:

```markup
func main() {
    result, err := myFunction()
    if err != nil {
        fmt.Printf("Received an error: %s", err)
        return err
    }
}
```

The `myFunction` function returns two values. In the outer function in the preceding example, we store the first return value of `myFunction` in a variable named `result`, and the second return value in the `err` variable, to store the value of any potential error inside `myFunction`, which now surfaces to the calling function.

Depending on the logic of the program, you need to decide how to handle the error. Here, if the error isn’t null (`nil`), we print the error message and finish the execution of the function (`return`). We could also have just logged it and allowed the program to continue.

## Container types

The next level up from the primitive types is a container type. These are still standard types that are available to any Go program without any explicit import statement. But, they represent more than just a single value. We use container types in Go to store different values of the same type; these include the following:

-   Arrays
-   Slices
-   Maps

In the following sections, we discuss the use cases and implementation details of these three types.

### Arrays

One of the first things any programmer needs, after they’ve gained the ability to deal with primitive types, is the ability to store collections of values of these types. For example, a network inventory may store a list of device hostnames or IP addresses. The most common solution for this problem is a data structure called an `array`. Go’s `array` types have the `[n]T` signature, where `n` is the length of the array and `T` is the value type you store in the array.

Here is an example of how you can use arrays in Go with strings. We purposely mix different semantic ways you can define an array, so you can choose the style you prefer. We first define the `hostnames` array on a single line and then the `ips` array on a multiline statement:

```markup
func main() {
    hostnames := [2]string{"router1.example.com",
                        "router2.example.com"}
    ips := [3]string{
        "192.0.2.1/32",
        "198.51.100.1/32",
        "203.0.113.1/32",
    }
    // Prints router2.example.com
    fmt.Println(hostnames[1])
    // Prints 203.0.113.1/32
    fmt.Println(ips[2])
}
```

This gets even more interesting for network engineers when working with arrays of bytes. Look at the next example of how Go reads the input decimal number (`127` for example), and the binary data is at your fingertips. Both array examples are available at `ch03/arrays/main.go` (see the _Further_ _reading_ section):

```markup
func main() {
    // ipv4 is [0000 0000, 0000 0000, 0000 0000, 0000 0000]
    var ipAddr [4]byte
    // ipv4 is [1111 1111, 0000 0000, 0000 0000, 0000 0001]
    var localhost = [4]byte{127, 0, 0, 1}
    // prints 4
    fmt.Println(len(localhost))
    // prints [1111111 0 0 1]
    fmt.Printf("%b\n", localhost)
    // prints false
    fmt.Println(ipAddr == localhost)
}
```

Go arrays have many benefits. They are very memory efficient, as they store values sequentially and don’t have any extra metadata overhead. They are also comparable, meaning you can check whether two arrays are equal, assuming their values have comparable types.

But, because of their fixed size, we rarely use arrays directly in Go. The only exception is when you know the size of your dataset ahead of time. With that in mind, in networking, we deal with a lot of fixed-sized datasets; they make up most of the network protocol headers, so arrays can be convenient for that and things such as IP and MAC addresses, port or sequence numbers, and various VPN labels.

### Slices

Arrays have an immutable structure by definition (fixed-size). While you can alter the value within an array, they cannot grow and shrink as the size of the stored data changes. But, implementation-wise, this has never been a problem. Many languages implement arrays as dynamic data structures that change their size behind the scenes.

Of course, there is some performance penalty involved when growing an array, but with some clever algorithms, it’s possible to reduce the number of changes and make the end user experience as frictionless as possible. Slices play this role in Go; they are the most widely used array-like data structure in Go.

Providing the length of the slice when creating it is optional. Behind the scenes, Go creates a backing array that defines the upper bound to what size the slice can grow to. That upper bound is what we know as the **capacity** of the slice. In general, the capacity is equal to the length of the slice, but that is not always the case. If the slice needs to grow beyond its capacity, Go creates a new larger backing array and copies over the contents of the original array. The next example shows three ways to create a slice and the values for capacity and length for each slice:

```markup
func main() {
    empty := []string{}
    words := []string{"zero", "one", "two", "three",
                    "four", "five", "six"}
    three := make([]string, 3)
    fmt.Printf("empty: length: %d, capacity: %d, %v\n",
                     len(empty), cap(empty), empty)
    fmt.Printf("words: length: %d, capacity: %d, %v\n",
                    len(words), cap(words), words)
    fmt.Printf("three: length: %d, capacity: %d, %v\n",
                    len(three), cap(three), three)
    /* ... <continues next > ... */
}
```

This program, which you can find at `ch03/slices/main.go` (see the _Further reading_ section), prints the following:

```markup
ch03/slices$ go run main.go
empty: length: 0, capacity: 0, []
words: length: 7, capacity: 7, [zero one two three four five six]
three: length: 3, capacity: 3, [  ]
```

Just like with strings, you can slice a slice, which creates a new reference to a section of the same backing array. For example, if you create a new slice based on the slice words from the preceding example with `words[1:3]`, you end up with a slice that has `one` and `two` elements, so the length of this slice is two. Its capacity is six, though. Why six? The backing array is the same, but the new slice starts at index one, and the last index of the backing array is seven. _Figure 3__.2_ shows what this looks like in memory:

![Figure 3.2 – What slices look like in memory](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.4.jpg)

Figure 3.2 – What slices look like in memory

To add elements to the end of slice, you can use the built-in `append` function. Let’s start from the slice we were just referencing and call it `mySlice`:

```markup
func main() {
    /* ... <continues from before > ... */
    mySlice := words[1:3]
    fmt.Printf(" mySlice: length: %d, capacity: %d, %v\n",
            len(mySlice), cap(mySlice), mySlice)
    mySlice = append(mySlice, "seven")
    fmt.Printf(" mySlice: length: %d, capacity: %d, %v\n",
            len(mySlice), cap(mySlice), mySlice)
    mySlice = append(mySlice, "eight", "nine", "ten",
                    "eleven")
    fmt.Printf(" mySlice: length: %d, capacity: %d, %v\n",
            len(mySlice), cap(mySlice), mySlice)
}
```

If we run this program from `ch03/slices/main.go` (see the _Further reading_ section), we can see how Go allocates a new backing array when it needs extra capacity. When it had three elements already, and we asked to add another four to a slice with a capacity of six, Go automatically allocated a new backing array with a capacity of 12 to support the extra elements and future growth:

```markup
ch03/slices$ go run main.go
...
 mySlice: length: 2, capacity: 6, [one two]
 mySlice: length: 3, capacity: 6, [one two seven]
 mySlice: length: 7, capacity: 12, [one two seven eight nine ten eleven]
```

The bottom line is that while this might sound hard to grasp, it all happens behind the scenes. What we want to leave you with about slices is that they are a three-word data structure, and are 24 bytes on most computers nowadays.

### Maps

Maps are a container type that makes it possible to store a mapping between one type, for example, a string or an integer, as the key to another type stored as the value. A map is of the `map[KeyType]ValueType` form, where `KeyType` is any type that is comparable and `ValueType` may be any type at all. One example would be `map[int]string`.

One way to initialize a map is with the built-in `make` function as in the next example, where we create a map of `string` as key and also with `string` as value. You can add new values to the map, referencing the key you want to associate that value with. In the example, we map `spine` to `192.168.100.1`:

```markup
func main() {
    dc := make(map[string]string)
    dc["spine"] = "192.168.100.1"
    ip := dc["spine"]
    ip, exists := dc["spine"]
    if exists {
        fmt.Println(ip)
    }
}
```

To retrieve a value and assign it to a variable, you can reference the key just like when adding values, but this time, on the right side of the equals sign, as in the preceding example, where we assigned the value of `dc["spine"]` to the `ip` variable.

You can also do membership testing, to check whether a certain key is on the map. A two-value assignment tests for the existence of a key, as in `ip, exists := dc["spine"]`, where `exists` is a Boolean value that is only `true` if `dc["spine"]` exists.

Another way to initialize a map is with data, as in the next example. To delete elements, you can use the built-in `delete` function:

```markup
func main() {
    inv := map[string]string{
        "router1.example.com": "192.0.2.1/32",
        "router2.example.com": "198.51.100.1/32",
    }
    fmt.Printf("inventory: length: %d, %v\n", len(inv),
                inv)
    delete(inv, "router1.example.com")
    fmt.Printf("inventory: length: %d, %v\n", len(inv),
                inv)
}
```

This program prints the following:

```markup
ch03/maps$ go run main.go
inventory: length: 2, map[router1.example.com:192.0.2.1/32 router2.example.com:198.51.100.1/32]
inventory: length: 1, map[router2.example.com:198.51.100.1/32]
```

The full code for this section is available at `ch03/maps/main.go` (see the _Further_ _reading_ section).

## User-defined types

Unlike the types we discussed before, user-defined types, as the name suggests, are types that you define. In this category we have the following:

-   Structs
-   Interfaces

Interfaces are the only abstract type in Go and define a contract for concrete types, such as structs. They describe behavior, not implementation details, which helps us break the business logic of our programs into building blocks with interfaces between them. We cover them in detail in a dedicated section for interfaces later in this chapter.

### Structs

A struct is a data structure that represents a collection of fields with their data types. Structs look a bit like mappings, except the keys in this case are fixed. They become an extension of the variable name.

Let’s define a router (`Router`) that has four `string` fields and one `bool` field:

```markup
type Router struct {
    Hostname  string
    Platform  string
    Username  string
    Password  string
    StrictKey bool
}
```

Now, this new type can also be part of another user-defined type, as in the following `Inventory` type, which has a slice of these routers we just defined:

```markup
type Inventory struct {
    Routers []Router
}
```

Here are a few examples of how to create an instance of a struct and assign values to its fields:

```markup
func main() {
    var r1 Router
    r1.Hostname = "router1.example.com"
    r2 := new(Router)
    r2.Hostname = "router2.example.com"
    r3 := Router{
        Hostname:  "router3.example.com",
        Platform:  "cisco_iosxr",
        Username:  "user",
        Password:  "secret",
        StrictKey: false,
    }
    /* ... <continues next > ... */
}
```

The caveat is that `r2` is now actually a pointer to `Router` (that’s how `new` works), but it’s not something we need to worry about right now. Let’s put all the routers in an `Inventory` type variable:

```markup
func main() {
    /* ... <continues from before > ... */
    inv := Inventory{
        Routers: []Router{r1, *r2, r3},
    }
    fmt.Printf("Inventory: %+v\n", inv)
}
```

Now, we have all our routers conveniently in a variable we can use. All the fields we haven’t assigned a value yet are zero value (`""`, or empty for strings):

```markup
ch03/structs$ go run main.go
Inventory: {Routers:[{Hostname:router1.example.com Platform: Username: Password: StrictKey:false} {Hostname:router2.example.com Platform: Username: Password: StrictKey:false} {Hostname:router3.example.com Platform:cisco_iosxr Username:user Password:secret StrictKey:false}]}
```

The code in this example is available at `ch03/structs/main.go` (see the _Further_ _reading_ section).

Until this point, we have not talked about other variable types such as pointers, channels, and functions. We cover these in other sections of this chapter. Please bear with us. In the next section, we introduce some math and logical operators that allow us to execute different actions in our programs.

Bookmark

# Arithmetic, comparison, and logical operators

Operators are special symbols that perform specific mathematical, logical, or relational computations on variables of different types. We cover the following three types of operators in this section:

-   Arithmetic operators
-   Logical operators
-   Comparison operators

While we don’t cover all corner cases and permutations of types, we’d like to focus on a few operators that might be interesting in the network automation context.

## Arithmetic operators

These operators perform mathematical calculations with numeric values. The resulting value depends on the order and type of the operands:

![Table 3.3 – Arithmetic operators
](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.5.jpg)

Table 3.3 – Arithmetic operators

They follow the standard mathematical logic implemented in most programming languages:

```markup
func main() {
    // sum s == 42
    s := 40 + 2
    // difference d == 0.14
    d := 3.14 - 3
    // product p == 9.42
    p := 3 * 3.14
    // quotient q == 0
    q := 3.0 / 5
    // remainder r == 2
    r :=  5 % 3
}
```

Strings are the only non-numeric type that can make use of an arithmetic operator. You can use `+` for string concatenation, to link together two or more text strings into one string:

```markup
func main() {
    // s == "Hello, World"
    s := "Hello" + ", " + "World"
}
```

One of the most interesting applications of arithmetic operations is interacting with binary data, something that many network engineers are familiar with.

Network protocols have deterministic structures expressed in a set of headers that contain forwarding information and facts of the encapsulated payload.

You can use the arithmetic operators bit shift and bitwise (`OR`, `AND`, and `XOR`) to create or extract data from network headers.

To see this in action, let’s work with a 20-byte long **Transmission Control Protocol** (**TCP**) header that has the following information:

-   Source port address – 2 bytes
-   Destination port address – 2 bytes
-   Sequence number – 4 bytes
-   Acknowledgment number – 4 bytes
-   Header length and reserved – 1 byte
-   Control flags – 1 byte:
    -   `CWR`: **Congestion Window** **Reduced** flag
    -   `ECE`: **Explicit Congestion Notification** (**ECN**)-echo flag
    -   `URG`: Urgent pointer
    -   `ACK`: Acknowledgment number is valid
    -   `PSH`: Request for push
    -   `RST`: Reset the connection
    -   `SYN`: Synchronize sequence numbers
    -   `FIN`: Terminate the connection
-   Window size – 2 bytes
-   Checksum – 2 bytes
-   Urgent pointer – 2 bytes

_Figure 3__.3_ shows the TCP header structure including all the mandatory fields we just listed:

![Figure 3.3 – TCP header structure](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.6.jpg)

Figure 3.3 – TCP header structure

In the next code example, we build a TCP header from an empty slice of bytes. We write its length in the first four bits of byte 13 and then set the `SYN` flag in byte 14 of the TCP header.

The header length field of the TCP header represents the number of 32-bit words the TCP header has. You can see it as the number of rows in it, as _Figure 3__.3_ shows. Here, the length is five words.

The following code snippet (the full version is at `ch03/tcp-header/main.go` (see the _Further reading_ section)) shows how to set this length on a TCP header using arithmetic operations:

```markup
func main() {
    // Header length (measured in 32-bit words) is 5
    var headerWords uint8 = 5
    // Header length in bytes is 20
    headerLen := headerWords * 32 / 8
    // Build a slice of 20 bytes to store the TCP header
    b := make([]byte, headerLen)
    // Shift header words bits to the left to fit
    // the Header Length field of the TCP header
    s := headerWords << 4
    // OR operation on byte 13 and the store new value
    b[13] = b[13] | s
    // Print the 13 byte of the TCP header -> [01010000]
    fmt.Printf("%08b\n", b[13])
    /* ... <continues next > ... */
}
```

_Figure 3__.4_ shows how the `headerWords` 8-bit unsigned integer variable, which is compatible with the size of a single byte, got bit-shifted left to fit into its appropriate positions in the header’s field.

The left shift operation moves the original bits, dropping the overflowing bits on the right and replacing the bits on the left with zeros. The bitwise `OR` operator combines the resulting value with the existing byte. This is a common pattern to make sure that none of the bits you configured before get lost since the bitwise `OR` operator always keeps the `1` bits if they are present in any of the operands:

![Figure 3.4 – Building a TCP header, part one](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.7.jpg)

Figure 3.4 – Building a TCP header, part one

To set a flag, we can do something similar, where we set one bit and shift it to the left to leave it in the second position to signal `SYN`:

```markup
func main() {
    /* ... <continues from before > ... */
    // assume that this is the initial TCP SYN message
    var tcpSyn uint8 = 1
    // SYN flag is the second bit from the right so
    // we shift it by 1 position
    f := tcpSyn << 1
    // OR operation on byte 14 and store the new value
    b[14] = b[14] | f
    // Print the 14 byte of the TCP header -> [00000010]
    fmt.Printf("%08b\n", b[14])
    /* ... <continues next > ... */
}
```

_Figure 3__.5_ depicts the bit operations in the preceding code example:

![Figure 3.5 – Building a TCP header, part two](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.5_NEW.jpg)

Figure 3.5 – Building a TCP header, part two

Now, let’s see how the reverse process of parsing those two bytes on the receiving side can look:

```markup
func main() {
    /* ... <continues from before > ... */
    // only interested if a TCP SYN flag has been set
    tcpSynFlag := (b[14] & 0x02) != 0
    // Shift header length right, drop any low-order bits
    parsedHeaderWords := b[13] >> 4
    // prints "TCP Flag is set: true"
    fmt.Printf("TCP Flag is set: %t\n", tcpSynFlag)
    // prints "TCP header words: 5"
    fmt.Printf("TCP header words: %d\n", parsedHeaderWords)
}
```

This time, we’re using the opposite set of bit operations. The right shift moves all bits from left to right, dropping the bits on the right and adding zeros to the left:

![Figure 3.6 – Parsing a TCP header, part one](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.61.jpg)

Figure 3.6 – Parsing a TCP header, part one

The bitwise `AND` operator has the same behavior as a network mask. It keeps the bits that are set to `1` and resets everything else to zero, effectively hiding the non-important bits. In our case, we’re using the `0x02` mask value or `0000 0010` in binary, which hides everything else and only leaves us with the second bit from the right. We can then shift that bit to the right and check its value:

![Figure 3.7 – Parsing a TCP header, part two](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.71.jpg)

Figure 3.7 – Parsing a TCP header, part two

Being able to work at the bit and byte level is a powerful programming capability.

## Logical operators

Logical operators are a basic set of Boolean operations that follow the rules of Boolean algebra — conjunction, disjunction, and negation:

![Table 3.4 – Logical operators
](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.11.jpg)

Table 3.4 – Logical operators

There is nothing surprising in Go’s implementation of these logical operators, the only thing worth remembering is that there is no syntactic sugar for them, so the only acceptable values are `&&` for `AND` , `||` for `OR`, and `!` for `NOT`.

## Comparison operators

We use the equal and not equal (`==` and `!=` ) operators to compare a pair of comparable values and return a Boolean (`true`|`false`). You can apply greater than and less than operators (`<`, `<=`, `>`, and `>=`) to ordered values:

![Table 3.5 – Comparison operators
](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.12.jpg)

Table 3.5 – Comparison operators

Here’s a brief example of comparison operators in action, with their most common types:

```markup
func main() {
    // all strings are comparable
    fmt.Println("hello" == "hello")
    // strings are ordered alphabetically
    fmt.Println("hello" < "world")
    // integers are comparable and ordered
    fmt.Println(1 < 10)
    // floating point numbers are also comparable
    fmt.Println(10.0 >= 1.1)
}
```

In the preceding example, all statements evaluate and print `true`. You can find the complete list of comparable and ordered properties of other Go types, such as pointers, channels, and arrays, in the _Comparison operators_ section of the Go language specification (see _Further reading_).

This concludes this introduction to the Go data types and different operators used to perform day-to-day operations. Now, it’s time to put together the first building blocks of our programs as we dive into Go’s control flow and functions.

Bookmark

# Control flow

Control flow constructs are a key building block of any computer program, as they allow you to express complex behaviors with conditions and iteration. Go’s support for control flow reflects its minimalistic design, which is why you’d mostly see a couple of variations of conditional statements and one version of loop in the entire language specification. It may seem surprising, but this makes Go easier to read, as it forces the same design patterns on all programs. Let’s start with the simplest and the most common control flow blocks.

## for loops

In its simplest form, the `for` loop allows you to iterate over a range of integers while doing some work in each iteration. For example, this is how you would print all numbers from `0` to `4`:

```markup
func main() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
}
```

The first line has the `init` statement, `i := 0`, the condition statement, `i < 5`, and the `post` (each iteration) statement, `i++`, separated by semicolons (`;`). The code continues to evaluate the condition statement and the post statement of the `for` loop until the condition is no longer `true`, that is, until `i >=` `5`.

This loop type (`for`) has many variations and one of the most common ones is the iteration over a container type. Here are two examples:

-   This is an example of iterating over a slice:
    
    ```markup
    func main() {
    ```
    
    ```markup
        slice := []string{"r1", "r2", "r3"}
    ```
    
    ```markup
        for i, v := range slice {
    ```
    
    ```markup
            fmt.Printf("index %d: value: %s\n", i, v)
    ```
    
    ```markup
        }
    ```
    
    ```markup
    }
    ```
    
-   This is an example of iterating over a map:
    
    ```markup
    func main() {
    ```
    
    ```markup
        hashMap := map[int]string{
    ```
    
    ```markup
            1: "r1",
    ```
    
    ```markup
            2: "r2",
    ```
    
    ```markup
            3: "r3",
    ```
    
    ```markup
        }
    ```
    
    ```markup
        for i, v := range hashMap {
    ```
    
    ```markup
            fmt.Printf("key %d: value: %s\n", i, v)
    ```
    
    ```markup
        }
    ```
    
    ```markup
    }
    ```
    

The special `range` keyword loops through all values of a slice or a map, creating a copy of the current item on a new pair of key/value variables for each iteration (`i` and `v` in the examples). You can also use `range` to iterate over arrays and strings. This keyword has special behavior for channels, which we cover later in the _Concurrency_ section.

Another common variation of this loop construct is the infinite loop. You can use this when you don’t know the number of iterations ahead of time, but you know when to stop:

```markup
func main() {
    for {
        time.Sleep(time.Second)
        break
    }
}
```

The key distinction here is the absence of any conditions in the loop definition, which is a shorthand for `true`; that is, the condition statement always evaluates to `true` and the loop iterates infinitely. The only way to stop this kind of loop is to use the `break` keyword.

Go doesn’t have a `while` keyword for loops, which you can find in many other programming languages. But, you can make Go’s `for` loop act in the same way as `while`, by dropping the `init` and `post` statements as the next code example shows:

```markup
func main() {
    i := 0
    for i < 5 {
        fmt.Println(i)
        i++
    }
}
```

Another special keyword worth mentioning in this context is `continue`, which skips the remainder of the current iteration of a loop. The following example prints all numbers from `0` to `4`, but only if they are even:

```markup
func main() {
    // prints 0 2 4
    for i := 0; i < 5; i++ {
        if i % 2 != 0 {
            continue
        }
        fmt.Println(i)
    }
}
```

In this example, we skip numbers that have a non-zero remainder when divided by two with the `if i % 2 != 0` clause. This is a conditional statement, which is the topic of the next section.

## Conditional statements

Control structures help you define the behavior or direction to follow when a program can follow different execution paths.

Let’s start with a two-way conditional statement. We try to connect to a website ([https://www.tkng.io/](https://www.tkng.io/)) and then print the response we receive if the connection is successful, or we return the error message if the `HTTP GET` operation fails. If the error is not null (`err != nil`), we return. Otherwise (`else`), we print the information (`fmt.Printf`):

```markup
func main() {
    resp, err := http.Get("https://www.tkng.io/")
    if err != nil {
            log.Fatalf("Could not connect: %v", err)
    } else {
            fmt.Printf("Received response: %v",
                        resp.Status)
    }
}
```

One way to improve the readability of the preceding example is to left-align the successful execution path of the program, meaning that if one of the branches of the `if` condition ends in a terminating statement, as in our case with `return`, you can drop the entire `else` clause and rewrite the code as follows:

```markup
func main() {
    resp, err := http.Get("https://www.tkng.io/")
    if err != nil {
            log.Fatalf("Could not connect: %v", err)
    }
    fmt.Printf("Received response: %v", resp.Status)
}
```

Like any typical `if`\-`then`\-`else` construct, Go’s conditional statements can encode multi-way conditions with many `if`\-`else` statements. But, Go developers usually prefer to use a `switch` statement in this scenario, because it’s a more concise and readable form of the multi-stage `if`\-`then`\-`else`.

Consider the following example, which sends an `HTTP GET` request and prints a message based on the returned status code. The full code is at `ch03/switch/main.go` (see _Further reading_):

```markup
func main() {
    resp, err := http.Get("http://httpstat.us/304")
    if err != nil {
        log.Fatalf("Could not connect: %v", err)
    }
    switch {
    case resp.StatusCode >= 600:
        fmt.Println("Unknown")
    case resp.StatusCode >= 500:
        fmt.Println("Server Error")
    case resp.StatusCode >= 400:
        fmt.Println("Client Error")
    case resp.StatusCode >= 300:
        fmt.Println("Redirect")
    case resp.StatusCode >= 200:
        fmt.Println("Success")
    case resp.StatusCode >= 100:
        fmt.Println("Informational")
    default:
        fmt.Println("Incorrect")
    }
}
```

You can write this example as a chain of `if`\-`then`\-`else` statements as well, but using `switch` makes your code cleaner, and many Go developers consider it good practice for these situations.

## goto statements

Another way you can transfer the control from one part of a program to another is by using a `goto` statement.

You can use `goto` statements to break out of a nested or infinite loop or to implement logic.

Building upon the preceding code example, let’s see how we can use `goto` statements to implement various exit points from a function. You can find the full code of the example at `ch03/goto/main.go` (see _Further reading_):

```markup
func main() {
    resp, err := http.Get("http://httpstat.us/304")
    if err != nil {
        log.Fatalf("Could not connect: %v", err)
    }
    switch {
    case resp.StatusCode >= 600:
        fmt.Println("Unknown")
        goto exception
    case resp.StatusCode >= 500:
        fmt.Println("Server Error")
        goto failure
    case resp.StatusCode >= 400:
        fmt.Println("Client Error")
        goto failure
    case resp.StatusCode >= 300:
        fmt.Println("Redirect")
        goto exit
    case resp.StatusCode >= 200:
        fmt.Println("Success")
        goto exit
    case resp.StatusCode >= 100:
        fmt.Println("Informational")
        goto exit
    default:
        fmt.Println("Incorrect")
        goto exception
    }
   exception:
    panic("Unexpected response")
   failure:
    log.Fatalf("Failed to connect: %v", err)
   exit:
    fmt.Println("Connection successful")
}
```

The `goto` statements have a somewhat evil reputation in most programming languages because of their power to break the flow of a program, often making it harder to read, with many prominent computer scientists warning against their inconsiderate use. Still, these statements do have their place and you can find them in many projects and even in the Go standard library.

Loops, conditional statements, and things like `goto` help you define the control flow of your Go programs. We still haven’t covered some extra control flow constructs and corner cases used together with channel types. We cover them later in the _Concurrency_ section of this chapter, but before we get there, we first need to talk about another important area of code organization: functions.

Bookmark

# Functions

On the surface, a Go function is exactly the same as in any other programming language: a section of code designed to perform a certain task grouped into a reusable container. Thanks to the static nature of the language, all functions have a signature that defines the number and types of acceptable input arguments and output values.

Consider the following function (`generateName`), which generates a new name based on a pair of input strings (`base` and `suffix`). You can find the full code of the next example at `ch03/functions1/main.go` (see _Further reading_):

```markup
func generateName(base string, suffix string) string {
    parts := []string{base, suffix}
    return strings.Join(parts, "-")
}
func main() {
    s := generateName("device", "01")
    // prints "device-01"
    fmt.Println(s)
}
```

This function’s signature is `func (string, string) string`, meaning that it accepts two arguments of the `string` type and returns another string. You can assign the returned value to a variable or pass it as an argument directly to another function.

Go’s functions are values, which means you can pass them as an input argument and even return them as the output from another function.

To illustrate this, we define a new function named `processDevice`, which takes two parameters, a function with a `func (string, string) string` signature, and a `string`. In the body of this function, two relevant strings are in play: `base`, which is statically set to `device`, and `ip`, which is the string the function receives as the second argument:

```markup
func processDevice(getName func (string, string) string, ip string) {
    base := "device"
    name := getName(base, ip)
    fmt.Println(name)
}
```

The most interesting part of this function is on the second line of its body, where it calls the `getName` function. This function is what `processDevice` received as an argument, which could be any function as long as it takes two strings as arguments and returns just one string. That’s the case with the `generateName` function we defined for an earlier example, which means we can pass `generateName` as an argument to `processDevice` to build a unique device name. Let’s see what this would look like. The code of this example is available at `ch03/functions1/main.go` (see _Further reading_):

```markup
func main() {
    // prints "device-192.0.2.1"
    processDevice(generateName, "192.0.2.1")
}
```

The benefit of this approach is the pluggable nature of the first argument. If we decide at any point that another function (for example, `generateName2`) is a better fit because it uses a different format to join the strings or something else, or maybe you want to make a change to create the device names differently but don’t want to alter the `generateName` function in case you need to roll back your changes quickly, then you can use a temporary `clone` function with a different name where you make the adjustments.

## Function arguments

In Go, we pass the function arguments by value, meaning that Go creates a copy of every input variable and passes that copy to the called function. Go saves the new function-scoped variables in the stack memory, as long as the compiler knows their lifetime and memory footprint at compile time. The stack is a very efficient region in memory designed to store variables that don’t need to be garbage collected, as it allocates or de-allocates memory automatically when the function returns. Memory that needs to be garbage collected goes to another location in memory known as the heap.

Consider the following example of a function attempting to mutate an input string. You can access the code for the next example at `ch03/functions2/main.go` (see _Further reading_):

```markup
type Device struct {
    name string
}
func mutate(input Device) {
    input.name += "-suffix"
}
func main() {
    d := Device{name: "myname"}
    mutate(d)
    // prints "myname"
    fmt.Println(d.name)
}
```

Since Go creates a copy of the input `Device` when passing it as a value to the `mutate` function, any changes that happen to that `Device` inside the body of this function are not visible outside of it, hence it doesn’t affect the original variable, `d`. That is why `d.name` prints `myname` and not `myname-suffix`.

In Go, we have two types of data we can work with: values and the memory addresses of those values (pointers). With this in mind, there are two ways to implement the desired (mutating) behavior when passing values to a function:

-   Change the function to return the mutated value and assign it to a variable. Still, this does not really mutate the original value but actually generates a new one instead.

Change the function to accept a pointer to a variable that stores a `Device`. This is what our program would look like in this case:

```markup
type Device struct {
    name string
}
func mutate(input *Device) {
    input.name += "-suffix"
}
func main() {
    d := Device{name: "myname"}
    mutate(&d)
    // prints "myname-suffix"
    fmt.Println(d.name)
}
```

Pointers are a common way of sharing data across program boundaries in Go, such as function calls. In this case, we still pass the input argument by value (`&d`), but this time, the value we copy and pass is a pointer to a memory address, instead of the actual content of the `d` variable. Now, when you change what that memory address is pointing to, you are mutating the value of the original `d` variable:

![Figure 3.8 – Values and pointers](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.8.jpg)

Figure 3.8 – Values and pointers

Go pointers are a powerful idea. The key operations you need to be aware of are as follows:

-   Taking an address of a variable using the `&` operator
-   Dereferencing a pointer, that is, getting the address of the referenced value using the `*` operator

Whenever you need to change the value of a variable, or when a variable is big enough to make copying it inefficient, you need to make sure that you pass it by a pointer. This rule applies to all the primitive types — `integer`, `string`, `boolean`, and so on.

A couple of types in Go do not hold the actual value but point to its memory address instead. While these are internal implementation details, it’s something worth keeping in mind. For example, channels and maps are two types that are actually pointers to internal data structures (runtime types). This means that even if you pass them around by value, you end up mutating the contents of the channel or map. The same, by the way, applies to functions.

See the following example where we pass a map (`m`) by value to a function (`fn`). This function adds a new key-value pair to the map, a value that the outer function (`main`) can access as well:

```markup
func fn(m map[int]int) {
    m[1] = 11
}
func main() {
    m := make(map[int]int)
    fn(m)
    // prints 11
    fmt.Println(m[1])
}
```

In the _Go’s type system_ section in this chapter, we learned that a slice is a type in Go that stores metadata about the underlying data along with a pointer to it. It may be tempting to assume that you can pass around this data type as a value and be able to mutate it. But, while this data structure has a pointer in it, you also create a copy of the rest of the metadata values (length and capacity), creating a disconnection between the slice in the called and calling functions.

For this reason, mutations in slices may have an unpredictable result. In-place changes may be visible but appends may not. This is why they always recommend passing them as pointers to avoid subtle bugs such as the following one:

```markup
func mutateV(input []string) {
    input [0] = "r03"
    input  = append(input , "r04")
}
func main() {
    d1 := []string{"r01", "r02"}
    mutateV(d1)
    // prints "[r03 r02]"
    fmt.Printf("%v\n", d1)
}
```

You can avoid this bug if you use a pointer instead, in which case, all changes to the underlying slice are reflected in the outer context:

```markup
func mutateP(input *[]string) {
    (*input)[0] = "r03"
    *input = append(*input, "r04")
}
func main() {
    d2 := []string{"r01", "r02"}
    mutateP(&d2)
    // prints "[r03 r02 r04]"
    fmt.Printf("%v\n", d2)
}
```

The full code for both of these examples is at `ch03/mutate-slice/main.go` (see _Further reading_).

## Error handling

In Go, errors are not exceptions that you have to handle somewhere else in the code. We handle them as they come along. An error might require you to immediately stop the execution of a program, or maybe you could continue to run the program and propagate the error to another part of the program or the user so they can make an informed decision about what to do with this error. Remember, _don’t just check errors, handle_ _them gracefully_.

When it comes to writing functions, the rule of thumb is that if a function is likely to run into an error, it must return it to the caller:

```markup
func makeCall(url string) (*http.Response, error) {
    resp, err := http.Get("example.com")
    if err != nil {
        return nil, fmt.Errorf("error in makeCall: %w",
                                err)
    }
    return resp, nil
}
```

The error message should be meaningful and offer enough context to the user to be able to identify the cause of the error and the place in the code where it happened. It’s up to the caller of this function to decide what to do with this error from the following possible actions:

-   Log it and continue.
-   Ignore it.
-   Interrupt execution and panic.
-   Pass it up to the outer function.

## Methods

Methods are a way of adding behavior to user-defined types, which, by default, can only store values. If you want those types to act, you can add a special function that would contain the name of the associated data type (method receiver) between the `func` keyword and the function name, such as `GetFullName` in the next example:

```markup
type Device struct {
    name string
}
func (d Device) GetFullName() string {
    return d.name
}
func main() {
    d1 := Device{name: "r1"}
    // prints "r1"
    fmt.Println(d1.GetFullName())
}
```

In all aspects, methods are just like functions — they accept zero or more arguments and return zero or more values. The biggest difference is that methods also have access to their receiver and can at the very least read its fields, as you’ve seen in the preceding example.

It’s also possible to create a method that mutates the receiving type by defining it on a pointer:

```markup
type Device struct {
    name string
}
func (d *Device) GenerateName() {
    d.name = "device-" + d.name
}
func (d Device) GetFullName() string {
    return d.name
}
func main() {
    d2 := Device{name: "r2"}
    d2.GenerateName()
    // prints "device-r2"
    fmt.Println(d2.GetFullName())
}
```

In this case, we define the `GenerateName` method on a pointer receiver and, thus, can safely set, delete or change its values — all these changes are visible in the outer scope.

The full code for the method code examples is available at `ch03/methods/main.go` (see _Further reading_).

## Variadic functions

So far, we’ve only seen examples with functions that take a strictly pre-defined number of arguments. But, that’s not the only option in Go; you can actually pass an arbitrary number of arguments to a function as long as you meet the following conditions:

-   All extra arguments are of the same type.
-   They are always the last arguments to a function.

The function signature looks slightly different. All extra arguments are automatically grouped into a slice and you denote them with three dots (`...`) before their type:

```markup
func printOctets(octets ...string) {
    fmt.Println(strings.Join(octets, "."))
}
func main() {
    // prints "127.1"
    printOctets("127", "1")
    ip := []string{"192", "0", "2", "1"}
    // prints "192.0.2.1"
    printOctets(ip...)
}
```

One benefit of variadic arguments, compared to declaring them as a slice argument instead, is the flexibility; you don’t have to create a slice before calling a function, and you can completely omit any trailing arguments if they are not needed and still satisfy the function’s signature.

The full code for the variadic code example is available at `ch03/variadic/main.go` (see _Further reading_).

## Closures

Functions in Go have different properties. They are values, so a function can accept another one as its argument.

Another interesting property is that when one function (outer) returns another function (inner), the inner function remembers and it has complete access to all variables that you defined in the scope of the outer function.

This is what’s called a **function closure**, and here’s a canonical example of how you can use it to generate a sequence of numbers. Here, the inner anonymous function with the `func() string` signature mutates the `i` variable defined in the `suffixGenerator` outer function every time it’s called:

```markup
func suffixGenerator() func() string {
    i := 0
    return func() string {
        i++
        return fmt.Sprintf("%02d", i)
    }
}
func main() {
    generator1 := suffixGenerator()
    // prints "device-01"
    fmt.Printf("%s-%s\n", "device", generator1())
    // prints "device-02"
    fmt.Printf("%s-%s\n", "device", generator1())
    generator2 := suffixGenerator()
    // prints "device-01"
    fmt.Printf("%s-%s\n", "device", generator2())
}
```

Every time we call `suffixGenerator`, we assign a new instance of the anonymous function it returns to a variable. `generator1` and `generator2` are now functions that keep track of the number of times we call each one.

Closures are a popular technique to create a surrounding context (environment). For example, API call functions in middleware software use closures to perform logging and telemetry data collection on every call, without the API caller needing to care about those details.

## Defer

When writing a program that opens remote network connections or local files, it’s important to promptly close these as soon as you no longer need them to prevent resource leaks — all operating systems have limitations on the number of open files or connections.

Go’s idiomatic way of dealing with this class of problems is to address them as early in the code as possible with the help of the `defer` statement. You should place this statement right next to the `open`/`connect` function call. Go only evaluates this statement when the function returns.

In the following example, the two `defer` statements run only _after_ the final statement of the function:

```markup
func main() {
    resp, err := http.Get("http://example.com")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    defer fmt.Println("Deferred cleanup")
    fmt.Println("Response status:", resp.Status)
}
```

You can stack together many `defer` statements to perform staged cleanup. They execute in last-in-first-out order – `Println("Deferred cleanup")` runs before `resp.Body.Close()`. This is what you see when you run this program:

```markup
ch03/defer$ go run main.go
Response status: 200 OK
Deferred cleanup
```

The full code for this code example is available at `ch03/defer/main.go` (see _Further reading_).

Now that we’ve covered the Go functions fundamentals, it’s time to move onto the next level of abstraction that describes object behaviors through a unique set of methods: interfaces.

Bookmark

# Interfaces

Interfaces are one of the most powerful constructs in Go, so it’s very important to understand what they do and when you can use them. From a purely theoretical point of view, interfaces are an abstract type. They do not contain implementation details but define a set of behaviors through method signatures.

If a Go type defines all method signatures declared by an interface, this Go type _implements_ that interface implicitly, with no explicit declaration. This is how Go deals with common behaviors exhibited by more than one type, and what other languages often express through object inheritance.

## Network automation example

To introduce the idea, we use a contrived network automation example. Let’s say we are developing a Go package to deal with common tasks across different network devices. We model a Cisco IOS XE device as a `CiscoIOS` type with two fields — one that identifies the hostname of a device (`Hostname`) and another that identifies the underlying hardware platform (`Platform`). For this `CiscoIOS` type, we define a method that gets us the uptime of a device (`getUptime`) as an integer. Finally, we define a function to compare two devices and find out which one has been running longer without a reboot:

```markup
type CiscoIOS struct {
    Hostname string
    Platform string
}
func (r CiscoIOS) getUptime() int {
    /* ... <omitted for brevity > ... */
}
func LastToReboot(r1, r2 CiscoIOS) bool {
    return r1.getUptime() < r2.getUptime()
}
```

Everything works fine until we add another platform to the mix. Let’s say we now also have a `CiscoNXOS` type and it has `Hostname` and `Platform` fields, but it also has a Boolean `ACI` field to show whether this switch is ACI-enabled. As with the `CiscoIOS` type, we define a method that returns the uptime of a `CiscoNXOS` device:

```markup
type CiscoNXOS struct {
    Hostname string
    Platform string
    ACI      bool
}
func (s CiscoNXOS) getUptime() int {
    /* ... <omitted for brevity > ... */
}
```

The challenge now is to compare the uptime of a `CiscoNXOS` device type with the uptime of a `CiscoIOS` device type. The `LastToReboot` function signature tells us it only accepts variables of a `CiscoIOS` type as an argument, so we cannot pass an element of a `CiscoNXOS` type to it.

You can fix this by creating an interface. By doing this, you abstract away the implementation details of the device and only focus on the need to present the device uptime as an integer via the `getUptime` function. Let’s call this interface `NetworkDevice`:

```markup
type NetworkDevice interface {
    getUptime() int
}
```

The next step is to change the `LastToReboot` function to accept a `NetworkDevice` type instead of `CiscoIOS`, as in the next code snippet:

```markup
func LastToReboot(r1, r2 NetworkDevice) bool {
    return r1.getUptime() < r2.getUptime()
}
```

Because both `CiscoIOS` and `CiscoNXOS` have a `getUptime() int` method, they implicitly satisfy the `NetworkDevice` interface, hence you can pass either one of them as a parameter to the `LastToReboot` function. A **sample program** (see _Further reading_) that uses these definitions to compare the uptime of these two device types would look as follows:

```markup
func main() {
    ios := CiscoIOS{}
    nexus := CiscoNXOS{}
    if LastToReboot(ios, nexus) {
        fmt.Println("IOS-XE has been running for less time, so it was the last to be rebooted")
        os.Exit(0)
    }
    fmt.Println("NXOS was the last one to reboot")
}
```

Interfaces can help you scale your programs. The interface `NetworkDevice` enables us to add any number of device types. It’s not only a great resource for good code design but also to set clear expectations of what the data should do in an API, regardless of what the data is. In the example, we don’t care what operating system the device is running, only that we have a method available to get its uptime as an integer.

## Standard library example

For a more real-world example, let’s turn our attention to the `net` package in the standard library, which has an interface that represents a network connection (`Conn`). Interface fields are often verbs that describe behavior and not state (for example, `SetDeadline` for the `Conn` interface). By contrast, a more descriptive name for the `RemoteAddr` method might have been `getRemoteAddr`:

```markup
// src/net/net.go
// Conn is a generic stream-oriented network connection.
type Conn interface {
    /* ... <omitted for brevity > ... */
    // LocalAddr returns the local network address.
    LocalAddr() Addr
    // RemoteAddr returns the remote network address.
    RemoteAddr() Addr
    SetDeadline(t time.Time) error
    SetReadDeadline(t time.Time) error
    SetWriteDeadline(t time.Time) error
}
```

The standard library includes several implementations of this interface. One of them is in the `crypto/ssh` library, through the `chanConn` concrete type. A concrete type is any non-interface type that stores its own data and, in this case, `chanConn` stores values for local (`laddr`) and remote (`raddr`) addresses of a **Secure Shell Protocol** (**SSH**) connection.

This type also defines methods, such as `LocalAddr() net.Addr` and `SetReadDeadline(deadline time.Time) error`. In fact, it has all methods of the `net.Conn` interface, hence it satisfies the interface:

```markup
// ssh/tcpip.go
// chanConn fulfills the net.Conn interface without
// the tcpChan having to hold laddr or raddr directly.
type chanConn struct {
    /* ... <omitted for brevity > ... */
    laddr, raddr net.Addr
}
// LocalAddr returns the local network address.
func (t *chanConn) LocalAddr() net.Addr {
    return t.laddr
}
// RemoteAddr returns the remote network address.
func (t *chanConn) RemoteAddr() net.Addr {
    return t.raddr
}
func (t *chanConn) SetDeadline(deadline time.Time) error {
    if err := t.SetReadDeadline(deadline); err != nil {
        return err
    }
    return t.SetWriteDeadline(deadline)
}
func (t *chanConn) SetReadDeadline(deadline time.Time) error {
    return errors.New("ssh: tcpChan: deadline not supported")
}
func (t *chanConn) SetWriteDeadline(deadline time.Time) error {
    return errors.New("ssh: tcpChan: deadline not supported")
}
```

Now, any function that accepts `net.Conn` as input can take `chanConn` as well. Or vice versa, if a function returns `net.Conn`, it can also return `chanConn`, as in the next example from the same source code file:

```markup
// ssh/tcpip.go
// Dial initiates a conn to the addr from remote host.
// Resulting conn has a zero LocalAddr() and RemoteAddr().
func (c *Client) Dial(n, addr string) (net.Conn, error) {
    var ch Channel
    switch n {
    case "tcp", "tcp4", "tcp6":
    // Parse the address into host and numeric port.
    host, portString, err := net.SplitHostPort(addr)
    if err != nil {
        return nil, err
    }
    /* ... <omitted for brevity > ... */
    return &chanConn{
        Channel: ch,
        laddr:   zeroAddr,
        raddr:   zeroAddr,
    }, nil
    /* ... <omitted for brevity > ... */
}
```

Don’t worry if these code snippets look daunting to you. These come from the actual SSH package of the Go standard library, so this is as complex as it gets.

## Interfaces as contracts

Interfaces are a valueless type; they only define method signatures. You can define a variable of an interface type, but you can only assign a concrete implementation of this interface as the value of this variable.

In the next code example, the `r` variable is of the `io.Reader` type, which is an interface. At that point, we know nothing about this variable but we do know that whatever value we assign to this variable must satisfy the `io.Reader` interface in order for the compiler to accept it.

In this case, we’re using `strings.NewReader("text")`, which implements the `io.Reader` interface to read from a `string` value that gets passed as an argument:

```markup
func main() {
    var r io.Reader
    r = strings.NewReader("a random text")
    io.Copy(os.Stdout, r)
}
```

The last line of code copies what we read to standard output (`Stdout`) or the user’s screen. The `io.Copy` function copies from `io.Reader` (`r`) to `io.Writer` (`os.Stdout` satisfies this interface), so we can copy from the string to the terminal.

While this looks a bit more complicated than just printing the string with `fmt.Println`, interfaces make our code more versatile, allowing you to replace either the source or destination of the data in the example without too much effort. This is possible because the `io.Reader` and `io.Writer` interfaces serve as a contract between both the `io.Copy()` consumer and the `strings.NewReader` and `os.Stdout` providers, ensuring they both conform to the rules defined by this interface.

Interfaces allow you to define a clear division between different modules of a program and offer an API where users can define the implementation details. In the next section, we examine in detail the `io.Reader` and `io.Writer` interfaces and their role in **input/output** (**I/O**) operations.

Bookmark

# Input and output operations

A common operation in a program is to move data around and reformat it. For example, you can open a file, load its content in memory, encode it to a different format, maybe `jpeg`, and then write it to a file on the disk. This is where the `io.Reader` and `io.Writer` interfaces play a key role in Go’s I/O model, as they allow you to stream data from a source to a destination via a transfer buffer. This means you don’t need to load the entire file in memory to encode it and write it to the destination, making the process more efficient.

## The io.Reader interface

The `io` package in the standard library defines one of the most popular interfaces in Go, the `io.Reader` interface, which can read a stream of bytes (`p`). It returns the number of bytes read (`n`) and any error encountered (`err`):

```markup
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

Any concrete type that has a `Read` with this signature implements the `io.Reader` interface. You don’t need to do anything else:

![Figure 3.9 – The io.Reader interface](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.9.jpg)

Figure 3.9 – The io.Reader interface

The `strings.Reader` type (in the `strings` package of the standard library) has a method with the `Read(p []byte) (n int, err error)` signature, hence it satisfies the `io.Reader` interface. The `strings` package also provides a convenient `NewReader` function that returns a pointer to a new instance of the `strings.Reader` type. The following is an actual snippet from the `strings` package source code:

```markup
// src/strings/reader.go
// A Reader implements the io.Reader, ...
// from a string.
type Reader struct {
    s        string
    i        int64 // current reading index
    prevRune int   // index of previous rune; or < 0
}
// Read implements the io.Reader interface.
func (r *Reader) Read(b []byte) (n int, err error) {
    if r.i >= int64(len(r.s)) {
        return 0, io.EOF
    }
    r.prevRune = -1
    n = copy(b, r.s[r.i:])
    r.i += int64(n)
    return
}
// NewReader returns a new Reader reading from s.
func NewReader(s string) *Reader { return &Reader{s, 0, -1} }
```

The preceding code also shows a concrete `Reader` implementation (with data fields) that has a `Read` method.

## The io.Writer interface

The `io` package also specifies the `io.Reader` interface, which can write `len(p)` bytes to the underlying data stream. It returns the number of bytes written (`n`) and any error encountered that caused the write to stop early (`err`):

```markup
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Any concrete type that has a `Write` method with this signature implements the `io.Writer` interface:

![Figure 3.10 – The io.Writer interface](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.10.jpg)

Figure 3.10 – The io.Writer interface

One example is `os.File` in the `os` package of the standard library. It has a method with the `Write(p []byte) (n int, err error)` signature, hence it satisfies the `io.Writer` interface:

```markup
// src/os/types.go
// File represents an open file descriptor.
type File struct {
    *file // os specific
}
// Read reads up to len(b) bytes from the File.
// It returns the number of bytes read and any error.
// At end of file, Read returns 0, io.EOF.
func (f *File) Read(b []byte) (n int, err error) {
    if err := f.checkValid("read"); err != nil {
        return 0, err
    }
    n, e := f.read(b)
    return n, f.wrapErr("read", e)
}
func Create(name string) (*File, error) {
    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
```

The `os` package also offers a convenient `Create` function that returns a pointer to an `os.File` from a file location. The preceding is an actual snippet from the `os` package source code.

## The io.Copy function

The `io.Copy` function allows you to copy data from a source to a destination, as we discussed at the end of the _Interfaces_ section. Even though you pass concrete type data to this function, `io.Copy` actually doesn’t care what the data is, as it takes interface types as an argument, so it’s interested in what the data can do instead. It needs a readable source and a writable destination:

```markup
// src/io/io.go
// Copy copies from src to dst until either EOF is reached
// on src or an error occurs.
func Copy(dst Writer, src Reader) (written int64, err error) {
    return copyBuffer(dst, src, nil)
}
```

As _Figure 3__.11_ shows, `io.Copy` uses a 32 KB transfer buffer to stream the data from the source to the destination:

![Figure 3.11 – The io.Copy function](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.111.jpg)

Figure 3.11 – The io.Copy function

Let’s test this. We can get an `io.Reader` from a string built with `strings.NewReader`, and `os.Create` gives us an `io.Writer`, which writes to a file on the disk. You can follow along with the code at `ch03/io-interface1/main.go` (see _Further reading_):

```markup
func main() {
    src := strings.NewReader("The text")
    dst, err := os.Create("./file.txt")
    if err != nil {
        panic(err)
    }
    defer dst.Close()
    io.Copy(dst, src)
}
```

While, in this case, we select a string and a file combination, you can use the same `io.Copy` function to read from the network and print to the terminal, for example. For now, let’s inspect the file we just produced:

```markup
ch03/io-interface1$ go run main.go
ch03/io-interface1$ cat file.txt
The text
```

Let’s examine a network-related example. The `net/http` package has the `Get` function that takes a URL (`string`) and returns a pointer to a `http.Response`, which has a field (`Body`) that satisfies the `io.Reader` interface, and the `os.Stdout` terminal satisfies the `io.Writer` interface. This gives us another combination to try out. Let’s see it in action. The code is very close to what we ran before, and is available at `ch03/io-interface2/main.go` (see _Further reading_):

```markup
func main() {
    res, err := http.Get("https://www.tkng.io/")
    if err != nil {
        panic(err)
    }
    src := res.Body
    defer src.Close()
    dst := os.Stdout
    io.Copy(dst, src)
}
```

The same `io.Copy` function now allows us to take the content from a URL and print it to the terminal:

```markup
ch03/io-interface2$ go run main.go
<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.74.3"><meta name=description content="The Kubernetes Networking Guide">...
```

With `io.Copy`, we move data from one point to another. Now, we need to add another piece to the puzzle to transform the data as we stream it.

## Composition

One way to transform the data as we stream it is by embedding one struct type into another, which we know as **composition**. This way, we can chain together several `io.Reader` or `io.Writer` interfaces to perform one or more operations and not just copy the data from source to destination.

The benefit of following this pattern is to write reusable segments of code, which you can use for any `io.Reader` or `io.Writer` interface in this case. Let’s look at the example at `ch03/reader/main.go` (see _Further reading_):

```markup
type myReader struct {
    src io.Reader
}
func (r *myReader) Read(buf []byte) (int, error) {
    tmp := make([]byte, len(buf))
    n, err := r.src.Read(tmp)
    copy(buf[:n], bytes.Title(tmp[:n]))
    return n, err
}
func NewMyReader(r io.Reader) io.Reader {
    return &myReader{src: r}
}
```

We define a new `myReader` type with a single `src` field of the `io.Reader` type. In Go, when we embed a type, the methods of that type become methods of the outer type, so `myReader` has a `Read` method from `src` now.

But, we want to change the behavior and do something with the data. Hence, we define a new `Read` method that takes precedence over any other more deeply nested method part of the type.

In this `Read` method, we read from the buffer and convert it to title case with `bytes.Title`, assuming we are working with strings. Last but not least, `NewMyReader` is what glues together an existing reader with this new one, connecting the dots between two pieces of code. Let’s see it in action:

```markup
func main() {
    r1 := strings.NewReader("network automation with go")
    r2 := NewMyReader(r1)
    io.Copy(os.Stdout, r2)
}
```

We create a reader from a string in `r1` and then use that as the input for `myReader` in `r2`:

```markup
ch03/reader$ go run main.go
Network Automation With Go
```

When we now copy from `r2` to `os.Stdout`, we read from the string and also change the content to title case before writing it to the terminal.

Input and output primitives are present in almost every Go library. The next section is no exception. Encoding and decoding in Go take full advantage of the `io.Reader` and `io.Writer` interfaces.

Bookmark

# Decoding and encoding

One of the most common network automation tasks is the ingesting and processing of structured data. You can retrieve data from or send it to a remote location or even store it on a local disk. Regardless of its location, you have to convert this data into an appropriate format. Encoding, or marshaling, is the process of transforming bytes from a Go data structure into a structured textual representation. Decoding, or unmarshalling, is the reverse process of populating Go values with externally sourced data.

Some examples of structured data encoding schemes are YAML, JSON, XML, and Protocol Buffers. Go’s standard library includes packages that implement encoding and decoding for most of these popular formats, and they all leverage the `io.Reader` and `io.Writer` interface primitives that we learned about in the last section.

In this section, we go through how Go deals with the following tasks:

-   Using tags to annotate Go structs to help libraries encode and decode structured data
-   Parsing of structured data using the empty interface
-   Performing deeply nested set and lookup operations using third-party libraries

## Decoding

We start our overview with decoding, as this is usually one of the first steps in a network automation pipeline. Let’s assume that we’re building a program that needs to interact with various remote network devices. We store the information of these devices in an inventory file we save on a local disk.

### Decoding JSON

In the first example, we see how to deal with a JSON inventory (`input.json`). All outputs of this part are available in the `ch03/json` folder of the book’s repository (see _Further reading_):

```markup
{
  "router": [
    {
      "hostname": "router1.example.com",
      "ip": "192.0.2.1",
      "asn": 64512
    },
    {
      "hostname": "router2.example.com",
      "ip": "198.51.100.1",
      "asn": 65535
    }
  ]
}
```

In the first code example in `ch03/json/main.go` (see _Further reading_), we define a couple of Go structs that can hold the JSON input data from the preceding output in memory. We call the first type `Router`, which has `Hostname`, `IP`, and `ASN` fields. The other type is `Inventory`, which stores a list of routers. The fields in the `Router` type have optional tags such as `json:"key"` to denote alternative key names in the original JSON structure:

```markup
type Router struct {
    Hostname string `json:"hostname"`
    IP       string `json:"ip"`
    ASN      uint16 `json:"asn"`
}
type Inventory struct {
    Routers []Router `json:"router"`
}
```

To read from a file, we create an `io.Reader` type (`file`) from the input file with `os.Open`:

```markup
func main() {
    file, err := os.Open("input.json")
    // process error
    defer file.Close()
    /* ... <continues next > ... */
}
```

Now, the `json` library, as well as any other encoding library, has a function that allows you to pass an `io.Reader` type as an argument to extract data from it. This means it can decode from a file, a string, a network connection, or anything else that implements the `io.Reader` interface with the same function call:

```markup
func main() {
    /* ... <continues from before > ... */
    d := json.NewDecoder(file)
    /* ... <continues next > ... */
}
```

Once you’ve created a decoder, you can use the `Decode` method to read and parse the contents of the JSON file into a variable (`inv`) of the `Inventory` type. Remember, to mutate the data struct, you need to pass it as a pointer:

```markup
func main() {
    /* ... <continues from before > ... */
    var inv Inventory
    err = d.Decode(&inv)
    // process error
    fmt.Printf("%+v\n", inv)
}
```

If you print the `inv` variable now, you would see it populate with data from the inventory JSON file:

```markup
ch03/json$ go run main.go
{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}
```

### Decoding into an empty interface

The field tags we’ve just seen are a very convenient way to map data during encoding and decoding. The condition to have all Go types predefined ahead of time offers type safety, but at the same time, you can see it as a major detractor if you are coming from another language where the decoding process does not need this.

But, you can also skip this in Go, with a few caveats that we discuss later. To show you how it works, we use a slightly different version of an earlier example. This new version is available in the `ch03/json-interface` folder (see _Further reading_). Instead of defining all Go structs, we use a special variable of the `map[string]interface{}` type and pass it as an argument to the `Decode` method call:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    var empty map[string]interface{}
    err = d.Decode(&empty)
    // process error
    // prints map[router:[map[asn:64512 hostname:router1.example.com
    // ip:192.0.2.1] map[asn:65535 hostname:router2.example.com
    // ip:198.51.100.1]]]
    fmt.Printf("%v\n", empty)
    /* ... <continues next > ... */
}
```

An _empty interface_, or `interface{}`, doesn’t define any methods, which means it can hold any value — `integer`, `string`, `float`, or user-defined. The only caveat is that, since Go is a statically typed language, those values remain an empty interface until we do an explicit type conversion, that is, until we tell Go what type we expect to see.

From the output of the empty variable of the `map[string]interface{}` type, where we decoded the JSON content in the preceding example, we see that the value of the map we print is an array. To parse these values and print them individually, we’d have to tell Go to treat them as a slice of unknown values, which you can express as `[]interface{}`:

```markup
func main() {
    /* ... <continues from before > ... */
    for _, r := range empty["router"].([]interface{}) {
        fmt.Printf("%v\n", r)
    }
}
```

The output of these print statements is the string representation of two `map[string]interface{}` maps, which means we’ve only parsed the keys (as strings), but the values are still undefined:

```markup
ch03/json-interface $ go run main.go
...
map[asn:64512 hostname:router1.example.com ip:192.0.2.1]
map[asn:65535 hostname:router2.example.com ip:198.51.100.1]
```

We could continue this process until we find the right type for all values of this object, but this process is obviously quite tedious. This is why we mainly see this approach in encoding libraries or as a troubleshooting step to take a quick glance at the structure of the potentially unknown input data.

Another option for quick operations with JSON data is external Go packages, which you can use to perform deep JSON lookup (**GJSON**) and set (**SJSON**) operations without having to build structs for the entire object. In both cases, the parsing still happens behind the scenes, but the user is only presented with their data or an error if the key doesn’t exist. We use GJSON (see _Further reading_) in a gRPC example in [_Chapter 8_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_08.xhtml#_idTextAnchor182), _Network APIs_.

### Decoding XML

While the XML input file looks different, the data is the same and the Go program doesn’t change much. The next example is in the `ch03/xml` folder of the book’s repository (see _Further reading_):

```markup
<?xml version="1.0" encoding="UTF-8" ?>
<routers>
  <router>
    <hostname>router1.example.com</hostname>
    <ip>192.0.2.1</ip>
    <asn>64512</asn>
  </router>
  <router>
    <hostname>router2.example.com</hostname>
    <ip>198.51.100.1</ip>
    <asn>65535</asn>
  </router>
</routers>
```

If we compared the final program with the one we did for JSON, we would notice four changes:

-   We import `encoding/xml` instead of `encoding/json`.
-   We use XML tags `xml:"hostname"` instead of the JSON equivalents for struct fields.
-   The input file is a `.``xml` file.
-   We use the `NewDecoder` function from the `xml` library instead.

The rest of the code remains exactly the same. The next code output highlights the actual lines that change; we omitted the rest of the lines as they are the same as in the JSON example:

```markup
package main
import (
    "os"
    "encoding/xml"
)
type Router struct {
    Hostname string `xml:"hostname"`
    IP       string `xml:"ip"`
    ASN      uint16 `xml:"asn"`
}
type Inventory struct {
    Routers []Router `xml:"router"`
}
func main() {
    file, err := os.Open("input.xml")
    /* ... <omitted for brevity > ... */
    d := xml.NewDecoder(file)
    /* ... <omitted for brevity > ... */
}
```

Just like JSON, XML has its own external libraries that can help you deal with complex input data without having to build the hierarchy of Go types. One of them is the `xmlquery` package (see _Further reading_), which lets you make XML Path Language (XPath) queries from Go.

### YAML

Now, let’s look at how we would parse a YAML inventory. You can find this example in the `ch03/yaml` directory of the book’s repository (see _Further reading_):

```markup
router:
  - hostname: "router1.example.com"
    ip: "192.0.2.1"
    asn: 64512
  - hostname: "router2.example.com"
    ip: "198.51.100.1"
    asn: 65535
```

By now, you would probably already have guessed that the number and nature of things that change from the JSON example are the same as for XML, which is to say, not much. The following code snippet highlights only the changed lines of code, and you can find the full code example at `ch03/yaml/main.go` (see _Further reading_):

```markup
package main
import (
    "os"
    "gopkg.in/yaml.v2"
)
type Router struct {
    Hostname string `yaml:"hostname"`
    IP       string `yaml:"ip"`
    ASN      uint16 `yaml:"asn"`
}
type Inventory struct {
    Routers []Router `yaml:"router"`
}
func main() {
    /* ... <omitted for brevity > ... */
    d := yaml.NewDecoder(file)
    /* ... <omitted for brevity > ... */
}
```

This Go program produces the same result as both the JSON and XML examples, but before we can run it, we need to go get the external YAML library dependency first (`gopkg.in/yaml.v2`):

```markup
ch03/yaml$ go get gopkg.in/yaml.v2
go get: added gopkg.in/yaml.v2 v2.4.0
ch03/yaml$ go run main.go
{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}
```

It’s also possible to parse and query YAML documents without having to predefine data structures. One tool that does that is `yq` (see _Further reading_), which implements a shell CLI tool in Go in the style of `jq` (the `sed` for JSON data). You can use `yq` in your Go program via its built-in `yqlib` package.

## Encoding

Just as important as being able to decode data from a source is processing the data in the opposite direction, producing a structured data document based on an in-memory data model. In the next example, we pick up where we left off in the _Decoding_ section and take the in-memory data we got from a JSON input file to output a corresponding XML document.

One of the first things we have to do in the code is to update the struct tags with an extra key-value pair for XML. Although this is not strictly necessary, as the XML library can fall back to using field names instead, it’s generally considered a best practice to annotate explicitly all relevant fields that you encode:

```markup
type Router struct {
    Hostname string `json:"hostname" xml:"hostname"`
    IP       string `json:"ip" xml:"ip"`
    ASN      uint16 `json:"asn" xml:"asn"`
}
type Inventory struct {
    Routers []Router `json:"router" xml:"router"`
}
```

The full code of this example is available in the `ch03/json-xml` directory (see _Further reading_) of the book’s repository, so for the sake of brevity, we only include the extra code that we add to encode the `inv` variable into an XML document:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    var dest strings.Builder
    e := xml.NewEncoder(&dest)
    err = e.Encode(&inv)
    // process error
    fmt.Printf("%+v\n", dest.String())
}
```

To produce a string output, we’re using the `strings.Builder` type, which implements the `io.Writer` interface required by the `Encode` method. This highlights the power of interfaces, as we could have passed in a network connection and sent the XML data to a remote host instead, with almost the same program. The next snippet shows the output of the program:

```markup
ch03/json-xml$ go run main.go
<Inventory><router><hostname>router1.example.com</hostname><ip>192.0.2.1</ip><asn>64512</asn></router><router><hostname>router2.example.com</hostname><ip>198.51.100.1</ip><asn>65535</asn></router></Inventory>
```

One encoding format we haven’t covered yet is Protocol Buffers, which is part of the gRPC section of [_Chapter 8_](https://subscription.imaginedevops.io/book/cloud-and-networking/9781800560925/2B16971_08.xhtml#_idTextAnchor182).

At this point, we’ve covered enough Go language theory to write effective programs to interact with and automate a network device. The only bit that we have left, which is also one of the most salient features of the language, is concurrency.

Bookmark

# Concurrency

If there was one feature that would characterize Go amongst other popular programming languages, it would be concurrency. Go’s built-in concurrency primitives (goroutines and channels) are one of the best abstractions we know for writing efficient code that can run more than one task simultaneously.

Your program starts in the main goroutine, but at any point, you can spawn other concurrent goroutines and create communication channels between them. You can do this with considerably less effort and less code compared to other programming languages, which improves the developing experience and your code’s support:

![Figure 3.12 – Go’s concurrency](https://static.packt-cdn.com/products/9781800560925/graphics/image/Figure_3.121.jpg)

Figure 3.12 – Go’s concurrency

In this section, we cover the following concurrency primitives:

-   Goroutines and the use of the `sync` package for their coordination
-   How we use channels to send and receive data between goroutines
-   The use of mutexes with data shared between different goroutines

## Goroutines

One way to think of Goroutines is as user-space threads that the Go runtime manages. They are computationally cheap to spawn and manage, so they can scale to hundreds of thousands, even on an average machine, with memory being the primary limiting factor.

It’s typical to create goroutines for tasks that may block the execution of the main function. You can imagine why this would be particularly helpful in a network automation context, where we have to deal with remote network calls and wait for network devices to execute the commands.

We introduce the basic goroutine theory by building another network automation example. In the preceding section, we learned how to load and parse a device inventory. In this section, we pick up where we left off and see how to interact with these network devices.

To start off, we use an inventory file (`input.yml`) with a single device. This file is in the `ch03/single` folder (see _Further reading_) of the book’s repository:

```markup
router:
- hostname: sandbox-iosxe-latest-1.cisco.com
  platform: cisco_iosxe
  strictkey: false
  username: developer
  password: C1sco12345
```

To store this inventory, we define a type hierarchy like the one we had in the encoding/decoding section. The code example output only shows some fields for brevity:

```markup
type Router struct {
    Hostname  string `yaml:"hostname"`
    /* ... <omitted for brevity > ... */
}
type Inventory struct {
    Routers []Router `yaml:"router"`
}
```

We define another function called `getVersion` that accepts an argument of the `Router` type, connects and retrieves the software and hardware version information, and prints it on a screen. The exact implementation of this function is not important and we don’t focus on it in this chapter yet, but you can see the full code example at `ch03/single/main.go` (see _Further reading_):

```markup
func getVersion(r Router) {
    /* ... <omitted for brevity > ... */
}
func main() {
    src, err := os.Open("input.yml")
    //process error
    defer src.Close()
    d := yaml.NewDecoder(src)
    var inv Inventory
    err = d.Decode(&inv)
    // process error
    getVersion(inv.Routers[0])
}
```

Since we only have one device in the inventory, we can access it directly using a slice index. The execution of this program takes a little under 2 seconds:

```markup
ch03/single$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: 17.3.1a
Uptime: 5 hours, 1 minute
This process took 1.779684183s
```

Now, let’s look at a similar example, stored in the `ch03/sequential` directory (see _Further reading_), where we’ve added two extra devices to the inventory:

```markup
router:
- hostname: sandbox-iosxe-latest-1.cisco.com
  platform: cisco_iosxe
  ...
- hostname: sandbox-nxos-1.cisco.com
  platform: cisco_nxos
  ...
- hostname: sandbox-iosxr-1.cisco.com
  platform: cisco_iosxr
  ...
```

As we discussed in the _Control flow_ section, we can iterate over arrays and slices with the `range` form of a `for` loop. Here, we iterate over each `Router` in `inv.Routers`, assigning it to the `v` variable in each iteration. We ignore the value of the index by assigning it to the blank identifier written as `_` (underscore). Finally, we call the `getVersion` function for the `v` router:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    for _, r := range inv.Routers {
        getVersion(v)
    }
}
```

It takes around 7 seconds to execute as it connects to one device after another:

```markup
ch03/sequential$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: 17.3.1a
Uptime: 5 hours, 25 minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: 9.3(3)
Uptime: 0 day(s), 3 hour(s), 2 minute(s), 18 second(s)
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv 9000
SW Version: 6.5.3
Uptime: 2 weeks 8 hours 23 minutes
This process took 6.984502353s
```

This is a prime example of code that we could optimize through the use of goroutines. All we need to do initially is to add a `go` keyword before the statement that we need to run in a goroutine:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    for _, r := range inv.Routers {
        go getVersion(v)
    }
}
```

In the code example, we spawn a separate goroutine for each invocation of the `getVersion` (`v`) statement. Everything happens in the background; any blocking statement inside a spawned goroutine does not affect the other goroutines, so all three function calls, plus the main goroutine, now run concurrently.

The default behavior of these spawned goroutines is to release control immediately, so in this example, the code iterates over all three devices and then returns. It doesn’t actually wait for the spawned goroutines to complete.

But, in our case, we’d like to see the result of all three function calls before we exit the program. This is where we can use a special `sync.WaitGroup` type, which blocks the main goroutine until all spawned goroutines complete. It does this by keeping a counter that tracks all currently active goroutines and blocks until that counter goes down to zero.

This is what we do to introduce this idea in the code example we are working with:

-   We create a new `wg` variable of the `sync.WaitGroup` type.
-   While iterating through our inventory, we increase the `WaitGroup` counter by one with `wg.Add(1)`.
-   Each spawned goroutine consists of an anonymous function that runs `getVersion`, but also calls `wg.Done` at the very end to decrement the `WaitGroup` counter by one with a `defer` statement.
-   The main goroutine blocks on `wg.Wait` until the `WaitGroup` counter becomes zero. This happens after all the spawned instances of the `getVersion` functions return.

You can find the full code of this example at `ch03/concurrency/main.go` (see _Further reading_):

```markup
func main() {
    /* ... <omitted for brevity > ... */
    var wg sync.WaitGroup
    for _, v := range inv.Routers {
        wg.Add(1)
        go func(r Router) {
            defer wg.Done()
            getVersion(r)
        }(v)
    }
    wg.Wait()
}
```

Now, let’s see what effect these changes have on the execution time of the program:

```markup
ch03/concurrency$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: 17.3.1a
Uptime: 5 hours, 26 minutes
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv 9000
SW Version: 6.5.3
Uptime: 2 weeks 8 hours 25 minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: 9.3(3)
Uptime: 0 day(s), 3 hour(s), 4 minute(s), 11 second(s)
This process took 2.746996304s
```

We’ve gone down to roughly 3 seconds, which is how long it took to communicate with the slowest device in the inventory. This is a pretty significant win, considering we didn’t have to change any of the _worker_ functions (`getVersion` in this case). You might apply the same refactoring to many other similar programs with minimal changes to their existing code bases.

This approach works well with natively synchronous functions that you can run with or without a goroutine. But, if we know that a certain function always runs in a goroutine, it’s totally possible to make it goroutine-aware from the very beginning. For example, this is how we could have refactored the `getVersion` function to accept an extra `WaitGroup` argument and make the `wg.Done` call part of the function:

```markup
func getVersion(r Router, wg *sync.WaitGroup) {
    defer wg.Done()
    /* ... <omitted for brevity > ... */
}
```

Having a function like that would simplify the code of the main function since we no longer need to wrap everything in an anonymous function just to make the `wg.Done` call:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    for _, v := range inv.Routers {
        wg.Add(1)
        go getVersion(v, &wg)
    }
    wg.Wait()
}
```

The complete code for this example is available in the `ch03/concurrency2` directory (see _Further reading_).

## Channels

As soon as anyone becomes familiar with goroutines, the next thing they normally want to do is exchange data between them. Go channels allow goroutines to communicate with each other. A real-world analogy to describe Go channels are first-in-first-out pipes – they have fixed throughput and allow you to send data in both directions.

You can use channels for both goroutine synchronization (a form of signaling used for work coordination) and general-purpose data exchange.

We create channels with the `make` keyword, which initializes them and makes them ready to use. The two arguments that `make` accepts are the channel type, which defines the data type you can exchange over the channel, and an optional capacity. The channel capacity determines how many unreceived values it can store before it starts blocking a sender, acting then as a buffer.

The following code snippet shows how we send and receive an integer over a channel. Here, `send` is the value we want to send to the `ch` channel we created. The `<-` operator lets us send data to a channel. Next, we declare a `receive` variable, whose value comes from the `ch` channel:

```markup
func main() {
    ch := make(chan int, 1)
    send := 1
    ch <- send
    receive := <-ch
    // prints 1
    fmt.Println(receive)
}
```

But, sending and receiving data in a single goroutine is not the goal here. Let’s examine another example of using channels for communication between different goroutines. We pick up the example we’ve used in this section so far and introduce another _worker_ function whose job is to print the results produced by the `getVersion` function.

The new `printer` function uses a `for` loop to receive values from an `in` channel and it prints them on the terminal:

```markup
func printer(in chan data {
    for out := range in {
        fmt.Printf("Hostname: %s\nHW: %s\nSW Version: %s\nUptime: %s\n\n", out.host, out.hw, out.version, out.uptime)
    }
}
```

We create the `ch` channel in the main goroutine before we spawn any of the goroutines. We pass it as an argument to both `getVersion` and `printer` functions. The first extra goroutine we start is an instance of the `printer` function that listens for messages coming from the device over the `ch` channel:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    ch := make(chan data)
    go printer(ch)
    var wg sync.WaitGroup
    for _, v := range inv.Routers {
        wg.Add(1)
        go getVersion(v, ch, &wg)
    }
    wg.Wait()
    close(ch)
}
```

The next step is to start a goroutine for each network device in the inventory to capture the output we need and send it over the channel with the `getVersion` function. After we collect and print the data, we close the channel and end the program:

```markup
ch03/concurrency3$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
HW: [CSR1000V]
SW Version: 17.3.1a
Uptime: 1 day, 12 hours, 42 minutes
Hostname: sandbox-iosxr-1.cisco.com
HW: IOS-XRv 9000
SW Version: 7.3.2
Uptime: 1 day 2 hours 57 minutes
Hostname: sandbox-nxos-1.cisco.com
HW: C9300v
SW Version: 9.3(3)
Uptime: 5 day(s), 6 hour(s), 25 minute(s), 44 second(s)
```

The complete code for this example is available in the `ch03/concurrency3` (_Further_ _reading_) directory.

## Channels and Timers

One thing we didn’t consider in the last couple of examples was the scenario where a network device is not reachable, or the connection to it hangs, or maybe a device takes forever to return the output we need. In these cases, we need to set up a timeout so we don’t wait forever and we can end the program gracefully.

You can handle this at the connection level, but also, channels offer you a couple of resources to keep track of time via these timer types:

-   **Timer** — To wait for a certain amount of time
-   **Ticker** — To perform an action repeatedly at some interval

### Timer

`Timer` can help you define a timeout for your program. To illustrate this, we can rewrite the example we have been working with to print all the messages from the `ch` channel in the main function, instead of calling a separate function (`printer`).

A `select` statement inside an infinite loop handles this as follows. Unlike a `switch` statement, we use `select` with channels when we don’t have to choose an option in order. For each iteration, we either wait for a message from the `ch` channel or if 5 seconds have elapsed (`time.After(5 * time.Second)`), we close the channel and exit the program:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    for {
        select {
        case out := <-ch:
            fmt.Printf(
    "Hostname: %s\nHW: %s\nSW Version: %s\nUptime:%s\n\n",
            out.host, out.hw, out.version, out.uptime)
        case <-time.After(5 * time.Second):
            close(ch)
            fmt.Println("Timeout: 5 seconds")
            return
        }
    }
}
```

This forces the runtime to always be 5 seconds, even if not all the tasks have been completed. This is not the most efficient way to solve this problem, but it shows how to timeout without introducing the `context` package from the standard library that you could also use in this scenario.

The complete code for this example is available in the `ch03/concurrency5` directory of the book’s repository (see _Further reading_).

### Ticker

A common use for a ticker is in cases where you want to execute periodic tasks. In the next code example, we create a `ticker` that runs every half second, which we use as a trigger to print out a message to the terminal. We also create a `done` channel, just to signal that we want to stop the execution of the program after 2 seconds and 100 milliseconds:

```markup
func main() {
    ticker := time.NewTicker(500 * time.Millisecond)
    done := make(chan bool)
    go repeat(done, ticker.C)
    time.Sleep(2100 * time.Millisecond)
    ticker.Stop()
    done <- true
}
```

Tickers from the `time` package have a `C` channel that they use to signal every interval. We pass this channel and the `done` channel to the `repeat` function that we execute in a goroutine:

```markup
func repeat(d chan bool, c <-chan time.Time) {
    for {
        select {
        case <-d:
            return
        case t := <-c:
            fmt.Println("Run at", t.Local())
        }
    }
}
```

This function runs an infinite loop that waits for a signal from the `ticker` or the `done` channel to end the execution. This is what the output looks like:

```markup
ch03/ticker$ go run main.go
Tick at 2021-11-17 23:19:33.914906389 -0500 EST
Tick at 2021-11-17 23:19:34.414279709 -0500 EST
Tick at 2021-11-17 23:19:34.915058301 -0500 EST
```

The complete code for this example is available in the `ch03/ticker` directory (see _Further reading_).

## Shared data access

Channels are thread-safe, so it’s always a good idea to use them as the default option for data communication between goroutines. But sometimes, you may still need to access and change data that more than just one goroutine has access to.

The problem with concurrent data access is that it may cause data corruption when many goroutines try to change the same field or read from a field that someone else might be changing. Go’s `sync` package includes three helper types you can use to serialize these kinds of operations:

-   The `sync.Mutex` type is a general-purpose mutual exclusion lock that has two states — locked and unlocked.
-   The `sync.RWMutex` type is a special mutex for read-write operations where only write operations are mutually exclusive but simultaneous read operations are safe.
-   The `sync.Map` mutex covers a couple of map corner case scenarios that we don’t delve into in this book. The **sync.Map documentation** talks about them (see _Further reading_).

Now, let’s see an example of how you can use `sync.RWMutexto` to safeguard concurrent map access. Using the example theme we have used through this section as the baseline, let’s add another variable that records whether we are able to connect successfully to a remote device. We call this variable `isAlive` and pass it to the `getVersion` function as an argument:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    isAlive := make(map[string]bool)
    /* ... <omitted for brevity > ... */
    for _, v := range inv.Routers {
        wg.Add(1)
        go getVersion(v, ch, &wg, isAlive)
    }
    /* ... <omitted for brevity > ... */
}
```

We define the `m` mutex as a package-level global variable to make sure all functions are using the same mutex for synchronization. We lock this mutex just before we change the `isAlive` map and unlock it right after we make the change in the `getVersion` function:

```markup
var m sync.RWMutex = sync.RWMutex{}
func getVersion(r Router, out chan data, wg *sync.WaitGroup, isAlive map[string]bool) {
    defer wg.Done()
    /* ... <omitted for brevity > ... */
    rs, err := d.SendCommand("show version")
    if err != nil {
        fmt.Printf("fail to send cmd for %s: %+v\n",
                    r.Hostname, err)
        m.Lock()
        isAlive[r.Hostname] = false
        m.Unlock()
        return
    }
    m.Lock()
    isAlive[r.Hostname] = true
    m.Unlock()
}
```

Finally, we add another mutex for a loop in the main function that uses a read-specific lock while iterating over a map to prevent it from being accidentally modified in the process:

```markup
func main() {
    /* ... <omitted for brevity > ... */
    m.RLock()
    for name, v := range isAlive {
        fmt.Printf("Router %s is alive: %t\n", name, v)
    }
    m.RUnlock()
    /* ... <omitted for brevity > ... */
}
```

You can check the full code in the `ch03/concurrency4` directory (see _Further reading_). The next output shows what this program produces:

```markup
ch03/concurrency4$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: 17.3.1a
Uptime: 8 hours, 27 minutes
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv 9000
SW Version: 7.3.2
Uptime: 1 day 11 hours 43 minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: 9.3(3)
Uptime: 5 day(s), 15 hour(s), 11 minute(s), 42 second(s)
Router sandbox-iosxe-latest-1.cisco.com is alive: true
Router sandbox-iosxr-1.cisco.com is alive: true
Router sandbox-nxos-1.cisco.com is alive: true
This process took 3.129440011s
```

Sometimes, you might forget to use mutexes, especially for non-trivial user-defined data types, or when you accidentally leak a variable between goroutines. In these cases, you can use the data race detector built into the `go` tool. Add the `-race` flag to any of the go `test`/`run`/`build` commands to check and get a report of any unprotected access requests to shared memory.

To see how it works, let’s focus on the `isAlive` map we manipulate concurrently on different instances of the `getVersion` function. Earlier, we surrounded this with a mutex, which we now remove in `ch03/race/main.go` (see _Further reading_):

```markup
func getVersion(r Router, out chan map[string]interface{}, wg *sync.WaitGroup, isAlive map[string]bool) {
    defer wg.Done()
    /* ... <omitted for brevity > ... */
    // m.Lock()
    isAlive[r.Hostname] = true
    // m.Unlock()
    out <- "test"
}
```

When you run the program with the extra `-race` flag, Go highlights the data race condition it detects:

```markup
ch03/race$ go run -race main.go
MESSAGE: test
MESSAGE: test
==================
WARNING: DATA RACE
Write at 0x00c00011c6f0 by goroutine 9:
  runtime.mapassign_faststr()
      /usr/local/go/src/runtime/map_faststr.go:202 +0x0
  main.getVersion()
      ~/Network-Automation-with-Go/ch03/race/main.go:35 +0xeb
  main.main·dwrap·5()
      ~/Network-Automation-with-Go/ch03/race/main.go:74 +0x110
...
==================
MESSAGE: test
Router sandbox-iosxe-latest-1.cisco.com is alive: true
Router sandbox-iosxr-1.cisco.com is alive: true
Router sandbox-nxos-1.cisco.com is alive: true
This process took 1.918348ms
Found 1 data race(s)
exit status 66
```

Go’s built-in data race detector alleviates the task of debugging data races, which are among the hardest bugs to debug in concurrent systems.

## Concurrency caveats

Concurrency is a powerful tool. You could even envision using goroutines everywhere in your code and following design patterns such as worker pools to split up your work between different goroutines to get the initial speed gains for a relatively small price of increased complexity.

But, it’s important to consider that _concurrency is not parallelism_ (see _Further reading_) and there is always some overhead involved in the coordination of goroutines and mapping them to OS threads. We also shouldn’t forget that the underlying hardware resources are finite and so are the concurrency performance gains, as they inevitably flatten out at a certain point (see _Simulating a real-world system in Go_ in the _Further_ _reading_ section).

Finally, concurrent programming is hard; it’s hard to write code that’s safe, and hard to reason about and debug when it breaks. It’s important not to over-engineer your code with goroutines and use them when and where you truly need them, measure your gains and detect race conditions, avoid memory sharing if possible, and opt for communicating via channels.

Bookmark

# Summary

This chapter concludes the theoretical introduction to Go as a programming language. We went from Go variable types and performing operations with them, to reviewing the key building blocks of Go programs, and how to take advantage of some of Go’s most notable packages from its standard library to help you build scalable applications.

Starting from the next chapter, we turn our attention to network-specific tasks that are more applicable to real-world scenarios. We still continue introducing some theoretical concepts throughout the book, but most content is on concrete use cases rather than abstract theory.

Bookmark

# Further reading

-   `ch03/type-definition/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go%0A)
-   `ch03/string-literals/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go%0A)
-   `ch03/string-concatenate/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go%0A)
-   `ch03/string-memory/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go%0A)
-   `ch03/boolean/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/boolean/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/boolean/main.go%0A)
-   `ch03/arrays/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/arrays/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/arrays/main.go)
-   `ch03/slices/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/slices/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/slices/main.go)
-   `ch03/maps/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/maps/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/maps/main.go%0A)
-   `ch03/structs/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/structs/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/structs/main.go)
-   `ch03/tcp-header/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go)
-   _Comparison_ _operators_: [https://golang.org/ref/spec#Comparison\_operators](https://golang.org/ref/spec#Comparison_operators)
-   `ch03/switch/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/switch/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/switch/main.go)
-   `ch03/goto/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/goto/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/goto/main.go)
-   `ch03/functions1/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/functions1/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/functions1/main.go)
-   `ch03/functions2/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/functions2/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/functions2/main.go)
-   `ch03/mutate-slice/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go)
-   `ch03/methods/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/methods/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/methods/main.go)
-   `ch03/variadic/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/variadic/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/variadic/main.go)
-   `ch03/defer/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/defer/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/defer/main.go)
-   _Sample_ _program_: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go%0A)
-   `ch03/io-interface1/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go%0A)
-   `ch03/io-interface2/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go%0A)
-   `ch03/reader/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/reader/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/reader/main.go%0A)
-   `ch03/json`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json%0A)
-   Book’s GitHub repository: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go%0A)
-   `ch03/json/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/json/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/json/main.go)
-   `ch03/json-interface`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json-interface](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json-interface%0A)
-   _GJSON_: [https://github.com/tidwall/gjson](https://github.com/tidwall/gjson%0A)
-   _SJSON_: [https://github.com/tidwall/sjson](https://github.com/tidwall/sjson%0A)
-   `ch03/xml`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/xml](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/xml%0A)
-   `xmlquery`: [https://github.com/antchfx/xmlquery](https://github.com/antchfx/xmlquery%0A)
-   `ch03/yaml`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/yaml](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/yaml%0A)
-   `ch03/yaml/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/yaml/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/yaml/main.go)
-   _yq_: [https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)
-   `ch03/json-xml`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json-xml](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/json-xml%0A)
-   `ch03/single`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/single](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/single%0A)
-   `ch03/single/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/single/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/single/main.go%0A)
-   `ch03/sequential`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/sequentia](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/sequentia%0A)
-   `ch03/concurrency/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go%0A)
-   `ch03/concurrency2`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency2](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency2%0A)
-   `ch03/concurrency3`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency3](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency3%0A)
-   `ch03/concurrency5`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency5](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency5%0A)
-   `ch03/ticker`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/ticker](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/ticker%0A)
-   _sync.Map_ _documentation_: [https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map%0A)
-   `ch03/concurrency4`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency4](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/tree/main/ch03/concurrency4%0A)
-   `ch03/race/main.go`: [https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/race/main.go](https://github.com/ImagineDevOps DevOps/Network-Automation-with-Go/blob/main/ch03/race/main.go%0A)
-   _Simulating a real-world system in_ _Go_: [https://www.youtube.com/watch?v=\_YK0viplIl4](https://www.youtube.com/watch?v=_YK0viplIl4%0A)
-   _Concurrency is not_ _parallelism_: [https://blog.golang.org/waza-talk](https://blog.golang.org/waza-talk)