# Writing Programs in Go

This chapter will talk about many essential, interesting, and handy Go topics that will help you be more productive. I think it would be a good idea to start this chapter by compiling and running the Go code of the hw.go program from the previous chapter. Then, you will learn how to deal with the environment variables that can be used by Go, how to process the command-line arguments of a Go program, and how to print the output on the screen and get input from the user. Finally, you will see how to define functions in Go, learn about the extremely important defer keyword, look at the data structures that come with Go, and learn what Go interfaces are before checking out code that generates random numbers.

Therefore, in this chapter, you will become familiar with many Go concepts, including the following:

-   Compiling your Go programs
-   Go environment variables
-   Using the command-line arguments given to a Go program
-   Getting user input and printing the output on your screen
-   Go functions and the defer keyword
-   Go data structures and interfaces
-   Creating random numbers

Just Imagine

# Compiling Go code

Go does not care about the name of the source file of an autonomous program as long as the package name is main and there is a main() function in it. This is because the main() function is where the program execution begins. This also means that you cannot have multiple main() functions in the files of a single project.

There exist two ways to run a Go program:

-   The first one, go run, just executes the Go code without generating any new files, only some temporary ones that are deleted afterward
-   The second way, go build, compiles the code, generates an executable file, and waits for you to run the executable file

This book is written on an Apple Mac OS Sierra system using the Homebrew ([https://brew.sh/](https://brew.sh/)) version of Go. However, you should have no difficulties compiling and running the presented Go code on most Linux and FreeBSD systems, provided that you have a relatively recent version of Go.

So, the first way is as follows:

```markup
$ go run hw.go
Hello World!  
```

The aforementioned way allows Go to be used as a scripting language. The following is the second way:

```markup
$ go build hw.go
$ file hw
hw: Mach-O 64-bit executable x86_64
```

The generated executable file is named after the name of the Go source file, which is much better than a.out, which is the default filename of the executable files generated by the C compiler.

If there is an error in your code, such as a misspelled Go package name when calling a Go function, you will get the following kind of error message:

```markup
$ go run hw.go
# command-line-arguments
./hw.go:3: imported and not used: "fmt"
./hw.go:7: undefined: mt in mt.Println
```

If you accidentally misspell the main() function, you will get the following error message because the execution of an autonomous Go program begins from the main() function:

```markup
$ go run hw.go
# command-line-arguments
runtime.main_main f: relocation target main.main not defined
runtime.main_main f: undefined: "main.main"
```

Lastly, I want to show you an error message that will give you a good idea about a formatting rule of Go:

```markup
$ cat hw.gocat 
package main
    
import "fmt"
    
func main()
{
      fmt.Println("Hello World!")
}
$ go run hw.go
# command-line-arguments
./hw.go:6: syntax error: unexpected semicolon or newline before {
  
```

The previous error message shows us that Go prefers putting curly braces in a certain way, which is not the case with most programming languages such as Perl, C, and C++. This might look frustrating at first, but it saves you from one extra line of code and makes your programs more readable. Note that the preceding code uses the _Allman formatting style_, which Go does not accept.

The official explanation for this error is that Go requires the use of semicolons as statement terminators in many contexts, and the compiler automatically inserts the required semicolons when it thinks they are necessary, which in this case is at the end of a non-blank line. Therefore, putting the opening brace ({) on its own line will make the Go compiler to put a semicolon at the end of the previous line, which produces the error message.

If you think that the gofmt tool can save you from similar errors, you will be disappointed:

```markup
$ gofmt hw.go
hw.go:6:1: expected declaration, found '{'
  
```

The Go compiler has another rule, as you can see in the following output:

```markup
$ go run afile.go
# command-line-arguments
./afile.go:4: imported and not used: "net"
```

This means that you should not import packages without actually using them in your programs. Although this could have been a harmless warning message, your Go program will not get compiled. Bear in mind that similar warnings and error messages are a good indication that you are missing something, and you should try to correct them. You will create a higher quality of code if you treat warnings and errors the same.

# Checking the size of the executable file

So, after successfully compiling hw.go, you might want to check the size of the generated executable file:

```markup
$ ls -l hw
-rwxr-xr-x  1 mtsouk  staff  1628192 Feb  9 22:29 hw
$ file hw
hw: Mach-O 64-bit executable x86_64  
```

Compiling the same Go program on a Linux machine will create the following file:

```markup
$ go versiongo 
go version go1.3.3 linux/amd64
$ go build hw.go
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw
$ file hw
hw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
  
```

To get a better sense of how big the Go executable is, consider that the executable for the same program written in C is about 8432 bytes!

So, you might ask why such a huge executable file for such a small program? The main reason is that Go executable files are statically build, which means that they require no external libraries to run. The use of the strip(1) command can make the generated executable files a little smaller, but do not expect miracles:

```markup
$ strip hw
$ ls -l hw
-rwxr-xr-x  1 mtsouk  staff  1540096 Feb 18 17:41 hw
```

The previous process has nothing to do with Go itself because strip(1) is a Unix command that removes or modifies the symbol table of files and therefore reduces their size. Go can perform the work of the strip(1) command on its own and create smaller executable files, but this method does not always work:

```markup
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw
$ CGO_ENABLED=0 go build -ldflags "-s" -a hw.go
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1328032 Feb 18 17:44 hw
$ file hw
hw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
```

The preceding output is from a Linux machine; when the same compilation command is used on a macOS machine, it will make no difference to the size of the executable file.

Just Imagine

# Go environment variables

The go tool can use many Unix shell environment variables dedicated to Go, including GOROOT, GOHOME, GOBIN, and GOPATH. The most important Go environment variable is GOPATH, which specifies the location of your workspace. Usually, this is the only environment variable that you will need to define when developing Go code; it is to do with the way the files of a project will be organized. This means that each project will be organized into three main directories, named src, pkg, and bin. However, many people, including me, prefer not to use GOPATH and manually organize their project files.

So, if you are a big fan of shell variables, you can put all these kinds of definitions in either .bashrc or .profile, which means that these environment variables will be active every time you log in to your Unix machine. If you are not using the Bash shell, which is the default Linux and macOS shell, then you might need to use another start up file. Check out the documentation of your favorite Unix shell to find out which file to use.

The upcoming screenshot shows part of the output of the following command, which displays all the environment variables used by Go:

```markup
$ go help environment
```

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/87508a77-cb59-4e6f-ac23-d4a412f73ebc.png)

The output of the "go help environment" command

You can find additional information about a particular environment variable by executing the next command and replacing NAME with the environment variable that interests you:

```markup
$ go env NAME  
```

All these environment variables have nothing to do with the actual Go code or the execution of the program, but they might affect the development environment; therefore, if you happen to see any strange behavior while trying to compile a Go program, check the environment variables you are using.

Just Imagine

# Using command-line arguments

Command-line arguments allow your programs to get input, such as the names of the files you want to process, without having to write a different version of the program. Hence, you cannot create any useful systems software if you're unable to process the command-line arguments passed to it.

So here is a naive Go program, named cla.go, that prints all its command-line arguments, including the name of the executable file:

```markup
package main 
 
import "fmt" 
import "os" 
 
func main() { 
   arguments := os.Args 
   for i := 0; i < len(arguments); i++ { 
         fmt.Println(arguments[i]) 
   } 
} 
```

As you can see, Go needs an extra package named os in order to read the command-line arguments of a program that are stored in the os.Args array. In case you do not like having multiple import statements, you can rewrite the two import statements as follows, which I find much easier to read:

```markup
import ( 
   "fmt" 
   "os" 
)
```

The gofmt utility puts package names in alphabetical order when you are importing all your packages using a single import block.

The Go code of cla.go is simple as it stores all the command-line arguments in an array and uses a for loop for printing them. As you will see in forthcoming chapters, the os package can do many more things. If you are familiar with C, you should know that in C, command-line arguments are automatically passed to programs, and you do not need to include any extra header files in order to read them. Go uses a different approach that gives you more control but requires slightly more code.

Executing cla.go after building it first will create the following kind of output:

```markup
$ ./cla 1 2 three
./cla
1
2
three
```

# Finding the sum of the command-line arguments

Now, let us try something different and tricky: you are going to try to find the summary of the command-line arguments given to your Go program. Therefore, you are going to consider the command-line arguments as numbers. Although the main idea remains the same, the implementation is totally different because you will have to convert your command-line arguments into numbers. The name of the Go program will be addCLA.go, and it can be split into two parts.

The first part is the preamble of the program:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strconv" 
) 
```

You need the fmt package for printing your output and the os package for reading the command-line arguments. As command-line arguments are stored as strings, you will also need the srtconv package for converting them into integers.

The second part is the implementation of the main() function:

```markup
func main() { 
   arguments := os.Args 
   sum := 0 
   for i := 1; i < len(arguments); i++ { 
         temp, _ := strconv.Atoi(arguments[i]) 
         sum = sum + temp 
   } 
   fmt.Println("Sum:", sum) 
} 
```

The strconv.Atoi() function returns two values: the first one is an integer number, provided that the conversion was successful, and the second one is an error variable.

Note that most Go functions return an error variable, which should always be examined, especially on production software.

If you do not use the strconv.Atoi() function, then you will have two problems:

-   The first one is that the program will try to perform additions, which are mathematical operations, using strings
-   The second one is that you will not be able to tell whether a command-line argument is a valid integer number or not, which can be done by examining the return value of strconv.Atoi()

So, strconv.Atoi() not only does the desired job, but it also tells us whether a given argument is a valid integer or not, which is equally important because it allows us to process inappropriate arguments differently.

The other crucial Go code found in addCLA.go is the one that ignores the value of the error variable from the strconv.Atoi() function using pattern matching. The \_ character means "match everything" in Go pattern matching terms, but do not save it in any variable.

Go has support for four different sizes of signed and unsigned integers, named int8, int16, int32, int64, uint8, uint16, uint32, and uint64, respectively. However, Go also has int and uint, which are the most efficient signed and unsigned integers for your current platform. Therefore, when in doubt, use either int or uint.

Executing addCLA.go with the right kind of command-line arguments creates the following output:

```markup
$ go run addCLA.go 1 2 -1 -3
Sum: -1
$ go run addCLA.go
Sum: 0
```

The good thing is that addCLA.go does not crash if it gets no arguments, without you taking care of it. Nevertheless, it would be more interesting to see how the program handles erroneous input because you can never assume that you are going to get the right type of input:

```markup
$ go run addCLA.go !
Sum: 0
$ go run addCLA.go ! -@
Sum: 0
$ go run addCLA.go ! -@ 1 2
Sum: 3
```

As you can see, if the program gets the wrong type of input, it does not crash and does not include the erroneous input in its calculations. What is a major issue here is that addCLA.go does not print any warning message to let the user know that some of their input was ignored. This kind of dangerous code creates unstable executables that might generate security issues when given the wrong kind of input. So, the general advice here is that you should never expect or rely on the Go compiler, or any other compiler or program, to take care of such things because this is your job.

[](https://subscription.imaginedevops.io/book/programming/9781787125643/3)[Chapter 3](https://subscription.imaginedevops.io/book/programming/9781787125643/3), _Advanced Go Features_, will talk about error handling in Go in more detail and will present a better and safer version of the previous program. For now, we should all be happy that we can prove that our program does not crash with any kind of input.

Although this is not a perfect situation, it is not that bad if you know that your program does not work as expected for some given kinds of input. The bad thing is when the developer has no idea that there exist certain kinds of input that can make a program fail, because you cannot correct what you do not believe or recognize is wrong.

Although processing command-line arguments looks easy, it might get pretty complex if your command-line utility supports a large number of options and parameters. [Chapter 5](https://subscription.imaginedevops.io/book/programming/9781787125643/5), _Files and Directories_, will talk more about processing command-line options, arguments, and parameters using the flag standard Go package.

Just Imagine

# User input and output

According to the Unix philosophy, when a program finishes its job successfully, it generates no output. However, for a number of reasons, not all programs finish successfully and they need to inform the user about their issues by printing appropriate messages. Additionally, some system tools need to get input from the user in order to decide how to handle a situation that might come up.

The hero of Go user input and output is the fmt package, and this section is going to show you how to perform these two tasks by starting with the simplest one.

The best place to learn more about the fmt package is its documentation page, which can be found at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).

# Getting user input

Apart from using command-line arguments to get user input, which is the preferred approach in systems programming, there exist ways to ask the user for input.

Two such examples are the rm(1) and mv(1) commands when used with the \-i option:

```markup
$ touch aFile
$ rm -i aFile
remove aFile? y
$ touch aFile
$ touch ../aFile
$ mv -i ../aFile .
overwrite ./aFile? (y/n [n]) y
```

So, this section will show you how to mimic the previous behavior in your Go code by making your program understand the \-i parameter without actually implementing the functionality of either rm(1) or mv(1).

The simplest function for getting user input is called fmt.Scanln() and reads an entire line. Other functions for getting user input include fmt.Scan(), fmt.Scanf(), fmt.Sscanf(), fmt.Sscanln(), and fmt.Sscan().

However, there exists a more advanced way to get input from the user in Go; it involves the use of the bufio package. Nevertheless, using the bufio package to get a simple response from a user is a bit of an overkill.

The Go code of parameter.go is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strings" 
) 
 
func main() { 
   arguments := os.Args 
   minusI := false 
   for i := 0; i < len(arguments); i++ { 
         if strings.Compare(arguments[i], "-i") == 0 { 
               minusI = true 
               break 
         } 
   } 
 
   if minusI { 
         fmt.Println("Got the -i parameter!") 
         fmt.Print("y/n: ") 
         var answer string 
         fmt.Scanln(&answer) 
         fmt.Println("You entered:", answer) 
   } else { 
         fmt.Println("The -i parameter is not set") 
   } 
} 
```

The presented code is not particularly clever. It just visits all command-line arguments using a for loop and checks whether the current argument is equal to the \-i string. Once it finds a match with the help of the strings.Compare() function, it changes the value of the minusI variable from false to true. Then, as it does not need to look any further, it exits the for loop using a break statement. In case the \-i parameter is given, the block with the if statement asks the user to enter y or n using the fmt.Scanln() function.

Note that the fmt.Scanln() function uses a pointer to the answer variable. Since Go passes its variables by value, we have to use a pointer reference here in order to save the user input to the answer variable. Generally speaking, functions that read data from the user tend to work this way.

Executing parameter.go creates the following kind of output:

```markup
$ go run parameter.go
The -i parameter is not set
$ go run parameter.go -i
Got the -i parameter!
y/n: y
You entered: y
```

# Printing output

The simplest way to print something in Go is using the fmt.Println() and fmt.Printf() functions. The fmt.Printf() function has many similarities with the C printf(3) function. You can also use the fmt.Print() function instead of fmt.Println().

The main difference between fmt.Print() and fmt.Println() is that the latter automatically prints a newline character each time you call it. The biggest difference between fmt.Println() and fmt.Printf() is that the latter requires a format specifier for everything it will print, just like the C printf(3) function. This means that you have better control over what you are doing, but you have to write more code. Go calls these specifiers **verbs**, and you can find out more about supported verbs at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).

Just Imagine

# Go functions

Functions are an important element of every programming language because they allow you to break big programs into smaller and more manageable parts, but they must be as independent of each other as possible and must do one job and only one job. So, if you find yourself writing functions that do multiple things, you may want to consider writing multiple functions instead. However, Go will not refuse to compile functions that are long, complicated, or do multiple things.

A safe indication that you need to create a new function is when you find yourself using the same Go code multiple times in your program. Similarly, a safe indication that you need to put some of your functions in a module is when you find yourself using the same functions all the time in most of your programs.

The single most popular Go function is main(), which can be found in every autonomous Go program. If you look at the definition of the main() function, you'll soon realize that function declarations in Go start with the func keyword.

As a rule of thumb, you must try to write functions that are less than 20-30 lines of Go code. A good side effect of having smaller functions is that they can be optimized more easily because you can clearly find out where the bottleneck is.

# Naming the return values of a Go function

Unlike C, Go allows you to name the return values of a Go function. Additionally, when such a function has a return statement without any arguments, the function automatically returns the current value of each named return value. Note that such functions return their values in the order they were declared in the definition of the function.

Naming return values is a very handy Go feature that can save you from various types of bugs, so use it.

My personal advice is this: name the return values of your functions unless there is a very good reason not to do so.

# Anonymous functions

Anonymous functions can be defined in line, without the need for a name, and they are usually used for implementing things that require a small amount of code. In Go, a function can return an anonymous function or take an anonymous function as one of its arguments. Additionally, anonymous functions can be attached to Go variables.

It is considered a good practice for anonymous functions to have a small implementation and local usage. If an anonymous function does not have local utilization, then you might need to consider making it a regular function.

When an anonymous function is suitable for a job, then it is extremely convenient and makes your life easier; just do not use too many anonymous functions in your programs without a good reason.

# Illustrating Go functions

This subsection will present examples of the previous types of functions using the Go code of the functions.go program. The first part of the program contains the expected preamble and the implementation of the unnamedMinMax() function:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func unnamedMinMax(x, y int) (int, int) { 
   if x > y { 
         min := y 
         max := x 
         return min, max 
   } else { 
         min := x 
         max := y 
         return min, max 
   } 
} 
```

The unnamedMinMax() function is a regular function that gets two integer numbers as input, named x and y, respectively. It returns two integer numbers as output using a return statement.

The next part of functions.go defines another function but this time with named returned values, which are called min and max:

```markup
func minMax(x, y int) (min, max int) { 
   if x > y { 
         min = y 
         max = x 
   } else { 
         min = x 
         max = y 
   } 
   return min, max 
} 
```

The next function is an improved version of minMax() because you do not have to explicitly define the return variables of the return statement:

```markup
func namedMinMax(x, y int) (min, max int) { 
   if x > y { 
         min = y 
         max = x 
   } else { 
         min = x 
         max = y 
   } 
   return 
} 
```

However, you can easily discover which values will be returned by looking at the definition of the namedMinMax() function. The namedMinMax() function will return the current values of min and max, in that order.

The next function shows how to sort two integers without having to use a temporary variable:

```markup
func sort(x, y int) (int, int) { 
   if x > y { 
         return x, y 
   } else { 
         return y, x 
   } 
} 
```

The previous code also shows how handy it is that Go functions can return more than one value. The last part of functions.go contains the main() function; this could be explained in two parts.

The first part is to do with anonymous functions:

```markup
 func main() {
   y := 4 
   square := func(s int) int { 
         return s * s 
   } 
   fmt.Println("The square of", y, "is", square(y)) 
 
   square = func(s int) int { 
         return s + s 
   } 
   fmt.Println("The square of", y, "is", square(y)) 
```

Here, you define two anonymous functions: the first one calculates the square of the given integer whereas the second doubles the given integer number. What is important here is that both of them are assigned to the same variable, which is a totally wrong and is a dangerous practice. Therefore, improper use of anonymous functions can create nasty bugs, so take extra care and do not assign the same variable to different anonymous functions.

Note that even if a function is assigned to a variable, it is still considered an anonymous function.

The second part of main() uses some of the defined functions:

```markup
   fmt.Println(minMax(15, 6)) 
   fmt.Println(namedMinMax(15, 6)) 
   min, max := namedMinMax(12, -1) 
   fmt.Println(min, max) 
} 
```

What is interesting here is that you can get the two returned values of the namedMinMax() function using two variables, all in one statement.

Executing functions.go generates the following output:

```markup
$ go run functions.go
The square of 4 is 16
The square of 4 is 8
6 15
6 15
-1 12
```

The next section shows more examples of anonymous functions combined with the defer keyword.

# The defer keyword

The defer keyword defers the execution of a function until the surrounding function returns, and is widely used in file I/O operations. This is because it saves you from having to remember when to close an open file.

The file with the Go code that illustrates the use of defer is called defer.go and has four main parts.

The first part is the expected preamble as well as the definition of the a1() function:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func a1() { 
   for i := 0; i < 3; i++ { 
         defer fmt.Print(i, " ") 
   } 
} 
```

In the previous example, the defer keyword is used with a simple fmt.Print() statement.

The second part is the definition of the a2() function:

```markup
func a2() { 
   for i := 0; i < 3; i++ { 
         defer func() { fmt.Print(i, " ") }() 
   } 
} 
```

After the defer keyword, there is an anonymous function that is not attached to a variable, which means that after the termination of the for loop, the anonymous function will automatically disappear. The presented anonymous function takes no arguments but uses the i local variable in the fmt.Print() statement.

The next part defines the a3() function and has the following Go code:

```markup
func a3() { 
   for i := 0; i < 3; i++ { 
         defer func(n int) { fmt.Print(n, " ") }(i) 
   } 
} 
```

This time, the anonymous function requires an integer parameter that is named n and takes its value from the i variable.

The last part of defer.go is the implementation of the main() function:

```markup
func main() { 
   a1() 
   fmt.Println() 
   a2() 
   fmt.Println() 
   a3() 
   fmt.Println() 
} 
```

Executing defer.go will print the following, which might surprise you at first:

```markup
$ go run defer.go
2 1 0
3 3 3
2 1 0
```

So, now it is time to explain the output of defer.go by examining the way a1(), a2(), and a3() execute their code. The first line of output verifies that deferred functions are executed in **Last In First Out** (**LIFO**) order after the return of the surrounding function. The for loop in a1() defers a single function call that uses the current value of the i variable. As a result, all numbers are printed in reverse order because the last used value of i is 2. The a2() function is a tricky one because due to defer, the function body is evaluated after the for loop ends while it is still referencing the local i variable, which at that time was equal to 3 for all evaluations of the body. As a result, a2() prints the number 3 three times. Put simply, you have three function calls that use the last value of a variable because this is what is passed to the function. However, this is not the case with the a3() function because the current value of i is passed as an argument to the deferred function, due to the (i) code at the end of the a3() function definition. So, each time the deferred function is executed, it has a different i value to process.

As using defer can be complicated, you should write your own examples and try to guess their output before executing the actual Go code to make sure that your program behaves as expected. Try to be able to tell when the function arguments are evaluated and when the function body is actually executed.

You will see the defer keyword in action again in [Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_.

# Using pointer variables in functions

**Pointers** are memory addresses that offer improved speed in exchange for difficult-to-debug code and nasty bugs. C programmers know more about this. The use of pointer variables in Go functions is illustrated inside the pointers.go file, which can be divided into two main parts. The first part contains the definition of two functions and one new structure named complex:

```markup
func withPointer(x *int) { 
   *x = *x * *x 
} 
 
type complex struct { 
   x, y int 
} 
 
func newComplex(x, y int) *complex { 
   return &complex{x, y} 
} 
```

The second part illustrates the use of the previous definitions in the main() function:

```markup
func main() { 
   x := -2 
   withPointer(&x) 
   fmt.Println(x) 
 
   w := newComplex(4, -5) 
   fmt.Println(*w) 
   fmt.Println(w) 
} 
```

As the withPointer() function uses a pointer variable, you do not need to return any values because any changes to the variable you pass to the function are automatically stored in the passed variable. Note that you need to put & in front of the variable name to pass it as a pointer instead of as a value. The complex structure has two members, named x and y, which are both integer variables.

On the other hand, the newComplex() function returns a pointer to a complex structure, previously defined in pointers.go, which needs to be stored in a variable. In order to print the contents of a complex variable returned by the newComplex() function, you will need to put a \* character in front of it.

Executing pointers.go generates the following output:

```markup
$ go run pointers.go
4
{4 -5}
&{4 -5}
```

I do not recommend the use of pointers to amateur programmers outside of what is required by the libraries you use because they might cause problems. However, as you get more experienced, you might want to experiment with pointers and decide whether you want to use them or not depending on the problem you are trying to solve.

Just Imagine

# Go data structures

Go comes with many handy **data structures** that can help you store your own data, including arrays, slices, and maps. The most important task that you should be able to perform on any data structure is accessing all of its elements in some way. The second important task is having direct access to a specific element once you know its index or key. The last two equally important tasks are inserting elements and deleting elements from data structures. Once you know how to perform these four tasks, you will have complete control over the data structure.

# Arrays

Arrays are the most popular data structure due to their speed and are supported by almost all programming languages. You can declare an array in Go as follows:

```markup
myArray := [4]int{1, 2, 4, -4} 
```

Should you wish to declare an array with two or three dimensions, you can use the following notation:

```markup
twoD := [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} 
threeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} 
```

The index of the first element of each dimension of an array is 0, the index of the second element of each dimension is 1, and so on. Accessing, assigning, or printing a single element from one of the previous three arrays can also be done easily:

```markup
myArray[0] 
twoD[1][2] = 15 
threeD[0][1][1] = -1
```

The most common way to access all the elements of an array is by finding its size using the len() function and then using a for loop. However, there exist cooler ways to visit all the elements of an array that involve the use of the range keyword inside a for loop and allow you to bypass the use of the len() function, which is pretty handy when you have to deal with arrays with two or more dimensions.

All of the code in this subsection is saved as arrays.go, and you should watch it on your own. Running arrays.go creates the following output:

```markup
$ go run arrays.go
1 2 4 -4
0 2 -2 6 7 8
1 2 3 4 5 15 7 8 9
[[1 2] [3 -1]] [[5 6] [7 8]]
```

Now let's try to break things by trying to access some strange array elements, such as an element with an index number that does not exist or an element with a negative index number, using the following Go program that is named breakMe.go:

```markup
package main 
 
import "fmt" 
 
func main() { 
   myArray := [4]int{1, 2, 4, -4} 
   threeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} 
   fmt.Println("myArray[-1]:", myArray[-1])
   fmt.Println("myArray[10]:", myArray[10]) 
   fmt.Println("threeD[-1][20][0]:", threeD[-1][20][0]) 
} 
```

Executing breakMe.go will generate the following output:

```markup
$ go run breakMe.go
# command-line-arguments
./breakMe.go:8: invalid array index -1 (index must be non-negative)
./breakMe.go:9: invalid array index 10 (out of bounds for 4-element array)
./breakMe.go:10: invalid array index -1 (index must be non-negative)
./breakMe.go:10: invalid array index 20 (out of bounds for 2-element array)
```

Go considers compiler issues that can be detected as compiler errors because this helps the development workflow, which is the reason for printing all the out of bounds array access errors of breakMe.go.

Trying to break things is an extremely educational process that you should attempt all the time. Put simply, knowing when something does not work is equally useful to knowing when it works.

Despite their simplicity, Go arrays have many and severe shortcomings:

-   First, once you define an array, you cannot change its size, which means that Go arrays are not dynamic. Put simply, if you want to include an additional element to an existing array that has no space, you will need to create a bigger array and copy all the elements from the old array to the new one.
-   Second, when you pass an array to a function, you actually pass a copy of the array, which means that any changes you make to an array inside a function will be lost after the function finishes.
-   Last, passing a large array to a function can be pretty slow, mostly because Go has to create a second copy of the array. The solution to all these problems is to use slices instead.

# Slices

You'll not find the concept of **slice** in many programming languages, despite the fact that it is both smart and handy. A slice has many similarities with an array, and it allows you to overcome the shortcomings of an array.

Slices have a capacity and length property, which are not always the same. The length of a slice is the same as the length of an array with the same number of elements and can be found using the len() function. The capacity of a slice is the current room that has been allocated for this particular slice and can be found with the cap() function. As slices are dynamic in size, if a slice runs out of room, Go automatically doubles its current length to make room for more elements.

As slices are passed by reference to functions, any modifications you make to a slice inside a function will not be lost after the function ends. Additionally, passing a big slice to a function is significantly faster than passing the same array because Go will not have to make a copy of the slice; it will just pass the memory address of the slice variable.

The code of this subsection is saved in slices.go, and it can be separated into three main parts.

The first part is the preamble as well as the definition of two functions that get slice as input:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func change(x []int) { 
   x[3] = -2 
} 
 
func printSlice(x []int) { 
   for _, number := range x { 
         fmt.Printf("%d ", number) 
   } 
   fmt.Println() 
} 
```

Note that when you use range over a slice, you get a pair of values in its iteration. The first one is the index number and the second one is the value of the element. When you are only interested in the stored element, you can ignore the index number as it happens with the printSlice() function.

The change() function just changes the fourth element of the input slice, whereas printSlice() is a utility function that prints the contents of its slice input variable. Here, you can also see the use of the fmt.Printf() function for printing an integer number.

The second part creates a new slice named aSlice and makes a change to it with the help of the change() function you saw in the first part:

```markup
func main() { 
   aSlice := []int{-1, 4, 5, 0, 7, 9} 
   fmt.Printf("Before change: ") 
   printSlice(aSlice) 
   change(aSlice) 
   fmt.Printf("After change: ") 
   printSlice(aSlice) 
```

Although the way you define a populated slice has some similarities with the way you define an array, the biggest difference is that you do not have to declare the number of elements your slice will have.

The last part illustrates the capacity property of a Go slice as well as the make() function:

```markup
   fmt.Printf("Before. Cap: %d, length: %d\n", cap(aSlice), len(aSlice)) 
   aSlice = append(aSlice, -100) 
   fmt.Printf("After. Cap: %d, length: %d\n", cap(aSlice), len(aSlice)) 
   printSlice(aSlice) 
   anotherSlice := make([]int, 4) 
   fmt.Printf("A new slice with 4 elements: ") 
   printSlice(anotherSlice) 
} 
```

The make() function automatically initializes the elements of a slice to the zero value for that type, which can be verified by the output of the printSlice (anotherSlice) statement. Note that you need to specify the number of elements of a slice when you create it with the make() function.

Executing slices.go generates the following output:

```markup
$ go run slices.go 
Before change: -1 4 5 0 7 9 
After change: -1 4 5 -2 7 9 
Before. Cap: 6, length: 6 
After. Cap: 12, length: 7 
-1 4 5 -2 7 9 -100 
A new slice with 4 elements: 0 0 0 0 
```

As you can see from the third line of the output, the capacity and the length of a slice were the same at the time of its definition. However, after adding a new element to the slice using append(), its length goes from 6 to 7 but its capacity doubles and goes from 6 to 12. The main advantage you get from doubling the capacity of a slice is better performance because Go will not have to allocate memory space all the time.

You can create a slice from the elements of an existing array, and you can copy an existing slice to another one using the copy() function. Both operations have some tricky points, and you should experiment with them.

[](https://subscription.imaginedevops.io/book/programming/9781787125643/6)[Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, will talk about a special type of slice, named byte slice, that can be used in file I/O operations.

# Maps

The Map data type in Go is equivalent to the well-known hash table found in other programming languages. The main advantage of maps is that they can use almost any data type as their index, which in this case is called a **key**. For a data type to be used as a key, it must be comparable.

So, let's take a look at an example Go program, named maps.go, which we will use for illustrative purposes. The first part of maps.go contains the preamble Go code you would expect:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func main() { 
 
```

Then, you can define a new empty map that has strings as its keys and integer numbers as values, as follows:

```markup
   aMap := make(map[string]int) 
```

Post this, you can add new key and value pairs to the aMap map, as follows:

```markup
   aMap["Mon"] = 0 
   aMap["Tue"] = 1 
   aMap["Wed"] = 2 
   aMap["Thu"] = 3 
   aMap["Fri"] = 4 
   aMap["Sat"] = 5 
   aMap["Sun"] = 6 
```

Then, you can get the value of an existing key:

```markup
   fmt.Printf("Sunday is the %dth day of the week.\n", aMap["Sun"]) 
 
```

However, the single most important operation you can perform on an existing map is illustrated in the following Go code:

```markup
   _, ok := aMap["Tuesday"] 
   if ok { 
         fmt.Printf("The Tuesday key exists!\n") 
   } else { 
         fmt.Printf("The Tuesday key does not exist!\n") 
   } 
```

What the aforementioned Go code does is use the error-handling capabilities of Go in order to verify that a key of a map already exists before you try to get its value. This is the proper and safe way of trying to get the value of a map key because asking for a value for which there is no key will result in returning zero. This gives you no way of determining whether the result was zero because the key you requested was not there or because the element with the corresponding key actually had the zero value.

The following Go code shows how you can iterate over all the keys of an existing map:

```markup
   count := 0 
   for key, _ := range aMap { 
         count++ 
         fmt.Printf("%s ", key) 
   } 
   fmt.Printf("\n") 
   fmt.Printf("The aMap has %d elements\n", count) 
```

If you have no interest in visiting the keys and the values of a map and you just want to count its pairs, then you can use the next, much simpler variation of the previous for loop:

```markup
   count = 0 
   delete(aMap, "Fri") 
   for _, _ = range aMap { 
         count++ 
   } 
   fmt.Printf("The aMap has now %d elements\n", count) 
```

The last part of the main() function contains the following Go code that illustrates an alternative way of defining and initializing a map at the same time:

```markup
   anotherMap := map[string]int{ 
         "One":   1, 
         "Two":   2, 
         "Three": 3, 
         "Four":  4, 
   }    anotherMap["Five"] = 5 
   count = 0 
   for _, _ = range anotherMap { 
         count++ 
   } 
   fmt.Printf("anotherMap has %d elements\n", count) 
} 
```

However, apart from the different initialization, all the other map operations work exactly the same. Executing maps.go generates the following output:

```markup
$ go run maps.go
Sunday is the 6th day of the week.
The Tuesday key does not exist!
Wed Thu Fri Sat Sun Mon Tue
The aMap has 7 elements
The aMap has now 6 elements
anotherMap has 5 elements
```

Maps are a very handy data structure, and there is a big chance that you are going to need them when developing systems software.

# Converting an array into a map

This subsection will perform a practical operation, which is converting an array into a map without knowing the size of array in advance. The Go code of array2map.go can be divided into three main parts. The first part is the standard Go code that includes the required packages and the beginning of the main() function:

```markup
package main 
 
import ( 
   "fmt" 
   "strconv" 
) 
 
func main() { 
```

The second part, which implements the core functionality, is as follows:

```markup
anArray := [4]int{1, -2, 14, 0} 
aMap := make(map[string]int) 
 
length := len(anArray) 
for i := 0; i < length; i++ { 
   fmt.Printf("%s ", strconv.Itoa(i)) 
   aMap[strconv.Itoa(i)] = anArray[i] 
} 
```

You first define the array variable and the map variable you will use. The for loop is used for visiting all the array elements and adding them to map. The strconv.Itoa() function converts the index number of array into a string.

Bear in mind that if you know that all the keys of a map will be consecutive positive integer numbers, you might consider using an array or a slice instead of a map. In fact, even if the keys are not consecutive, arrays and slices are cheaper data structures than maps, so you might end up with a sparse matrix.

The last part, which is just for printing the contents of the generated map, uses the expected range form of the for loop:

```markup
for key, value := range aMap {    fmt.Printf("%s: %d\n", key, value) 
   } 
} 
```

As you can easily guess, developing the inverse operation is not always possible because map is a richer data structure than array. However, the price you pay for a more powerful data structure is time because array operations are usually faster.

# Structures

Although arrays, slices, and maps are all very useful, they cannot hold multiple values in the same place. When you need to group various types of variables and create a new handy type, you can use a structure--the various elements of a structure are called fields.

The code of this subsection is saved as dataStructures.go and can be divided into three parts. The first part contains the preamble and the definition of a new structure named message:

```markup
package main 
 
import ( 
   "fmt" 
   "reflect" 
) 
 
func main() { 
 
   type message struct {
         X     int 
         Y     int 
         Label string 
   } 
```

The message structure has three fields, named X, Y, and Label. Note that structures are usually defined at the beginning of a program and outside the main() function.

The second part uses the message structure to define two new message variables, named p1 and p2. Then, it uses reflection to get information about the p1 and p2 variables of the message structure:

```markup
   p1 := message{23, 12, "A Message"} 
   p2 := message{} 
   p2.Label = "Message 2" 
 
   s1 := reflect.ValueOf(&p1).Elem() 
   s2 := reflect.ValueOf(&p2).Elem() 
   fmt.Println("S2= ", s2) 
```

The last part shows how to print all the fields of a structure without knowing their names using a for loop and the Type() function:

```markup
   typeOfT := s1.Type() 
   fmt.Println("P1=", p1) 
   fmt.Println("P2=", p2) 
 
   for i := 0; i < s1.NumField(); i++ {         f := s1.Field(i)         fmt.Printf("%d: %s ", i, typeOfT.Field(i).Name) 
         fmt.Printf("%s = %v\n", f.Type(), f.Interface()) 
   } 
 
} 
```

Running dataStructures.go will generate the following kind of output:

```markup
$ go run dataStructures.go
S2=  {0 0 Message 2}
P1= {23 12 A Message}
P2= {0 0 Message 2}
0: X int = 23
1: Y int = 12
2: Label string = A Message
```

If the name of a field of a struct definition begins with a lowercase letter (x instead of X), the previous program will fail with the following error message:

```markup
panic: reflect.Value.Interface: cannot return value obtained from unexported field or method
  
```

This happens because lowercase fields do not get exported; therefore, they cannot be used by the reflect.Value.Interface() method. You will learn more about reflection in the next chapter.

Just Imagine

# Interfaces

Interfaces are an advanced Go feature, which means that you might not want to use them in your programs if you are not feeling very comfortable with Go. However, interfaces can be very practical when developing big Go programs, which is the main reason for talking about interfaces in this book.

But first, I will talk about methods, which are functions with a special receiver argument. You declare methods as ordinary functions with an additional parameter that appears just before the function name. This particular parameter connects the function to the type of that extra parameter. As a result, that parameter is called the receiver of the method. You will see such functions in a while.

Put simply, interfaces are abstract types that define a set of functions that need to be implemented so that a type can be considered an instance of the interface. When this happens, we say that the type satisfies this interface. So, an interface is two things--a set of methods and a type--and it is used for defining the behavior of a type.

Let's describe the main advantage of interfaces with an example. ImagineDevOps  that you have a type named ATYPE and an interface for the ATYPE type. Any function that accepts an ATYPE variable can accept any other variable that implements the interface of ATYPE.

The Go code of interfaces.go can be divided into three parts. The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
type coordinates interface { 
   xaxis() int 
   yaxis() int 
} 
 
type point2D struct { 
   X int 
   Y int 
} 
```

In this part, you define an interface called coordinates and a new structure called point2D. The interface has two functions, named xaxis() and yaxis(). The definition of the coordinates interface says that if you want to convert to the coordinates interface, you will have to implement these two functions.

It is important to notice that the interface does not state any other specific types apart from the interface itself. On the other hand, the two functions of the interface should state the types of their return values.

The second part has the following Go code:

```markup
func (s point2D) xaxis() int { 
   return s.X 
} 
 
func (s point2D) yaxis() int { 
   return s.Y 
} 
 
func findCoordinates(a coordinates) { 
   fmt.Println("X:", a.xaxis(), "Y:", a.yaxis()) 
} 
 
type coordinate int 
 
func (s coordinate) xaxis() int { 
   return int(s) 
} 
 
func (s coordinate) yaxis() int { 
   return 0 
} 
```

In the second part, you first implement the two functions of the coordinates interface for the point2D type. Then you develop a function named findCoordinates() that accepts a variable that implements the coordinates interface. The findCoordinates() function just prints the two coordinates of a point using a simple fmt.Println() function call. Then, you define a new type named coordinate that is used for points that belong to the _x_\-axis. Last, you implement the coordinates interface for the coordinate type.

At the time of writing the code for interfaces.go, I believed that the coordinates and coordinate names were fine. After writing the previous paragraph, I realized that the coordinate type could have been renamed to xpoint for better readability. I left the names coordinates and coordinate to point out that everybody makes mistakes and that the variable and type names you are using must be chosen wisely.

The last part has the following Go code:

```markup
func main() { 
 
   x := point2D{X: -1, Y: 12}
   fmt.Println(x) 
   findCoordinates(x) 
 
   y := coordinate(10) 
   findCoordinates(y) 
} 
```

In this part, you first create a point2D variable and print its coordinates using the findCoordinates() function, then you create a coordinate variable named y that holds a single coordinate value. Lastly, you print the y variable using the same findCoordinates() function used for printing a point2D variable.

Although Go is not an object-oriented programming language, I will use some object-oriented terminology here. So, in object-oriented terminology, this means that both point2D and coordinate types are coordinate objects. However, none of them are _only_ a coordinate object.

Executing interfaces.go creates the following output:

```markup
$ go run interfaces.go
{-1 12}
X: -1 Y: 12
X: 10 Y: 0
```

I believe that Go interfaces are not necessary when developing systems software, but they are a handy Go feature that can make the development of a systems application more readable and simpler, so do not hesitate to use them.

Just Imagine

# Creating random numbers

As a practical programming example, this section will talk about creating random numbers in Go. Random numbers have many uses, including the generation of good passwords as well as the creation of files with random data that can be used for testing other applications. However, bear in mind that usually programming languages generate pseudorandom numbers that approximate the properties of a true random number generator.

Go uses the math/rand package for generating random numbers and needs a seed to start producing random numbers. The seed is used for initializing the entire process and is extremely important because if you always start with the same seed, you will always get the same sequence of random numbers.

The random.go program has three main parts. The first part is the preamble of the program:

```markup
package main 
 
import ( 
   "fmt" 
   "math/rand" 
   "os" 
   "strconv" 
   "time" 
) 
```

The second part is the definition of the random() function that returns a random number each time it is called, using the rand.Intn() Go function:

```markup
func random(min, max int) int { 
   return rand.Intn(max-min) + min 
} 
```

The two parameters of the random() function define the lower and upper limits of the generated random number. The last part of random.go is the implementation of the main() function that is mainly used for calling the random() function:

```markup
func main() { 
   MIN := 0 
   MAX := 0 
   TOTAL := 0 
   if len(os.Args) > 3 { 
         MIN, _ = strconv.Atoi(os.Args[1]) 
         MAX, _ = strconv.Atoi(os.Args[2]) 
         TOTAL, _ = strconv.Atoi(os.Args[3]) 
   } else { 
         fmt.Println("Usage:", os.Args[0], "MIX MAX TOTAL") 
         os.Exit(-1) 
   } 
 
   rand.Seed(time.Now().Unix()) 
   for i := 0; i < TOTAL; i++ { 
         myrand := random(MIN, MAX) 
         fmt.Print(myrand) 
         fmt.Print(" ") 
   } 
   fmt.Println() 
} 
```

A big part of the main() function involves dealing with the reading of command-line arguments as integer numbers and printing a descriptive error message in case you did not get the correct number of command-line arguments. This is the standard practice that we will follow in this book. The random.go program uses the Unix epoch time as the seed for the random number generator by calling the time.Now().Unix() function. The important thing to remember is that you do not have to call rand.Seed() multiple times. Lastly, random.go does not examine the error variable returned by strconv.Atoi() to save book space, not because it is not necessary.

Executing random.go generates the following kind of output:

```markup
$ go run random.go 12 32 20
29 27 20 23 22 28 13 16 22 26 12 29 22 30 15 19 26 24 20 29
  
```

Should you wish to generate more secure random numbers in Go, you should use the crypto/rand package, which implements a cryptographically secure pseudorandom number generator. You can find more information about the crypto/rand package by visiting its documentation page at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).

If you are really into random numbers, then the definitive reference to the theory of random numbers is the second volume of _The Art of Computer Programming_ by Donald Knuth.

Just Imagine

# Exercises

1.  Browse the Go documentation site: [https://golang.org/doc/](https://golang.org/doc/).[](https://golang.org/doc/)
2.  Write a Go program that keeps reading integers until you give the number 0 as input, then it prints the minimum and maximum integer in the input.
3.  Write the same Go program as before, but this time, you will get your input using command-line arguments. Which version do you think is better? Why?
4.  Write a Go program that supports two command-line options (\-i and \-k) in random order using if statements. Now change your program to support three command-line arguments. As you will see, the complexity of the latter program is just too much to handle using if statements.
5.  If the indices of a map were natural numbers, are there any cases that it would be wise and efficient to use a map instead of an array?
6.  Try to put the functionality of array2map.go into a separate function.
7.  Try to develop your own random number generator in Go that will still use the current time as a seed but not the math/rand package.
8.  Learn how to create a slice from an existing array. What happens when you make changes to the slice?
9.  Use the copy() function to make a copy of an existing slice. What happens when the destination slice is smaller than the source slice? What happens when the destination slice is bigger than the source slice?
10.  Try to write an interface for supporting points in 3D space. Then, use this interface to support points that reside on the x-axis.

Just Imagine

# Summary

You learned many things in this chapter, including getting user input and processing command-line arguments. You familiarized yourself with the basic Go structures and you created a Go program that generates random numbers. Try to do the offered exercises and do not get discouraged if you fail in some of them.

The next chapter will talk about many advanced Go features, including error handling, pattern matching, regular expressions, reflection, unsafe code, calling C code from Go, and the strace(1) command-line utility. I will compare Go with other programming languages and give you practical advice in order to avoid some common Go pitfalls.