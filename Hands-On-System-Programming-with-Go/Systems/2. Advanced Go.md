# Advanced Go Features

In the previous chapter, you learned how to compile Go code, how to get input from the user and print the output on the screen, how to create your own Go functions, the data structures that Go supports, and how to process command-line arguments.

This chapter will discuss many fascinating things, so you better prepare yourselves for lots of interesting and practical Go code that will help you perform many different yet really important tasks, starting with error handling and ending with how to avoid some common Go mistakes. If you are familiar with Go, you can skip what you already know, but please do not skip the proposed exercises.

So, this chapter will talk about some advanced Go features, including:

-   Error handling
-   Error logging
-   Pattern matching and regular expressions
-   Reflection
-   How to use the strace(1) and dtrace(1) tools to watch the system calls of Go executable files
-   How to detect unreachable Go code
-   How to avoid various common Go mistakes

Bookmark

# Error handling in Go

Errors happen all the time, so it is our job to both catch and handle them, especially when writing code that deals with sensitive system information and files. The good news is that Go has a special data type called error that helps signify erroneous states; if an error variable has a nil value, then there is no error situation.

As you saw in the addCLA.go program that was developed in the previous chapter, you can ignore the error variable that is returned by most Go functions using the \_ character:

```markup
temp, _ := strconv.Atoi(arguments[i]) 
```

However, this is not considered good practice and should be avoided, especially on systems software and other kinds of critical software, such as server processes.

As you will see in [Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, even **End of File** (**EOF**) is a type of error that is returned when there is nothing left to read from a file. As EOF is defined in the io package, you can handle it as follows:

```markup
if err == io.EOF { 
    // Do something 
} 
```

However, the most important task to learn is how to develop functions that return error variables and how to handle them, which is explained next.

# Functions can return error variables

Go functions can return error variables, which means that an error condition can be handled inside a function, outside of a function, or both inside and outside the function; the latter situation does not happen very often. So, this subsection will develop a function that returns error messages. The relevant Go code can be found in funErr.go and will be presented in three parts.

The first part contains the following Go code:

```markup
package main 
 
import ( 
   "errors" 
   "fmt" 
   "log" 
) 
 
func division(x, y int) (int, error, error) { 
   if y == 0 { 
         return 0, nil, errors.New("Cannot divide by zero!") 
   } 
   if x%y != 0 { 
         remainder := errors.New("There is a remainder!") 
         return x / y, remainder, nil 
   } else { 
         return x / y, nil, nil 
   } 
 
} 
```

Apart from the expected preamble, the preceding code defines a new function named division(), which returns an integer and two error variables. If you remember from your Math classes, when you divide two integer numbers, the division operation is not always perfect, which means that you might get a remainder that is not zero. The errors.New() function from the errors Go package that you see in funErr.go creates a new error variable, using the provided string as the error message.

The second part of funErr.go has the following Go code:

```markup
func main() { 
   result, rem, err := division(2, 2) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
```

It is a very common Go practice to compare an error variable with nil to quickly find out whether there is an error condition or not.

The last part of funErr.go is as follows:

```markup
   result, rem, err = division(12, 5) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
 
   result, rem, err = division(2, 0) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
} 
```

This part showcases two erroneous conditions. The first one is an integer division that has a remainder, whereas the second one is an invalid division because you cannot divide a number by zero. As the name log.Fatal() implies, this logging function should be used for critical errors only because when called, it automatically terminates your program. However, as you will see in the next subsection, there exist other, more gentle, ways to log your error messages.

Executing funErr.go generates the next output:

```markup
$ go run funErr.go
The result is 1
The result is 2
There is a remainder!
2017/03/07 07:39:19 Cannot divide by zero!
exit status 1
```

The last line is automatically generated by the log.Fatal() function, just before terminating the program. It is important to understand that any Go code after the call to log.Fatal() will not be executed.

# About error logging

Go offers functions that can help you log your error messages in various ways. You already saw log.Fatal() in funErr.go, which is a somewhat cruel way to deal with simple errors. Put simply, you should have a very good reason to use log.Fatal() in your code. Generally speaking, log.Fatal() should be used instead of the os.Exit() function because it allows you to print an error message and exit your program using just one function call.

Go offers additional error logging functions in the log standard package that behave more gently depending on the situation, which includes log.Printf(), log.Print(), log.Println(), log.Fatalf(), log.Fatalln(), log.Panic(), log.Panicln(), and log.Panicf(). Please note that logging functions can be handy for debugging purposes so do not underestimate their power.

The logging.go program illustrates two of the mentioned logging functions using the following Go code:

```markup
package main 
 
import ( 
   "log" 
) 
 
func main() { 
   x := 1 
   log.Printf("log.Print() function: %d", x) 
   x = x + 1 
   log.Printf("log.Print() function: %d", x) 
   x = x + 1 
   log.Panicf("log.Panicf() function: %d", x) 
   x = x + 1 
   log.Printf("log.Print() function: %d", x) 
} 
```

As you can see, logging.go does not need the fmt package because it has its own functions for printing the output. Executing logging.go will produce the following output:

```markup
$ go run logging.go
2017/03/10 16:51:56 log.Print() function: 1
2017/03/10 16:51:56 log.Print() function: 2
2017/03/10 16:51:56 log.Panicf() function: 3
panic: log.Panicf() function: 3
    
goroutine 1 [running]:
log.Panicf(0x10b78d0, 0x19, 0xc42003df48, 0x1, 0x1)
      /usr/local/Cellar/go/1.8/libexec/src/log/log.go:329 +0xda
main.main()
      /Users/mtsouk/ch3/code/logging.go:14 +0x1af
exit status 2
```

Although the log.Printf() function works in the same way as fmt.Printf(), it automatically prints the date and time the log message was printed, just like the log.Fatal() function did in funErr.go. Additionally, the log.Panicf() function works in a similar way to log.Fatal()\--they both terminate the current program. However, log.Panicf() prints some additional information, useful for debugging purposes.

Go also offers the log/syslog package that is a simple interface to the system log service running on your Unix machine. [](https://subscription.imaginedevops.io/book/programming/9781787125643/7)[Chapter 7](https://subscription.imaginedevops.io/book/programming/9781787125643/7), _Working with System Files_, will talk more about the log/syslog package.

# The addCLA.go program revisited

This subsection will present an improved version of the addCLA.go program we developed in the previous chapter, to make it able to handle any kind of user input. The new program will be called addCLAImproved.go, but instead of presenting its full Go code, you will only see the differences between addCLAImproved.go and addCLA.go using the diff(1) command-line utility:

```markup
$ diff addCLAImproved.go addCLA.go
13,18c13,14
<           temp, err := strconv.Atoi(arguments[i])
<           if err == nil {
<                 sum = sum + temp
<           } else {
<                 fmt.Println("Ignoring", arguments[i])
<           }
---
>           temp, _ := strconv.Atoi(arguments[i])
>           sum = sum + temp
```

What this output basically tells us is that the last two lines of code, which can be found in addCLA.go and begin with the \> character, were replaced by the lines of code that begin with the < character in addCLAImproved.go. The remaining code of both files is exactly the same.

The diff(1) utility compares text files line by line and is a handy way of spotting code differences between different versions of the same file.

Executing addCLAImproved.go will generate the following kind of output:

```markup
$ go run addCLAImproved.go
Sum: 0
$ go run addCLAImproved.go 1 2 -3
Sum: 0
$ go run addCLAImproved.go 1 a 2 b 3.2 @
Ignoring a
Ignoring b
Ignoring 3.2
Ignoring @
Sum: 3
```

So, the new and improved version works as expected, behaves reliably, and allows us to differentiate between valid and invalid input.

Bookmark

# Pattern matching and regular expressions

**Pattern matching**, which plays a key role in Go, is a technique for searching a string for a set of characters based on a specific search pattern that is based on **regular expressions**. If pattern matching is successful, it allows you to extract the desired data from the string or replace or delete it. **Grammar** is a set of production rules for strings in a formal language. The production rules describe how to create strings from the alphabet of the language that are valid according to the syntax of the language. Grammar does not describe the meaning of a string or what can be done with it in whatever context, only its form. What is important is to realize that grammar is at the heart of regular expressions because without it, you cannot define or use a regular expression.

Regular expressions and pattern matching are not a panacea, so you should not try to solve every problem using regular expressions since they are not suitable for every kind of problem you may come up against. Furthermore, they might introduce unnecessary complexity to your software.

The Go package responsible for the pattern matching capabilities of Go is called regexp, which you can see in action in regExp.go. The code of regExp.go will be presented in four parts.

The first part is the expected preamble:

```markup
package main 
 
import ( 
   "fmt" 
   "regexp" 
) 
```

The second part is as follows:

```markup
func main() { 
match, _ := regexp.MatchString("Mihalis", "Mihalis Tsoukalos") 
   fmt.Println(match) 
   match, _ = regexp.MatchString("Tsoukalos", "Mihalis tsoukalos") 
   fmt.Println(match) 
```

Both calls to regexp.MatchString() try to find a static string, which is the first parameter, in a given string, which is the second parameter.

The third part contains a single, yet crucial, line of Go code:

```markup
   parse, err := regexp.Compile("[Mm]ihalis") 
```

The regexp.Compile() function reads the provided regular expression and tries to parse it. If the parsing of the regular expressing is successful, then regexp.Compile() returns a value of the regexp.Regexp variable type that you can use afterward. The \[Mm\] expression in the regexp.Compile() function means that what you are looking for can begin with an uppercase M or a lowercase m. Both \[ and \] are special characters that are not part of the regular expression. So, the provided grammar is naive and only matches the words Mihalis and mihalis.

The last part uses the previous regular expression that is stored in the parse variable:

```markup
   if err != nil { 
         fmt.Printf("Error compiling RE: %s\n", err) 
   } else { 
         fmt.Println(parse.MatchString("Mihalis Tsoukalos")) 
         fmt.Println(parse.MatchString("mihalis Tsoukalos")) 
         fmt.Println(parse.MatchString("M ihalis Tsoukalos")) 
         fmt.Println(parse.ReplaceAllString("mihalis Mihalis", "MIHALIS")) 
   } 
} 
```

Running regExp.go generates the next output:

```markup
$ go run regExp.go
true
false
true
true
false
MIHALIS MIHALIS
```

So, the first call to regexp.MatchString() was a match, but the second was not because pattern matching is case-sensitive and Tsoukalos does not match tsoukalos. The parse.ReplaceAllString() function at the end searches the string that is given as an input ("mihalis Mihalis") and replaces each match with the string that is given as its second parameter ("MIHALIS").

The rest of this section will present various examples using static text because you do not know how to read text files yet. However, as the static text will be stored in an array and processed line by line, the presented code can be easily modified to support getting your input from external text files.

# Printing all the values from a given column of a line

This is a very common scenario, as you often will need to get all the data from a given column of a structured text file in order to analyze it afterward. The code of readColumn.go, which prints values in the third column, will be presented in two parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "strings" 
) 
 
func main() { 
   var s [3]string 
   s[0] = "1 2 3" 
   s[1] = "11 12 13 14 15 16" 
   s[2] = "-1 2 -3 -4 -5 6" 
```

Here, you import the required Go packages and define a string with three lines using an array with three elements.

The second part contains the following Go code:

```markup
   column := 2 
 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         if len(data) >= column { 
               fmt.Println((data[column-1])) 
         } 
   } 
} 
```

First, you define the column that interests you. Then, you start iterating over the strings stored in the array. This is similar to reading a text file line by line. The Go code inside the for loop splits the fields of the input line, stores them in the data array, verifies that the value from the desired column is present, and prints it on your screen. All of the hard work is done by the handy strings.Fields() function that splits a string based on whitespace characters, as defined in unicode.IsSpace(), and returns a slice of strings. Although readColumn.go does not use the regexp.Compile() function, the logic behind its implementation with the use of strings.Fields() is still based on the principles of regular expressions.

An important thing to remember is that you should never trust your data. Put simply, always verify that the data you expect to grab is there.

Executing readColumn.go will generate the following kind of output:

```markup
$ go run readColumn.go
2
12
2
```

[](https://subscription.imaginedevops.io/book/programming/9781787125643/6)[Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, will show an improved version of readColumn.go that you can use as a starting point in case you want to modify the rest of the examples shown.

# Creating summaries

In this section, we will develop a program that adds all the values of a given column of text with multiple lines. To make things even more interesting, the column number will be given as a parameter in the program. The main difference between the program of this subsection and readColumn.go from the previous subsection is that you will need to convert each value into an integer number.

The name of the program that will be developed is summary.go and can be divided into three parts.

The first part is this:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strconv" 
   "strings" 
) 
 
func main() { 
   var s [3]string 
   s[0] = "1 b 3" 
   s[1] = "11 a 1 14 1 1" 
   s[2] = "-1 2 -3 -4 -5" 
```

The second part has the following Go code:

```markup
   arguments := os.Args 
   column, err := strconv.Atoi(arguments[1]) 
   if err != nil { 
         fmt.Println("Error reading argument") 
         os.Exit(-1) 
   } 
   if column == 0 { 
         fmt.Println("Invalid column") 
         os.Exit(1) 
   } 
```

The previous code reads the index of the column that interests you. If you want to make summary.go even better, you can check for negative values in the column variable and print the appropriate error message.

The last part of summary.go is as follows:

```markup
   sum := 0 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         if len(data) >= column { 
               temp, err := strconv.Atoi(data[column-1]) 
               if err == nil { 
                     sum = sum + temp 
               } else { 
                     fmt.Printf("Invalid argument: %s\n", data[column-1]) 
               } 
         } else { 
               fmt.Println("Invalid column!") 
         } 
   } 
   fmt.Printf("Sum: %d\n", sum) 
} 
```

As you can see, most of the Go code in summary.go is about dealing with exceptions and potential errors. The core functionality of summary.go is implemented in a few lines of Go code.

Executing summary.go will give you the following output:

```markup
$ go run summary.go 0
Invalid column
exit status 1
$ go run summary.go 2
Invalid argument: b
Invalid argument: a
Sum: 2
$ go run summary.go 1
Sum: 11
```

# Finding the number of occurrences

A very common programming problem is finding out the number of times an IP address appears in a log file. So, the example in this subsection will show you how to do this using a handy map structure. The occurrences.go program will be presented in three parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "strings" 
) 
 
func main() { 
 
   var s [3]string 
   s[0] = "1 b 3 1 a a b" 
   s[1] = "11 a 1 1 1 1 a a" 
   s[2] = "-1 b 1 -4 a 1" 
```

The second part is as follows:

```markup
   counts := make(map[string]int) 
 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         for _, word := range data { 
               _, ok := counts[word] 
               if ok { 
                     counts[word] = counts[word] + 1 
               } else { 
                     counts[word] = 1 
               } 
         } 
   } 
```

Here, we use the knowledge from the previous chapter to create a map named counts and populate it with the desired data using two for loops.

The last part is pretty small as it just prints the contents of the counts map:

```markup
   for key, _ := range counts { 
         fmt.Printf("%s -> %d \n", key, counts[key]) 
   } 
} 
```

Executing occurrences.go and using the sort(1) command-line utility to sort the output of occurrences.go will generate the following kind of output:

```markup
$ go run occurrences.go | sort -n -r -t\  -k3,3
1 -> 8
a -> 6
b -> 3
3 -> 1
11 -> 1
-4 -> 1
-1 -> 1
```

As you can see, traditional Unix tools are still useful.

# Find and replace

The example in this subsection will search the provided text for two variations of a given string and replace it with another string. The program will be named findReplace.go and will actually use Go regular expressions. The main reason for using the regexp.Compile() function, in this case, is that it greatly simplifies things and allows you to access your text only once.

The first part of the findReplace.go program is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "regexp" 
) 
```

The next part is as follows:

```markup
func main() { 
 
   var s [3]string 
   s[0] = "1 b 3" 
   s[1] = "11 a B 14 1 1" 
   s[2] = "b 2 -3 B -5" 
 
   parse, err := regexp.Compile("[bB]") 
 
   if err != nil { 
         fmt.Printf("Error compiling RE: %s\n", err) 
         os.Exit(-1) 
   } 
```

The previous Go code will find every occurrence of an uppercase B or a lowercase b (\[bB\]). Note that there is also regexp.MustCompile() that works like regexp.Compile(). However, regexp.MustCompile() does not return an error variable; it just panics if the given expression is erroneous and cannot be parsed. As a result, regexp.Compile() is a better choice.

The last part is as follows:

```markup
   for i := 0; i < len(s); i++ { 
         temp := parse.ReplaceAllString(s[i], "C") 
         fmt.Println(temp) 
   } 
} 
```

Here you replace each match with an uppercase C using parse.ReplaceAllString().

Executing findReplace.go generates the expected output:

```markup
$ go run findReplace.go
1 C 3
11 a C 14 1 1
C 2 -3 C -5
```

The awk(1) and sed(1) command-line tools can do most of the previous tasks more easily, but sed(1) and awk(1) are not general-purpose programming languages.

Bookmark

# Reflection

Reflection is an advanced Go feature that allows you to dynamically learn the type of an arbitrary object as well as information about its structure. You should recall that the dataStructures.go program from [Chapter 2](https://subscription.imaginedevops.io/book/programming/9781787125643/2), _Writing Programs in Go_, used reflection to find out the fields of a data structure as well as the type of each fields. All of this happened with the help of the reflect Go package and the reflect.TypeOf() function that returns a Type variable.

Reflection is illustrated in the reflection.go Go program that will be presented in four parts.

The first one is the preamble of the Go program and has the following code:

```markup
package main 
 
import ( 
   "fmt" 
   "reflect" 
) 
```

The second part is as follows:

```markup
func main() { 
 
   type t1 int 
   type t2 int 
 
   x1 := t1(1) 
   x2 := t2(1) 
   x3 := 1 
```

Here, you create two new types, named t1 and t2, that are both int and three variables, named x1, x2, and x3.

The third part has the following Go code:

```markup
   st1 := reflect.ValueOf(&x1).Elem() 
   st2 := reflect.ValueOf(&x2).Elem() 
   st3 := reflect.ValueOf(&x3).Elem() 
 
   typeOfX1 := st1.Type() 
   typeOfX2 := st2.Type() 
   typeOfX3 := st3.Type() 
 
   fmt.Printf("X1 Type: %s\n", typeOfX1) 
   fmt.Printf("X2 Type: %s\n", typeOfX2) 
   fmt.Printf("X3 Type: %s\n", typeOfX3) 
```

Here, you find the type of the x1, x2, and x3 variables using reflect.ValueOf() and Type().

The last part of reflection.go deals with a struct variable:

```markup
   type aStructure struct { 
         X    uint 
         Y    float64 
         Text string 
   } 
 
   x4 := aStructure{123, 3.14, "A Structure"} 
   st4 := reflect.ValueOf(&x4).Elem() 
   typeOfX4 := st4.Type() 
 
   fmt.Printf("X4 Type: %s\n", typeOfX4) 
   fmt.Printf("The fields of %s are:\n", typeOfX4) 
 
   for i := 0; i < st4.NumField(); i++ { 
         fmt.Printf("%d: Field name: %s ", i, typeOfX4.Field(i).Name) 
         fmt.Printf("Type: %s ", st4.Field(i).Type()) 
         fmt.Printf("and Value: %v\n", st4.Field(i).Interface()) 
   } 
} 
```

There exist some laws that govern reflection in Go, but talking about them is beyond the scope of this book. What you should remember is that your programs can examine their own structure using reflection, which is a very powerful capability.

Executing reflection.go prints the following output:

```markup
$ go run reflection.go
X1 Type: main.t1
X2 Type: main.t2
X3 Type: int
X4 Type: main.aStructure
The fields of main.aStructure are:
0: Field name: X Type: uint and Value: 123
1: Field name: Y Type: float64 and Value: 3.14
2: Field name: Text Type: string and Value: A Structure
```

The first two lines of the output show that Go does not consider the types t1 and t2 as equal, even though both t1 and t2 are aliases of the int type.

Old habits die hard!

Despite the fact that Go tries to be a safe programming language, sometimes it is forced to forget about safety and allows the programmer to do whatever he/she wants.

# Calling C code from Go

Go allows you to call C code because there are times when the only way to perform some tasks, such as communicating with a hardware device or a database server, is by using C. Nevertheless, if you find yourself using this capability many times in the same project, you might need to reconsider your approach and your choice of programming language.

Talking more about this capability in Go is beyond the scope of this book. What you should remember is that most likely, you will never need to call C code from your Go program. Nevertheless, should you wish to explore this Go feature, you can start by visiting the documentation of the cgo tool at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/) as well as by looking at the code found at [https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go](https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go).

# Unsafe code

Unsafe code is Go code that bypasses the type safety and memory security of Go and requires the use of the unsafe package. You will most likely never need to use unsafe code in your Go programs but if for some strange reason you ever need to, it will probably have to do with pointers.

Using unsafe code can be dangerous for your programs, so only use it when it is absolutely necessary. If you are not completely sure that you need it, then do not use it.

The example code in this subsection is saved as unsafe.go and will be presented in two parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "unsafe" 
) 
 
func main() { 
   var value int64 = 5 
   var p1 = &value 
   var p2 = (*int32)(unsafe.Pointer(p1)) 
```

You first create a new int64 variable that is named value. Then, you create a pointer to it named p1. Next, you create another pointer that points to p1. However, the p2 pointer that points to p1 is a pointer to an int32 integer, despite the fact that p1 points to an int64 variable. Although this is not permitted by Go rules, the unsafe.Pointer() function makes this possible.

The second part is as follows:

```markup
   fmt.Println("*p1: ", *p1) 
   fmt.Println("*p2: ", *p2) 
   *p1 = 312121321321213212 
   fmt.Println(value) 
   fmt.Println("*p2: ", *p2) 
   *p1 = 31212132 
   fmt.Println(value) 
   fmt.Println("*p2: ", *p2) 
} 
```

Executing unsafe.go will create the following output:

```markup
$ go run unsafe.go
*p1:  5
*p2:  5
312121321321213212
*p2:  606940444
31212132
*p2:  31212132
```

The output shows how dangerous an unsafe pointer can be. When the value of the value variable fits into an int32 memory space (5 and 31212132), then p2 works fine and shows the correct result. However, when the value variable holds a value (312121321321213212) that does not fit into an int32 memory space, then p2 shows an erroneous result (606940444), without giving you a warning or an error message.

Bookmark

# Comparing Go to other programming languages

Go is not perfect, but neither are the rest of the programming languages. This section will briefly discuss other programming languages and compare them to Go in order to give you a better understanding of the choices you have. So, the list of programming languages that can be compared to Go includes:

-   **C**: C is the most popular programming language for developing systems software because the portable part of each Unix operating system is written in C. However, it has some critical drawbacks, including the fact that C pointers, which are great and fast, can lead to difficult-to-detect bugs and memory leaks. Additionally, C does not offer garbage collection; back when C was created, garbage collection was a luxury that had the ability slow down computers. However, nowadays computers are pretty fast and garbage collection does not slow things down anymore. Moreover, C programs require more code for developing a given task than other systems programming languages. Lastly, C is an old programming language that does not support modern programming paradigms, such as object-oriented and functional programming.
-   **C++**: As previously mention, I do not like C++ anymore. If you think that you should use C++, then you may want to consider using C instead. However, the main advantage of C++ over Go is that if needed, C++ can be used as if it were C. However, neither C nor C++ have good support for concurrent programming.
-   **Rust**: Rust is a new systems programming language that tries to avoid unpleasant bugs caused by unsafe code. Currently, the syntax of Rust is changing too fast, but this will end in the near feature. If for some reason you do not like Go, you should try Rust.
-   **Swift**: In its current status, Swift is more suitable for developing systems software for macOS systems. However, I am sure that in the near feature, Swift will be more popular on Linux machines, so you should keep an eye on it.
-   **Python**: Python is a scripting language, which is its main disadvantage. This is because usually, you do not want to make the source of your systems software available to everyone.
-   **Perl**: What was said about Python can be also said about Perl. However, both programming languages have a plethora of modules that will make your life a lot easier and your code a lot smaller.

If you ask my opinion, I think that Go is a modern, portable, mature, and safe programming language for writing systems software. You should try Go before looking for any alternatives. However, if you are a Go programmer and want to try something else, I suggest that you pick Rust or Swift. Yet, if you need to write reliable concurrent programs, Go should be your first choice.

If you cannot choose between Go and Rust, then just try C. Learning the basics of systems programming is more important than the programming language you select.

Despite their disadvantages, bear in mind that all scripting programming languages are perfect for writing prototypes and have the advantage that they allow you to create graphical interfaces for your software. Still, delivering systems software in a scripting language is rarely accepted, unless there is a really good reason to do so.

Bookmark

# Analysing software

There are times that a program fails for some unknown reason or does not perform well, and you want to find out why without having to rewrite your code and add a plethora of debugging statements. So, this section will talk about strace(1) and dtrace(1) , which allow you to see what is going on behind the scenes when you execute a program on a Unix machine. Although both tools can work with the go run command, you will get less unrelated output if you first create an executable file using go build and use this file. This mainly occurs because go run makes temporary files before actually running your Go code, and you want to debug the actual program, not the compiler used to build the program.

Remember that although dtrace(1) is more powerful than strace(1) and has its own programming language, strace(1) is more versatile for watching the system calls a program makes.

# Using the strace(1) command-line utility

The strace(1) command-line utility allows you to trace system calls and signals. As strace(1) is not available on Mac machines, this section will use a Linux machine to showcase strace(1). However, as you will see in a later, macOS machines have the dtrace(1) command-line utility that can do many more things.

The number after the name of a program refers to the section of the manual its page belongs to. Although most of the names can be found only once, which means that putting the section number is not necessary, there are names that can be located in multiple sections because they have multiple meanings, such as crontab(1) and crontab(5). Therefore, if you try to retrieve such a page without specifically stating the section number, you will get the entry in the section of the manual that has the smallest section number.

To get a good sense of the output generated by strace(1), look at the following figure where strace(1) is used to examine the executable of addCLAImproved.go:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/6c0c5c81-3946-433a-bc90-4dafd085d3a0.png)

Using the strace(1) command on a Linux machine

The really interesting part of the strace(1) output is the following line, which cannot be seen in the preceding figure:

```markup
$ strace ./addCLAImproved 1 2 2>&1 | grep write
write(1, "Sum: 3\n", 7Sum: 3
```

We used the grep(1) command-line utility to extract the lines that contain the C system call that interests us, which in this case is write(2). This is because we already know that write(2) is used for printing output. So, you learned that in this case, a single write(2) C system call is used for printing all of the output on the screen; its first parameter is the file descriptor, and its second parameter is the text you want to print.

Note that you might want to use strace(1) with the \-f option in order to also trace any child processes that might get created during the execution of a program.

Bear in mind that there exist two more variations of write(2), named pwrite(2) and writev(2), which offer the same core functionality as write(2) but in a slightly different way.

The following variation of the previous command requires more calls to write(2) because it generates more output:

```markup
$ strace ./addCLAImproved 1 a b 2>&1 | grep write
write(1, "Ignoring a\n", 11Ignoring a
write(1, "Ignoring b\n", 11Ignoring b
write(1, "Sum: 1\n", 7Sum: 1
```

Unix uses file descriptors, which are positive integer values, as an internal representation for accessing all its files. By default, all Unix systems support three special and standard filenames: /dev/stdin, /dev/stdout, and /dev/stderr. They can also be accessed using file descriptors 0, 1, and 2, respectively. These three file descriptors are also called standard input, standard output, and standard error, respectively. Additionally, the file descriptor 0 can be accessed as /dev/fd/0 on a Mac machine and as /dev/pts/0 on a Debian Linux machine because everything in Unix is a file.

So, the reason for needing to put 2>&1 at the end of the command is to redirect all of the output, from standard error (file descriptor 2) to standard output (file descriptor 1), in order to be able to search it using the grep(1) command, which searches standard output only. Note that there exist many variations of grep(1), including zegrep(1), fgrep(1), and fgrep(1), that might work faster when they have to deal with large or huge text files.

What you can see here is that even if you are writing in Go, the generated executable uses C system calls and functions because apart from using machine language, C is the only way to communicate with the Unix kernel.

# The DTrace utility

Although debugging utilities, such as strace(1) and truss(1), which work on FreeBSD, can trace system calls produced by a process, they can be slow and therefore not appropriate for solving performance problems on busy Unix systems. Another tool named dtrace(1), which uses the **DTrace** facility, allows you to see what happens behind the scenes on a system-wide basis without the need to modify or recompile anything. It also allows you to work on production systems and watch running programs or server processes dynamically without introducing a big overhead.

This subsection will use the dtruss(1) command-line utility, which is just a dtrace(1) script, that shows the system calls of a process. The output that dtruss(1) generates when examining the addCLAImproved.go executable on a macOS machine looks similar to the one that you can see in the following screenshot:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/f596ddbd-3b87-454d-8eda-478318fd1014.png)

Using the dtruss(1) command on a macOS machine

Once again, the following part of the output verifies that at the end of the day, everything on Unix machines is translated into C system calls and functions because this is the only way to communicate with the Unix kernel. You can display all the calls to the write(2) system call as follows:

```markup
$ sudo dtruss -c ./addCLAImproved 2000 2>&1 | grep write
```

However, this time you are going to get lots of output because the macOS executable uses write(2) multiple times instead of just once to print the same output.

Starting to realize that not all Unix systems work the same way, despite their numerous similarities, is marvelous. But this also means that you should not make any assumptions about the way a Unix system works behind the scenes.

What is really interesting is the last part of the output of the following command:

```markup
$ sudo dtruss -c ./addCLAImproved 2000
CALL                                        COUNT
__pthread_sigmask                               1
exit                                            1
getpid                                          1
ioctl                                           1
issetugid                                       1
read                                            1
thread_selfid                                   1
ulock_wake                                      1
bsdthread_register                              2
close                                           2
csops                                           2
open                                            2
select                                          2
sysctl                                          3
mmap                                            7
mprotect                                        8
stat64                                         41
write                                          83
```

The reason you get this output is the \-c option that tells dtruss(1) to count all system calls and print a summary of them, which in this case shows that write(2) has been called 83 times and stat64(2) 41 times.

The dtrace(1) utility is much more powerful than strace(1) and has its own programming language but is more difficult to learn. Additionally, even though there is a Linux version of dtrace(1), strace(1) is more mature on Linux systems and does the job of tracing system calls in a simpler way.

You can learn more about the dtrace(1) utility by reading _DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X, and FreeBSD_ by Brendan Gregg and Jim Mauro and by visiting [http://dtrace.org/](http://dtrace.org/).

# Disabling System Integrity Protection on macOS

There is a big chance that you will have trouble running dtrace(1) and dtruss(1) on your Mac OS X machine the first time you try them and get the following error message:

```markup
$ sudo dtruss ./addCLAImproved 1 2 2>&1 | grep -i write
dtrace: error on enabled probe ID 2132 (ID 156: syscall::write:return): invalid kernel access in action #12 at DIF offset 92
```

In this case you might need to disable the DTrace restrictions but still keep System Integrity Protection active for everything else. You can learn more about System Integrity Protection by visiting [https://support.apple.com/en-us/HT204899](https://support.apple.com/en-us/HT204899).

Bookmark

# Unreachable code

Unreachable code is code that can never be executed and is a logical kind of error. As the Go compiler itself cannot catch such logical errors, you will need to use the go tool vet command to help.

You should not confuse unreachable code with code that never gets executed intentionally, such as the code of a function that is not needed and is therefore not called in a program.

The example code in this section is saved as cannotReach.go and can be divided into two parts.

The first part has the following Go code:

```markup
package main 
 
import ( 
   "fmt" 
) 
func x() int { 
   return -1 
   fmt.Println("Exiting x()") 
   return -1 
} 
 
func y() int { 
   return -1 
   fmt.Println("Exiting y()") 
   return -1 
} 
```

The second part is as follows:

```markup
func main() { 
   fmt.Println(x()) 
   fmt.Println("Exiting program...") 
} 
```

As you can see, the unreachable code is in the first part. Both x() and y() functions have unreachable code because their return statements were put at the wrong place. However, we are not done yet because we will have to let the go tool vet tool discover the unreachable code. The process is simple and includes the execution of the following command:

```markup
$ go tool vet cannotReach.go
cannotReach.go:9: unreachable code
cannotReach.go:14: unreachable code
 
```

Additionally, you can see that go tool vet detects unreachable code even if the surrounding function is not going to be executed at all, as happens with y().

Bookmark

# Avoiding common Go mistakes

This section will briefly talk about some common Go mistakes so that you can avoid them in your programs:

-   If you have an error in a Go function, either log it or return it; do not do both unless you have a really good reason to do so.
-   Go interfaces define behaviors, not data and data structures.
-   Use the io.Reader and io.Writer interfaces because they make your code more extensible.
-   Make sure that you pass a pointer to a variable to a function only when needed. The rest of the time, just pass the value of the variable.
-   Error variables are not strings; they are error values.
-   If you are afraid of making mistakes, you will most likely end up doing nothing useful. So experiment as much as you can.

The following are general pieces of advice that can be applied in every programming language:

-   Test your Go code and functions in small and autonomous Go programs to make sure that they behave the way you think they should
-   If you do not really know a Go feature, test it before using it for the first time, especially if you are developing a systems utility
-   Do not test systems software on production machines
-   When you deploy your systems software on a production machine, do it when the production machine is not busy and make sure that you have a backup plan

Bookmark

# Exercises

1.  Find and visit the documentation page of the log package.
2.  Use strace(1) to examine hw.go from the previous chapter.
3.  If you are on a Mac, try to examine the hw.go executable using dtruss(1).
4.  Write a program that gets input from the user and examine its executable file using either strace(1) or dtruss(1).

5.  Visit the website of Rust at [https://www.rust-lang.org/](https://www.rust-lang.org/).
6.  Visit the website of Swift at [https://swift.org/](https://swift.org/).
7.  Visit the documentation page of the io package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
8.  Use the diff(1) command-line utility on your own in order to learn how to interpret its output better.
9.  Visit and read the main page of write(2).
10.  Visit the main page of grep(1).
11.  Play with reflection on your own by examining your own structures.
12.  Write an improved version of occurrences.go that will only display frequencies that are above a known numeric threshold, which will be given as a command-line argument.

Bookmark

# Summary

This chapter taught you some advanced Go features, including error handling, pattern matching and regular expressions, reflection, and unsafe code. Also, it talked about the strace(1) and dtrace(1) tools.

The next chapter will cover many interesting things, including the use of the new sort.slice() Go function, which is available in the latest Go version (1.8), as well as the big O notation, sorting algorithms, Go packages, and garbage collection.