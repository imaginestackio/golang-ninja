# System Programming with Go 


# Writing Programs in Go


-   Compiling your Go programs
-   Go environment variables
-   Using the command-line arguments given to a Go program
-   Getting user input and printing the output on your screen
-   Go functions and the defer keyword
-   Go data structures and interfaces
-   Creating random numbers

# Compiling Go code

Go does not care about the name of the source file of an autonomous program as long as the package name is main and there is a main() function in it. This is because the main() function is where the program execution begins. This also means that you cannot have multiple main() functions in the files of a single project.

There exist two ways to run a Go program:

-   The first one, go run, just executes the Go code without generating any new files, only some temporary ones that are deleted afterward
-   The second way, go build, compiles the code, generates an executable file, and waits for you to run the executable file

This book is written on an Apple Mac OS Sierra system using the Homebrew ([https://brew.sh/](https://brew.sh/)) version of Go. However, you should have no difficulties compiling and running the presented Go code on most Linux and FreeBSD systems, provided that you have a relatively recent version of Go.

So, the first way is as follows:

```markup
$ go run hw.go
Hello World!  
```

The aforementioned way allows Go to be used as a scripting language. The following is the second way:

```markup
$ go build hw.go
$ file hw
hw: Mach-O 64-bit executable x86_64
```

The generated executable file is named after the name of the Go source file, which is much better than a.out, which is the default filename of the executable files generated by the C compiler.

If there is an error in your code, such as a misspelled Go package name when calling a Go function, you will get the following kind of error message:

```markup
$ go run hw.go
# command-line-arguments
./hw.go:3: imported and not used: "fmt"
./hw.go:7: undefined: mt in mt.Println
```

If you accidentally misspell the main() function, you will get the following error message because the execution of an autonomous Go program begins from the main() function:

```markup
$ go run hw.go
# command-line-arguments
runtime.main_main f: relocation target main.main not defined
runtime.main_main f: undefined: "main.main"
```

Lastly, I want to show you an error message that will give you a good idea about a formatting rule of Go:

```markup
$ cat hw.gocat 
package main
    
import "fmt"
    
func main()
{
      fmt.Println("Hello World!")
}
$ go run hw.go
# command-line-arguments
./hw.go:6: syntax error: unexpected semicolon or newline before {
  
```

The previous error message shows us that Go prefers putting curly braces in a certain way, which is not the case with most programming languages such as Perl, C, and C++. This might look frustrating at first, but it saves you from one extra line of code and makes your programs more readable. Note that the preceding code uses the _Allman formatting style_, which Go does not accept.

The official explanation for this error is that Go requires the use of semicolons as statement terminators in many contexts, and the compiler automatically inserts the required semicolons when it thinks they are necessary, which in this case is at the end of a non-blank line. Therefore, putting the opening brace ({) on its own line will make the Go compiler to put a semicolon at the end of the previous line, which produces the error message.

If you think that the gofmt tool can save you from similar errors, you will be disappointed:

```markup
$ gofmt hw.go
hw.go:6:1: expected declaration, found '{'
  
```

The Go compiler has another rule, as you can see in the following output:

```markup
$ go run afile.go
# command-line-arguments
./afile.go:4: imported and not used: "net"
```

This means that you should not import packages without actually using them in your programs. Although this could have been a harmless warning message, your Go program will not get compiled. Bear in mind that similar warnings and error messages are a good indication that you are missing something, and you should try to correct them. You will create a higher quality of code if you treat warnings and errors the same.

# Checking the size of the executable file

So, after successfully compiling hw.go, you might want to check the size of the generated executable file:

```markup
$ ls -l hw
-rwxr-xr-x  1 mtsouk  staff  1628192 Feb  9 22:29 hw
$ file hw
hw: Mach-O 64-bit executable x86_64  
```

Compiling the same Go program on a Linux machine will create the following file:

```markup
$ go versiongo 
go version go1.3.3 linux/amd64
$ go build hw.go
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw
$ file hw
hw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
  
```

To get a better sense of how big the Go executable is, consider that the executable for the same program written in C is about 8432 bytes!

So, you might ask why such a huge executable file for such a small program? The main reason is that Go executable files are statically build, which means that they require no external libraries to run. The use of the strip(1) command can make the generated executable files a little smaller, but do not expect miracles:

```markup
$ strip hw
$ ls -l hw
-rwxr-xr-x  1 mtsouk  staff  1540096 Feb 18 17:41 hw
```

The previous process has nothing to do with Go itself because strip(1) is a Unix command that removes or modifies the symbol table of files and therefore reduces their size. Go can perform the work of the strip(1) command on its own and create smaller executable files, but this method does not always work:

```markup
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1823712 Feb 18 17:35 hw
$ CGO_ENABLED=0 go build -ldflags "-s" -a hw.go
$ ls -l hw
-rwxr-xr-x 1 mtsouk mtsouk 1328032 Feb 18 17:44 hw
$ file hw
hw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
```

The preceding output is from a Linux machine; when the same compilation command is used on a macOS machine, it will make no difference to the size of the executable file.

Just Imagine

# Go environment variables

The go tool can use many Unix shell environment variables dedicated to Go, including GOROOT, GOHOME, GOBIN, and GOPATH. The most important Go environment variable is GOPATH, which specifies the location of your workspace. Usually, this is the only environment variable that you will need to define when developing Go code; it is to do with the way the files of a project will be organized. This means that each project will be organized into three main directories, named src, pkg, and bin. However, many people, including me, prefer not to use GOPATH and manually organize their project files.

So, if you are a big fan of shell variables, you can put all these kinds of definitions in either .bashrc or .profile, which means that these environment variables will be active every time you log in to your Unix machine. If you are not using the Bash shell, which is the default Linux and macOS shell, then you might need to use another start up file. Check out the documentation of your favorite Unix shell to find out which file to use.

The upcoming screenshot shows part of the output of the following command, which displays all the environment variables used by Go:

```markup
$ go help environment
```

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/87508a77-cb59-4e6f-ac23-d4a412f73ebc.png)

The output of the "go help environment" command

You can find additional information about a particular environment variable by executing the next command and replacing NAME with the environment variable that interests you:

```markup
$ go env NAME  
```

All these environment variables have nothing to do with the actual Go code or the execution of the program, but they might affect the development environment; therefore, if you happen to see any strange behavior while trying to compile a Go program, check the environment variables you are using.

Just Imagine

# Using command-line arguments

Command-line arguments allow your programs to get input, such as the names of the files you want to process, without having to write a different version of the program. Hence, you cannot create any useful systems software if you're unable to process the command-line arguments passed to it.

So here is a naive Go program, named cla.go, that prints all its command-line arguments, including the name of the executable file:

```markup
package main 
 
import "fmt" 
import "os" 
 
func main() { 
   arguments := os.Args 
   for i := 0; i < len(arguments); i++ { 
         fmt.Println(arguments[i]) 
   } 
} 
```

As you can see, Go needs an extra package named os in order to read the command-line arguments of a program that are stored in the os.Args array. In case you do not like having multiple import statements, you can rewrite the two import statements as follows, which I find much easier to read:

```markup
import ( 
   "fmt" 
   "os" 
)
```

The gofmt utility puts package names in alphabetical order when you are importing all your packages using a single import block.

The Go code of cla.go is simple as it stores all the command-line arguments in an array and uses a for loop for printing them. As you will see in forthcoming chapters, the os package can do many more things. If you are familiar with C, you should know that in C, command-line arguments are automatically passed to programs, and you do not need to include any extra header files in order to read them. Go uses a different approach that gives you more control but requires slightly more code.

Executing cla.go after building it first will create the following kind of output:

```markup
$ ./cla 1 2 three
./cla
1
2
three
```

# Finding the sum of the command-line arguments

Now, let us try something different and tricky: you are going to try to find the summary of the command-line arguments given to your Go program. Therefore, you are going to consider the command-line arguments as numbers. Although the main idea remains the same, the implementation is totally different because you will have to convert your command-line arguments into numbers. The name of the Go program will be addCLA.go, and it can be split into two parts.

The first part is the preamble of the program:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strconv" 
) 
```

You need the fmt package for printing your output and the os package for reading the command-line arguments. As command-line arguments are stored as strings, you will also need the srtconv package for converting them into integers.

The second part is the implementation of the main() function:

```markup
func main() { 
   arguments := os.Args 
   sum := 0 
   for i := 1; i < len(arguments); i++ { 
         temp, _ := strconv.Atoi(arguments[i]) 
         sum = sum + temp 
   } 
   fmt.Println("Sum:", sum) 
} 
```

The strconv.Atoi() function returns two values: the first one is an integer number, provided that the conversion was successful, and the second one is an error variable.

Note that most Go functions return an error variable, which should always be examined, especially on production software.

If you do not use the strconv.Atoi() function, then you will have two problems:

-   The first one is that the program will try to perform additions, which are mathematical operations, using strings
-   The second one is that you will not be able to tell whether a command-line argument is a valid integer number or not, which can be done by examining the return value of strconv.Atoi()

So, strconv.Atoi() not only does the desired job, but it also tells us whether a given argument is a valid integer or not, which is equally important because it allows us to process inappropriate arguments differently.

The other crucial Go code found in addCLA.go is the one that ignores the value of the error variable from the strconv.Atoi() function using pattern matching. The \_ character means "match everything" in Go pattern matching terms, but do not save it in any variable.

Go has support for four different sizes of signed and unsigned integers, named int8, int16, int32, int64, uint8, uint16, uint32, and uint64, respectively. However, Go also has int and uint, which are the most efficient signed and unsigned integers for your current platform. Therefore, when in doubt, use either int or uint.

Executing addCLA.go with the right kind of command-line arguments creates the following output:

```markup
$ go run addCLA.go 1 2 -1 -3
Sum: -1
$ go run addCLA.go
Sum: 0
```

The good thing is that addCLA.go does not crash if it gets no arguments, without you taking care of it. Nevertheless, it would be more interesting to see how the program handles erroneous input because you can never assume that you are going to get the right type of input:

```markup
$ go run addCLA.go !
Sum: 0
$ go run addCLA.go ! -@
Sum: 0
$ go run addCLA.go ! -@ 1 2
Sum: 3
```

As you can see, if the program gets the wrong type of input, it does not crash and does not include the erroneous input in its calculations. What is a major issue here is that addCLA.go does not print any warning message to let the user know that some of their input was ignored. This kind of dangerous code creates unstable executables that might generate security issues when given the wrong kind of input. So, the general advice here is that you should never expect or rely on the Go compiler, or any other compiler or program, to take care of such things because this is your job.

[](https://subscription.imaginedevops.io/book/programming/9781787125643/3)[Chapter 3](https://subscription.imaginedevops.io/book/programming/9781787125643/3), _Advanced Go Features_, will talk about error handling in Go in more detail and will present a better and safer version of the previous program. For now, we should all be happy that we can prove that our program does not crash with any kind of input.

Although this is not a perfect situation, it is not that bad if you know that your program does not work as expected for some given kinds of input. The bad thing is when the developer has no idea that there exist certain kinds of input that can make a program fail, because you cannot correct what you do not believe or recognize is wrong.

Although processing command-line arguments looks easy, it might get pretty complex if your command-line utility supports a large number of options and parameters. [Chapter 5](https://subscription.imaginedevops.io/book/programming/9781787125643/5), _Files and Directories_, will talk more about processing command-line options, arguments, and parameters using the flag standard Go package.

Just Imagine

# User input and output

According to the Unix philosophy, when a program finishes its job successfully, it generates no output. However, for a number of reasons, not all programs finish successfully and they need to inform the user about their issues by printing appropriate messages. Additionally, some system tools need to get input from the user in order to decide how to handle a situation that might come up.

The hero of Go user input and output is the fmt package, and this section is going to show you how to perform these two tasks by starting with the simplest one.

The best place to learn more about the fmt package is its documentation page, which can be found at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).

# Getting user input

Apart from using command-line arguments to get user input, which is the preferred approach in systems programming, there exist ways to ask the user for input.

Two such examples are the rm(1) and mv(1) commands when used with the \-i option:

```markup
$ touch aFile
$ rm -i aFile
remove aFile? y
$ touch aFile
$ touch ../aFile
$ mv -i ../aFile .
overwrite ./aFile? (y/n [n]) y
```

So, this section will show you how to mimic the previous behavior in your Go code by making your program understand the \-i parameter without actually implementing the functionality of either rm(1) or mv(1).

The simplest function for getting user input is called fmt.Scanln() and reads an entire line. Other functions for getting user input include fmt.Scan(), fmt.Scanf(), fmt.Sscanf(), fmt.Sscanln(), and fmt.Sscan().

However, there exists a more advanced way to get input from the user in Go; it involves the use of the bufio package. Nevertheless, using the bufio package to get a simple response from a user is a bit of an overkill.

The Go code of parameter.go is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strings" 
) 
 
func main() { 
   arguments := os.Args 
   minusI := false 
   for i := 0; i < len(arguments); i++ { 
         if strings.Compare(arguments[i], "-i") == 0 { 
               minusI = true 
               break 
         } 
   } 
 
   if minusI { 
         fmt.Println("Got the -i parameter!") 
         fmt.Print("y/n: ") 
         var answer string 
         fmt.Scanln(&answer) 
         fmt.Println("You entered:", answer) 
   } else { 
         fmt.Println("The -i parameter is not set") 
   } 
} 
```

The presented code is not particularly clever. It just visits all command-line arguments using a for loop and checks whether the current argument is equal to the \-i string. Once it finds a match with the help of the strings.Compare() function, it changes the value of the minusI variable from false to true. Then, as it does not need to look any further, it exits the for loop using a break statement. In case the \-i parameter is given, the block with the if statement asks the user to enter y or n using the fmt.Scanln() function.

Note that the fmt.Scanln() function uses a pointer to the answer variable. Since Go passes its variables by value, we have to use a pointer reference here in order to save the user input to the answer variable. Generally speaking, functions that read data from the user tend to work this way.

Executing parameter.go creates the following kind of output:

```markup
$ go run parameter.go
The -i parameter is not set
$ go run parameter.go -i
Got the -i parameter!
y/n: y
You entered: y
```

# Printing output

The simplest way to print something in Go is using the fmt.Println() and fmt.Printf() functions. The fmt.Printf() function has many similarities with the C printf(3) function. You can also use the fmt.Print() function instead of fmt.Println().

The main difference between fmt.Print() and fmt.Println() is that the latter automatically prints a newline character each time you call it. The biggest difference between fmt.Println() and fmt.Printf() is that the latter requires a format specifier for everything it will print, just like the C printf(3) function. This means that you have better control over what you are doing, but you have to write more code. Go calls these specifiers **verbs**, and you can find out more about supported verbs at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).

Just Imagine

# Go functions

Functions are an important element of every programming language because they allow you to break big programs into smaller and more manageable parts, but they must be as independent of each other as possible and must do one job and only one job. So, if you find yourself writing functions that do multiple things, you may want to consider writing multiple functions instead. However, Go will not refuse to compile functions that are long, complicated, or do multiple things.

A safe indication that you need to create a new function is when you find yourself using the same Go code multiple times in your program. Similarly, a safe indication that you need to put some of your functions in a module is when you find yourself using the same functions all the time in most of your programs.

The single most popular Go function is main(), which can be found in every autonomous Go program. If you look at the definition of the main() function, you'll soon realize that function declarations in Go start with the func keyword.

As a rule of thumb, you must try to write functions that are less than 20-30 lines of Go code. A good side effect of having smaller functions is that they can be optimized more easily because you can clearly find out where the bottleneck is.

# Naming the return values of a Go function

Unlike C, Go allows you to name the return values of a Go function. Additionally, when such a function has a return statement without any arguments, the function automatically returns the current value of each named return value. Note that such functions return their values in the order they were declared in the definition of the function.

Naming return values is a very handy Go feature that can save you from various types of bugs, so use it.

My personal advice is this: name the return values of your functions unless there is a very good reason not to do so.

# Anonymous functions

Anonymous functions can be defined in line, without the need for a name, and they are usually used for implementing things that require a small amount of code. In Go, a function can return an anonymous function or take an anonymous function as one of its arguments. Additionally, anonymous functions can be attached to Go variables.

It is considered a good practice for anonymous functions to have a small implementation and local usage. If an anonymous function does not have local utilization, then you might need to consider making it a regular function.

When an anonymous function is suitable for a job, then it is extremely convenient and makes your life easier; just do not use too many anonymous functions in your programs without a good reason.

# Illustrating Go functions

This subsection will present examples of the previous types of functions using the Go code of the functions.go program. The first part of the program contains the expected preamble and the implementation of the unnamedMinMax() function:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func unnamedMinMax(x, y int) (int, int) { 
   if x > y { 
         min := y 
         max := x 
         return min, max 
   } else { 
         min := x 
         max := y 
         return min, max 
   } 
} 
```

The unnamedMinMax() function is a regular function that gets two integer numbers as input, named x and y, respectively. It returns two integer numbers as output using a return statement.

The next part of functions.go defines another function but this time with named returned values, which are called min and max:

```markup
func minMax(x, y int) (min, max int) { 
   if x > y { 
         min = y 
         max = x 
   } else { 
         min = x 
         max = y 
   } 
   return min, max 
} 
```

The next function is an improved version of minMax() because you do not have to explicitly define the return variables of the return statement:

```markup
func namedMinMax(x, y int) (min, max int) { 
   if x > y { 
         min = y 
         max = x 
   } else { 
         min = x 
         max = y 
   } 
   return 
} 
```

However, you can easily discover which values will be returned by looking at the definition of the namedMinMax() function. The namedMinMax() function will return the current values of min and max, in that order.

The next function shows how to sort two integers without having to use a temporary variable:

```markup
func sort(x, y int) (int, int) { 
   if x > y { 
         return x, y 
   } else { 
         return y, x 
   } 
} 
```

The previous code also shows how handy it is that Go functions can return more than one value. The last part of functions.go contains the main() function; this could be explained in two parts.

The first part is to do with anonymous functions:

```markup
 func main() {
   y := 4 
   square := func(s int) int { 
         return s * s 
   } 
   fmt.Println("The square of", y, "is", square(y)) 
 
   square = func(s int) int { 
         return s + s 
   } 
   fmt.Println("The square of", y, "is", square(y)) 
```

Here, you define two anonymous functions: the first one calculates the square of the given integer whereas the second doubles the given integer number. What is important here is that both of them are assigned to the same variable, which is a totally wrong and is a dangerous practice. Therefore, improper use of anonymous functions can create nasty bugs, so take extra care and do not assign the same variable to different anonymous functions.

Note that even if a function is assigned to a variable, it is still considered an anonymous function.

The second part of main() uses some of the defined functions:

```markup
   fmt.Println(minMax(15, 6)) 
   fmt.Println(namedMinMax(15, 6)) 
   min, max := namedMinMax(12, -1) 
   fmt.Println(min, max) 
} 
```

What is interesting here is that you can get the two returned values of the namedMinMax() function using two variables, all in one statement.

Executing functions.go generates the following output:

```markup
$ go run functions.go
The square of 4 is 16
The square of 4 is 8
6 15
6 15
-1 12
```

The next section shows more examples of anonymous functions combined with the defer keyword.

# The defer keyword

The defer keyword defers the execution of a function until the surrounding function returns, and is widely used in file I/O operations. This is because it saves you from having to remember when to close an open file.

The file with the Go code that illustrates the use of defer is called defer.go and has four main parts.

The first part is the expected preamble as well as the definition of the a1() function:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func a1() { 
   for i := 0; i < 3; i++ { 
         defer fmt.Print(i, " ") 
   } 
} 
```

In the previous example, the defer keyword is used with a simple fmt.Print() statement.

The second part is the definition of the a2() function:

```markup
func a2() { 
   for i := 0; i < 3; i++ { 
         defer func() { fmt.Print(i, " ") }() 
   } 
} 
```

After the defer keyword, there is an anonymous function that is not attached to a variable, which means that after the termination of the for loop, the anonymous function will automatically disappear. The presented anonymous function takes no arguments but uses the i local variable in the fmt.Print() statement.

The next part defines the a3() function and has the following Go code:

```markup
func a3() { 
   for i := 0; i < 3; i++ { 
         defer func(n int) { fmt.Print(n, " ") }(i) 
   } 
} 
```

This time, the anonymous function requires an integer parameter that is named n and takes its value from the i variable.

The last part of defer.go is the implementation of the main() function:

```markup
func main() { 
   a1() 
   fmt.Println() 
   a2() 
   fmt.Println() 
   a3() 
   fmt.Println() 
} 
```

Executing defer.go will print the following, which might surprise you at first:

```markup
$ go run defer.go
2 1 0
3 3 3
2 1 0
```

So, now it is time to explain the output of defer.go by examining the way a1(), a2(), and a3() execute their code. The first line of output verifies that deferred functions are executed in **Last In First Out** (**LIFO**) order after the return of the surrounding function. The for loop in a1() defers a single function call that uses the current value of the i variable. As a result, all numbers are printed in reverse order because the last used value of i is 2. The a2() function is a tricky one because due to defer, the function body is evaluated after the for loop ends while it is still referencing the local i variable, which at that time was equal to 3 for all evaluations of the body. As a result, a2() prints the number 3 three times. Put simply, you have three function calls that use the last value of a variable because this is what is passed to the function. However, this is not the case with the a3() function because the current value of i is passed as an argument to the deferred function, due to the (i) code at the end of the a3() function definition. So, each time the deferred function is executed, it has a different i value to process.

As using defer can be complicated, you should write your own examples and try to guess their output before executing the actual Go code to make sure that your program behaves as expected. Try to be able to tell when the function arguments are evaluated and when the function body is actually executed.

You will see the defer keyword in action again in [Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_.

# Using pointer variables in functions

**Pointers** are memory addresses that offer improved speed in exchange for difficult-to-debug code and nasty bugs. C programmers know more about this. The use of pointer variables in Go functions is illustrated inside the pointers.go file, which can be divided into two main parts. The first part contains the definition of two functions and one new structure named complex:

```markup
func withPointer(x *int) { 
   *x = *x * *x 
} 
 
type complex struct { 
   x, y int 
} 
 
func newComplex(x, y int) *complex { 
   return &complex{x, y} 
} 
```

The second part illustrates the use of the previous definitions in the main() function:

```markup
func main() { 
   x := -2 
   withPointer(&x) 
   fmt.Println(x) 
 
   w := newComplex(4, -5) 
   fmt.Println(*w) 
   fmt.Println(w) 
} 
```

As the withPointer() function uses a pointer variable, you do not need to return any values because any changes to the variable you pass to the function are automatically stored in the passed variable. Note that you need to put & in front of the variable name to pass it as a pointer instead of as a value. The complex structure has two members, named x and y, which are both integer variables.

On the other hand, the newComplex() function returns a pointer to a complex structure, previously defined in pointers.go, which needs to be stored in a variable. In order to print the contents of a complex variable returned by the newComplex() function, you will need to put a \* character in front of it.

Executing pointers.go generates the following output:

```markup
$ go run pointers.go
4
{4 -5}
&{4 -5}
```

I do not recommend the use of pointers to amateur programmers outside of what is required by the libraries you use because they might cause problems. However, as you get more experienced, you might want to experiment with pointers and decide whether you want to use them or not depending on the problem you are trying to solve.

Just Imagine

# Go data structures

Go comes with many handy **data structures** that can help you store your own data, including arrays, slices, and maps. The most important task that you should be able to perform on any data structure is accessing all of its elements in some way. The second important task is having direct access to a specific element once you know its index or key. The last two equally important tasks are inserting elements and deleting elements from data structures. Once you know how to perform these four tasks, you will have complete control over the data structure.

# Arrays

Arrays are the most popular data structure due to their speed and are supported by almost all programming languages. You can declare an array in Go as follows:

```markup
myArray := [4]int{1, 2, 4, -4} 
```

Should you wish to declare an array with two or three dimensions, you can use the following notation:

```markup
twoD := [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} 
threeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} 
```

The index of the first element of each dimension of an array is 0, the index of the second element of each dimension is 1, and so on. Accessing, assigning, or printing a single element from one of the previous three arrays can also be done easily:

```markup
myArray[0] 
twoD[1][2] = 15 
threeD[0][1][1] = -1
```

The most common way to access all the elements of an array is by finding its size using the len() function and then using a for loop. However, there exist cooler ways to visit all the elements of an array that involve the use of the range keyword inside a for loop and allow you to bypass the use of the len() function, which is pretty handy when you have to deal with arrays with two or more dimensions.

All of the code in this subsection is saved as arrays.go, and you should watch it on your own. Running arrays.go creates the following output:

```markup
$ go run arrays.go
1 2 4 -4
0 2 -2 6 7 8
1 2 3 4 5 15 7 8 9
[[1 2] [3 -1]] [[5 6] [7 8]]
```

Now let's try to break things by trying to access some strange array elements, such as an element with an index number that does not exist or an element with a negative index number, using the following Go program that is named breakMe.go:

```markup
package main 
 
import "fmt" 
 
func main() { 
   myArray := [4]int{1, 2, 4, -4} 
   threeD := [2][2][2]int{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}} 
   fmt.Println("myArray[-1]:", myArray[-1])
   fmt.Println("myArray[10]:", myArray[10]) 
   fmt.Println("threeD[-1][20][0]:", threeD[-1][20][0]) 
} 
```

Executing breakMe.go will generate the following output:

```markup
$ go run breakMe.go
# command-line-arguments
./breakMe.go:8: invalid array index -1 (index must be non-negative)
./breakMe.go:9: invalid array index 10 (out of bounds for 4-element array)
./breakMe.go:10: invalid array index -1 (index must be non-negative)
./breakMe.go:10: invalid array index 20 (out of bounds for 2-element array)
```

Go considers compiler issues that can be detected as compiler errors because this helps the development workflow, which is the reason for printing all the out of bounds array access errors of breakMe.go.

Trying to break things is an extremely educational process that you should attempt all the time. Put simply, knowing when something does not work is equally useful to knowing when it works.

Despite their simplicity, Go arrays have many and severe shortcomings:

-   First, once you define an array, you cannot change its size, which means that Go arrays are not dynamic. Put simply, if you want to include an additional element to an existing array that has no space, you will need to create a bigger array and copy all the elements from the old array to the new one.
-   Second, when you pass an array to a function, you actually pass a copy of the array, which means that any changes you make to an array inside a function will be lost after the function finishes.
-   Last, passing a large array to a function can be pretty slow, mostly because Go has to create a second copy of the array. The solution to all these problems is to use slices instead.

# Slices

You'll not find the concept of **slice** in many programming languages, despite the fact that it is both smart and handy. A slice has many similarities with an array, and it allows you to overcome the shortcomings of an array.

Slices have a capacity and length property, which are not always the same. The length of a slice is the same as the length of an array with the same number of elements and can be found using the len() function. The capacity of a slice is the current room that has been allocated for this particular slice and can be found with the cap() function. As slices are dynamic in size, if a slice runs out of room, Go automatically doubles its current length to make room for more elements.

As slices are passed by reference to functions, any modifications you make to a slice inside a function will not be lost after the function ends. Additionally, passing a big slice to a function is significantly faster than passing the same array because Go will not have to make a copy of the slice; it will just pass the memory address of the slice variable.

The code of this subsection is saved in slices.go, and it can be separated into three main parts.

The first part is the preamble as well as the definition of two functions that get slice as input:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func change(x []int) { 
   x[3] = -2 
} 
 
func printSlice(x []int) { 
   for _, number := range x { 
         fmt.Printf("%d ", number) 
   } 
   fmt.Println() 
} 
```

Note that when you use range over a slice, you get a pair of values in its iteration. The first one is the index number and the second one is the value of the element. When you are only interested in the stored element, you can ignore the index number as it happens with the printSlice() function.

The change() function just changes the fourth element of the input slice, whereas printSlice() is a utility function that prints the contents of its slice input variable. Here, you can also see the use of the fmt.Printf() function for printing an integer number.

The second part creates a new slice named aSlice and makes a change to it with the help of the change() function you saw in the first part:

```markup
func main() { 
   aSlice := []int{-1, 4, 5, 0, 7, 9} 
   fmt.Printf("Before change: ") 
   printSlice(aSlice) 
   change(aSlice) 
   fmt.Printf("After change: ") 
   printSlice(aSlice) 
```

Although the way you define a populated slice has some similarities with the way you define an array, the biggest difference is that you do not have to declare the number of elements your slice will have.

The last part illustrates the capacity property of a Go slice as well as the make() function:

```markup
   fmt.Printf("Before. Cap: %d, length: %d\n", cap(aSlice), len(aSlice)) 
   aSlice = append(aSlice, -100) 
   fmt.Printf("After. Cap: %d, length: %d\n", cap(aSlice), len(aSlice)) 
   printSlice(aSlice) 
   anotherSlice := make([]int, 4) 
   fmt.Printf("A new slice with 4 elements: ") 
   printSlice(anotherSlice) 
} 
```

The make() function automatically initializes the elements of a slice to the zero value for that type, which can be verified by the output of the printSlice (anotherSlice) statement. Note that you need to specify the number of elements of a slice when you create it with the make() function.

Executing slices.go generates the following output:

```markup
$ go run slices.go 
Before change: -1 4 5 0 7 9 
After change: -1 4 5 -2 7 9 
Before. Cap: 6, length: 6 
After. Cap: 12, length: 7 
-1 4 5 -2 7 9 -100 
A new slice with 4 elements: 0 0 0 0 
```

As you can see from the third line of the output, the capacity and the length of a slice were the same at the time of its definition. However, after adding a new element to the slice using append(), its length goes from 6 to 7 but its capacity doubles and goes from 6 to 12. The main advantage you get from doubling the capacity of a slice is better performance because Go will not have to allocate memory space all the time.

You can create a slice from the elements of an existing array, and you can copy an existing slice to another one using the copy() function. Both operations have some tricky points, and you should experiment with them.

[](https://subscription.imaginedevops.io/book/programming/9781787125643/6)[Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, will talk about a special type of slice, named byte slice, that can be used in file I/O operations.

# Maps

The Map data type in Go is equivalent to the well-known hash table found in other programming languages. The main advantage of maps is that they can use almost any data type as their index, which in this case is called a **key**. For a data type to be used as a key, it must be comparable.

So, let's take a look at an example Go program, named maps.go, which we will use for illustrative purposes. The first part of maps.go contains the preamble Go code you would expect:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
func main() { 
 
```

Then, you can define a new empty map that has strings as its keys and integer numbers as values, as follows:

```markup
   aMap := make(map[string]int) 
```

Post this, you can add new key and value pairs to the aMap map, as follows:

```markup
   aMap["Mon"] = 0 
   aMap["Tue"] = 1 
   aMap["Wed"] = 2 
   aMap["Thu"] = 3 
   aMap["Fri"] = 4 
   aMap["Sat"] = 5 
   aMap["Sun"] = 6 
```

Then, you can get the value of an existing key:

```markup
   fmt.Printf("Sunday is the %dth day of the week.\n", aMap["Sun"]) 
 
```

However, the single most important operation you can perform on an existing map is illustrated in the following Go code:

```markup
   _, ok := aMap["Tuesday"] 
   if ok { 
         fmt.Printf("The Tuesday key exists!\n") 
   } else { 
         fmt.Printf("The Tuesday key does not exist!\n") 
   } 
```

What the aforementioned Go code does is use the error-handling capabilities of Go in order to verify that a key of a map already exists before you try to get its value. This is the proper and safe way of trying to get the value of a map key because asking for a value for which there is no key will result in returning zero. This gives you no way of determining whether the result was zero because the key you requested was not there or because the element with the corresponding key actually had the zero value.

The following Go code shows how you can iterate over all the keys of an existing map:

```markup
   count := 0 
   for key, _ := range aMap { 
         count++ 
         fmt.Printf("%s ", key) 
   } 
   fmt.Printf("\n") 
   fmt.Printf("The aMap has %d elements\n", count) 
```

If you have no interest in visiting the keys and the values of a map and you just want to count its pairs, then you can use the next, much simpler variation of the previous for loop:

```markup
   count = 0 
   delete(aMap, "Fri") 
   for _, _ = range aMap { 
         count++ 
   } 
   fmt.Printf("The aMap has now %d elements\n", count) 
```

The last part of the main() function contains the following Go code that illustrates an alternative way of defining and initializing a map at the same time:

```markup
   anotherMap := map[string]int{ 
         "One":   1, 
         "Two":   2, 
         "Three": 3, 
         "Four":  4, 
   }    anotherMap["Five"] = 5 
   count = 0 
   for _, _ = range anotherMap { 
         count++ 
   } 
   fmt.Printf("anotherMap has %d elements\n", count) 
} 
```

However, apart from the different initialization, all the other map operations work exactly the same. Executing maps.go generates the following output:

```markup
$ go run maps.go
Sunday is the 6th day of the week.
The Tuesday key does not exist!
Wed Thu Fri Sat Sun Mon Tue
The aMap has 7 elements
The aMap has now 6 elements
anotherMap has 5 elements
```

Maps are a very handy data structure, and there is a big chance that you are going to need them when developing systems software.

# Converting an array into a map

This subsection will perform a practical operation, which is converting an array into a map without knowing the size of array in advance. The Go code of array2map.go can be divided into three main parts. The first part is the standard Go code that includes the required packages and the beginning of the main() function:

```markup
package main 
 
import ( 
   "fmt" 
   "strconv" 
) 
 
func main() { 
```

The second part, which implements the core functionality, is as follows:

```markup
anArray := [4]int{1, -2, 14, 0} 
aMap := make(map[string]int) 
 
length := len(anArray) 
for i := 0; i < length; i++ { 
   fmt.Printf("%s ", strconv.Itoa(i)) 
   aMap[strconv.Itoa(i)] = anArray[i] 
} 
```

You first define the array variable and the map variable you will use. The for loop is used for visiting all the array elements and adding them to map. The strconv.Itoa() function converts the index number of array into a string.

Bear in mind that if you know that all the keys of a map will be consecutive positive integer numbers, you might consider using an array or a slice instead of a map. In fact, even if the keys are not consecutive, arrays and slices are cheaper data structures than maps, so you might end up with a sparse matrix.

The last part, which is just for printing the contents of the generated map, uses the expected range form of the for loop:

```markup
for key, value := range aMap {    fmt.Printf("%s: %d\n", key, value) 
   } 
} 
```

As you can easily guess, developing the inverse operation is not always possible because map is a richer data structure than array. However, the price you pay for a more powerful data structure is time because array operations are usually faster.

# Structures

Although arrays, slices, and maps are all very useful, they cannot hold multiple values in the same place. When you need to group various types of variables and create a new handy type, you can use a structure--the various elements of a structure are called fields.

The code of this subsection is saved as dataStructures.go and can be divided into three parts. The first part contains the preamble and the definition of a new structure named message:

```markup
package main 
 
import ( 
   "fmt" 
   "reflect" 
) 
 
func main() { 
 
   type message struct {
         X     int 
         Y     int 
         Label string 
   } 
```

The message structure has three fields, named X, Y, and Label. Note that structures are usually defined at the beginning of a program and outside the main() function.

The second part uses the message structure to define two new message variables, named p1 and p2. Then, it uses reflection to get information about the p1 and p2 variables of the message structure:

```markup
   p1 := message{23, 12, "A Message"} 
   p2 := message{} 
   p2.Label = "Message 2" 
 
   s1 := reflect.ValueOf(&p1).Elem() 
   s2 := reflect.ValueOf(&p2).Elem() 
   fmt.Println("S2= ", s2) 
```

The last part shows how to print all the fields of a structure without knowing their names using a for loop and the Type() function:

```markup
   typeOfT := s1.Type() 
   fmt.Println("P1=", p1) 
   fmt.Println("P2=", p2) 
 
   for i := 0; i < s1.NumField(); i++ {         f := s1.Field(i)         fmt.Printf("%d: %s ", i, typeOfT.Field(i).Name) 
         fmt.Printf("%s = %v\n", f.Type(), f.Interface()) 
   } 
 
} 
```

Running dataStructures.go will generate the following kind of output:

```markup
$ go run dataStructures.go
S2=  {0 0 Message 2}
P1= {23 12 A Message}
P2= {0 0 Message 2}
0: X int = 23
1: Y int = 12
2: Label string = A Message
```

If the name of a field of a struct definition begins with a lowercase letter (x instead of X), the previous program will fail with the following error message:

```markup
panic: reflect.Value.Interface: cannot return value obtained from unexported field or method
  
```

This happens because lowercase fields do not get exported; therefore, they cannot be used by the reflect.Value.Interface() method. You will learn more about reflection in the next chapter.

Just Imagine

# Interfaces

Interfaces are an advanced Go feature, which means that you might not want to use them in your programs if you are not feeling very comfortable with Go. However, interfaces can be very practical when developing big Go programs, which is the main reason for talking about interfaces in this book.

But first, I will talk about methods, which are functions with a special receiver argument. You declare methods as ordinary functions with an additional parameter that appears just before the function name. This particular parameter connects the function to the type of that extra parameter. As a result, that parameter is called the receiver of the method. You will see such functions in a while.

Put simply, interfaces are abstract types that define a set of functions that need to be implemented so that a type can be considered an instance of the interface. When this happens, we say that the type satisfies this interface. So, an interface is two things--a set of methods and a type--and it is used for defining the behavior of a type.

Let's describe the main advantage of interfaces with an example. ImagineDevOps  that you have a type named ATYPE and an interface for the ATYPE type. Any function that accepts an ATYPE variable can accept any other variable that implements the interface of ATYPE.

The Go code of interfaces.go can be divided into three parts. The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
type coordinates interface { 
   xaxis() int 
   yaxis() int 
} 
 
type point2D struct { 
   X int 
   Y int 
} 
```

In this part, you define an interface called coordinates and a new structure called point2D. The interface has two functions, named xaxis() and yaxis(). The definition of the coordinates interface says that if you want to convert to the coordinates interface, you will have to implement these two functions.

It is important to notice that the interface does not state any other specific types apart from the interface itself. On the other hand, the two functions of the interface should state the types of their return values.

The second part has the following Go code:

```markup
func (s point2D) xaxis() int { 
   return s.X 
} 
 
func (s point2D) yaxis() int { 
   return s.Y 
} 
 
func findCoordinates(a coordinates) { 
   fmt.Println("X:", a.xaxis(), "Y:", a.yaxis()) 
} 
 
type coordinate int 
 
func (s coordinate) xaxis() int { 
   return int(s) 
} 
 
func (s coordinate) yaxis() int { 
   return 0 
} 
```

In the second part, you first implement the two functions of the coordinates interface for the point2D type. Then you develop a function named findCoordinates() that accepts a variable that implements the coordinates interface. The findCoordinates() function just prints the two coordinates of a point using a simple fmt.Println() function call. Then, you define a new type named coordinate that is used for points that belong to the _x_\-axis. Last, you implement the coordinates interface for the coordinate type.

At the time of writing the code for interfaces.go, I believed that the coordinates and coordinate names were fine. After writing the previous paragraph, I realized that the coordinate type could have been renamed to xpoint for better readability. I left the names coordinates and coordinate to point out that everybody makes mistakes and that the variable and type names you are using must be chosen wisely.

The last part has the following Go code:

```markup
func main() { 
 
   x := point2D{X: -1, Y: 12}
   fmt.Println(x) 
   findCoordinates(x) 
 
   y := coordinate(10) 
   findCoordinates(y) 
} 
```

In this part, you first create a point2D variable and print its coordinates using the findCoordinates() function, then you create a coordinate variable named y that holds a single coordinate value. Lastly, you print the y variable using the same findCoordinates() function used for printing a point2D variable.

Although Go is not an object-oriented programming language, I will use some object-oriented terminology here. So, in object-oriented terminology, this means that both point2D and coordinate types are coordinate objects. However, none of them are _only_ a coordinate object.

Executing interfaces.go creates the following output:

```markup
$ go run interfaces.go
{-1 12}
X: -1 Y: 12
X: 10 Y: 0
```

I believe that Go interfaces are not necessary when developing systems software, but they are a handy Go feature that can make the development of a systems application more readable and simpler, so do not hesitate to use them.

Just Imagine

# Creating random numbers

As a practical programming example, this section will talk about creating random numbers in Go. Random numbers have many uses, including the generation of good passwords as well as the creation of files with random data that can be used for testing other applications. However, bear in mind that usually programming languages generate pseudorandom numbers that approximate the properties of a true random number generator.

Go uses the math/rand package for generating random numbers and needs a seed to start producing random numbers. The seed is used for initializing the entire process and is extremely important because if you always start with the same seed, you will always get the same sequence of random numbers.

The random.go program has three main parts. The first part is the preamble of the program:

```markup
package main 
 
import ( 
   "fmt" 
   "math/rand" 
   "os" 
   "strconv" 
   "time" 
) 
```

The second part is the definition of the random() function that returns a random number each time it is called, using the rand.Intn() Go function:

```markup
func random(min, max int) int { 
   return rand.Intn(max-min) + min 
} 
```

The two parameters of the random() function define the lower and upper limits of the generated random number. The last part of random.go is the implementation of the main() function that is mainly used for calling the random() function:

```markup
func main() { 
   MIN := 0 
   MAX := 0 
   TOTAL := 0 
   if len(os.Args) > 3 { 
         MIN, _ = strconv.Atoi(os.Args[1]) 
         MAX, _ = strconv.Atoi(os.Args[2]) 
         TOTAL, _ = strconv.Atoi(os.Args[3]) 
   } else { 
         fmt.Println("Usage:", os.Args[0], "MIX MAX TOTAL") 
         os.Exit(-1) 
   } 
 
   rand.Seed(time.Now().Unix()) 
   for i := 0; i < TOTAL; i++ { 
         myrand := random(MIN, MAX) 
         fmt.Print(myrand) 
         fmt.Print(" ") 
   } 
   fmt.Println() 
} 
```

A big part of the main() function involves dealing with the reading of command-line arguments as integer numbers and printing a descriptive error message in case you did not get the correct number of command-line arguments. This is the standard practice that we will follow in this book. The random.go program uses the Unix epoch time as the seed for the random number generator by calling the time.Now().Unix() function. The important thing to remember is that you do not have to call rand.Seed() multiple times. Lastly, random.go does not examine the error variable returned by strconv.Atoi() to save book space, not because it is not necessary.

Executing random.go generates the following kind of output:

```markup
$ go run random.go 12 32 20
29 27 20 23 22 28 13 16 22 26 12 29 22 30 15 19 26 24 20 29
  
```

Should you wish to generate more secure random numbers in Go, you should use the crypto/rand package, which implements a cryptographically secure pseudorandom number generator. You can find more information about the crypto/rand package by visiting its documentation page at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).

If you are really into random numbers, then the definitive reference to the theory of random numbers is the second volume of _The Art of Computer Programming_ by Donald Knuth.

Just Imagine

# Exercises

1.  Browse the Go documentation site: [https://golang.org/doc/](https://golang.org/doc/).[](https://golang.org/doc/)
2.  Write a Go program that keeps reading integers until you give the number 0 as input, then it prints the minimum and maximum integer in the input.
3.  Write the same Go program as before, but this time, you will get your input using command-line arguments. Which version do you think is better? Why?
4.  Write a Go program that supports two command-line options (\-i and \-k) in random order using if statements. Now change your program to support three command-line arguments. As you will see, the complexity of the latter program is just too much to handle using if statements.
5.  If the indices of a map were natural numbers, are there any cases that it would be wise and efficient to use a map instead of an array?
6.  Try to put the functionality of array2map.go into a separate function.
7.  Try to develop your own random number generator in Go that will still use the current time as a seed but not the math/rand package.
8.  Learn how to create a slice from an existing array. What happens when you make changes to the slice?
9.  Use the copy() function to make a copy of an existing slice. What happens when the destination slice is smaller than the source slice? What happens when the destination slice is bigger than the source slice?
10.  Try to write an interface for supporting points in 3D space. Then, use this interface to support points that reside on the x-axis.

Just Imagine

# Summary

You learned many things in this chapter, including getting user input and processing command-line arguments. You familiarized yourself with the basic Go structures and you created a Go program that generates random numbers. Try to do the offered exercises and do not get discouraged if you fail in some of them.

The next chapter will talk about many advanced Go features, including error handling, pattern matching, regular expressions, reflection, unsafe code, calling C code from Go, and the strace(1) command-line utility. I will compare Go with other programming languages and give you practical advice in order to avoid some common Go pitfalls.



# Advanced Go Features

In the previous chapter, you learned how to compile Go code, how to get input from the user and print the output on the screen, how to create your own Go functions, the data structures that Go supports, and how to process command-line arguments.

This chapter will discuss many fascinating things, so you better prepare yourselves for lots of interesting and practical Go code that will help you perform many different yet really important tasks, starting with error handling and ending with how to avoid some common Go mistakes. If you are familiar with Go, you can skip what you already know, but please do not skip the proposed exercises.

So, this chapter will talk about some advanced Go features, including:

-   Error handling
-   Error logging
-   Pattern matching and regular expressions
-   Reflection
-   How to use the strace(1) and dtrace(1) tools to watch the system calls of Go executable files
-   How to detect unreachable Go code
-   How to avoid various common Go mistakes

Just Imagine

# Error handling in Go

Errors happen all the time, so it is our job to both catch and handle them, especially when writing code that deals with sensitive system information and files. The good news is that Go has a special data type called error that helps signify erroneous states; if an error variable has a nil value, then there is no error situation.

As you saw in the addCLA.go program that was developed in the previous chapter, you can ignore the error variable that is returned by most Go functions using the \_ character:

```markup
temp, _ := strconv.Atoi(arguments[i]) 
```

However, this is not considered good practice and should be avoided, especially on systems software and other kinds of critical software, such as server processes.

As you will see in [Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, even **End of File** (**EOF**) is a type of error that is returned when there is nothing left to read from a file. As EOF is defined in the io package, you can handle it as follows:

```markup
if err == io.EOF { 
    // Do something 
} 
```

However, the most important task to learn is how to develop functions that return error variables and how to handle them, which is explained next.

# Functions can return error variables

Go functions can return error variables, which means that an error condition can be handled inside a function, outside of a function, or both inside and outside the function; the latter situation does not happen very often. So, this subsection will develop a function that returns error messages. The relevant Go code can be found in funErr.go and will be presented in three parts.

The first part contains the following Go code:

```markup
package main 
 
import ( 
   "errors" 
   "fmt" 
   "log" 
) 
 
func division(x, y int) (int, error, error) { 
   if y == 0 { 
         return 0, nil, errors.New("Cannot divide by zero!") 
   } 
   if x%y != 0 { 
         remainder := errors.New("There is a remainder!") 
         return x / y, remainder, nil 
   } else { 
         return x / y, nil, nil 
   } 
 
} 
```

Apart from the expected preamble, the preceding code defines a new function named division(), which returns an integer and two error variables. If you remember from your Math classes, when you divide two integer numbers, the division operation is not always perfect, which means that you might get a remainder that is not zero. The errors.New() function from the errors Go package that you see in funErr.go creates a new error variable, using the provided string as the error message.

The second part of funErr.go has the following Go code:

```markup
func main() { 
   result, rem, err := division(2, 2) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
```

It is a very common Go practice to compare an error variable with nil to quickly find out whether there is an error condition or not.

The last part of funErr.go is as follows:

```markup
   result, rem, err = division(12, 5) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
 
   result, rem, err = division(2, 0) 
   if err != nil { 
         log.Fatal(err) 
   } else { 
         fmt.Println("The result is", result) 
   } 
 
   if rem != nil { 
         fmt.Println(rem) 
   } 
} 
```

This part showcases two erroneous conditions. The first one is an integer division that has a remainder, whereas the second one is an invalid division because you cannot divide a number by zero. As the name log.Fatal() implies, this logging function should be used for critical errors only because when called, it automatically terminates your program. However, as you will see in the next subsection, there exist other, more gentle, ways to log your error messages.

Executing funErr.go generates the next output:

```markup
$ go run funErr.go
The result is 1
The result is 2
There is a remainder!
2017/03/07 07:39:19 Cannot divide by zero!
exit status 1
```

The last line is automatically generated by the log.Fatal() function, just before terminating the program. It is important to understand that any Go code after the call to log.Fatal() will not be executed.

# About error logging

Go offers functions that can help you log your error messages in various ways. You already saw log.Fatal() in funErr.go, which is a somewhat cruel way to deal with simple errors. Put simply, you should have a very good reason to use log.Fatal() in your code. Generally speaking, log.Fatal() should be used instead of the os.Exit() function because it allows you to print an error message and exit your program using just one function call.

Go offers additional error logging functions in the log standard package that behave more gently depending on the situation, which includes log.Printf(), log.Print(), log.Println(), log.Fatalf(), log.Fatalln(), log.Panic(), log.Panicln(), and log.Panicf(). Please note that logging functions can be handy for debugging purposes so do not underestimate their power.

The logging.go program illustrates two of the mentioned logging functions using the following Go code:

```markup
package main 
 
import ( 
   "log" 
) 
 
func main() { 
   x := 1 
   log.Printf("log.Print() function: %d", x) 
   x = x + 1 
   log.Printf("log.Print() function: %d", x) 
   x = x + 1 
   log.Panicf("log.Panicf() function: %d", x) 
   x = x + 1 
   log.Printf("log.Print() function: %d", x) 
} 
```

As you can see, logging.go does not need the fmt package because it has its own functions for printing the output. Executing logging.go will produce the following output:

```markup
$ go run logging.go
2017/03/10 16:51:56 log.Print() function: 1
2017/03/10 16:51:56 log.Print() function: 2
2017/03/10 16:51:56 log.Panicf() function: 3
panic: log.Panicf() function: 3
    
goroutine 1 [running]:
log.Panicf(0x10b78d0, 0x19, 0xc42003df48, 0x1, 0x1)
      /usr/local/Cellar/go/1.8/libexec/src/log/log.go:329 +0xda
main.main()
      /Users/mtsouk/ch3/code/logging.go:14 +0x1af
exit status 2
```

Although the log.Printf() function works in the same way as fmt.Printf(), it automatically prints the date and time the log message was printed, just like the log.Fatal() function did in funErr.go. Additionally, the log.Panicf() function works in a similar way to log.Fatal()\--they both terminate the current program. However, log.Panicf() prints some additional information, useful for debugging purposes.

Go also offers the log/syslog package that is a simple interface to the system log service running on your Unix machine. [](https://subscription.imaginedevops.io/book/programming/9781787125643/7)[Chapter 7](https://subscription.imaginedevops.io/book/programming/9781787125643/7), _Working with System Files_, will talk more about the log/syslog package.

# The addCLA.go program revisited

This subsection will present an improved version of the addCLA.go program we developed in the previous chapter, to make it able to handle any kind of user input. The new program will be called addCLAImproved.go, but instead of presenting its full Go code, you will only see the differences between addCLAImproved.go and addCLA.go using the diff(1) command-line utility:

```markup
$ diff addCLAImproved.go addCLA.go
13,18c13,14
<           temp, err := strconv.Atoi(arguments[i])
<           if err == nil {
<                 sum = sum + temp
<           } else {
<                 fmt.Println("Ignoring", arguments[i])
<           }
---
>           temp, _ := strconv.Atoi(arguments[i])
>           sum = sum + temp
```

What this output basically tells us is that the last two lines of code, which can be found in addCLA.go and begin with the \> character, were replaced by the lines of code that begin with the < character in addCLAImproved.go. The remaining code of both files is exactly the same.

The diff(1) utility compares text files line by line and is a handy way of spotting code differences between different versions of the same file.

Executing addCLAImproved.go will generate the following kind of output:

```markup
$ go run addCLAImproved.go
Sum: 0
$ go run addCLAImproved.go 1 2 -3
Sum: 0
$ go run addCLAImproved.go 1 a 2 b 3.2 @
Ignoring a
Ignoring b
Ignoring 3.2
Ignoring @
Sum: 3
```

So, the new and improved version works as expected, behaves reliably, and allows us to differentiate between valid and invalid input.

Just Imagine

# Pattern matching and regular expressions

**Pattern matching**, which plays a key role in Go, is a technique for searching a string for a set of characters based on a specific search pattern that is based on **regular expressions**. If pattern matching is successful, it allows you to extract the desired data from the string or replace or delete it. **Grammar** is a set of production rules for strings in a formal language. The production rules describe how to create strings from the alphabet of the language that are valid according to the syntax of the language. Grammar does not describe the meaning of a string or what can be done with it in whatever context, only its form. What is important is to realize that grammar is at the heart of regular expressions because without it, you cannot define or use a regular expression.

Regular expressions and pattern matching are not a panacea, so you should not try to solve every problem using regular expressions since they are not suitable for every kind of problem you may come up against. Furthermore, they might introduce unnecessary complexity to your software.

The Go package responsible for the pattern matching capabilities of Go is called regexp, which you can see in action in regExp.go. The code of regExp.go will be presented in four parts.

The first part is the expected preamble:

```markup
package main 
 
import ( 
   "fmt" 
   "regexp" 
) 
```

The second part is as follows:

```markup
func main() { 
match, _ := regexp.MatchString("Mihalis", "Mihalis Tsoukalos") 
   fmt.Println(match) 
   match, _ = regexp.MatchString("Tsoukalos", "Mihalis tsoukalos") 
   fmt.Println(match) 
```

Both calls to regexp.MatchString() try to find a static string, which is the first parameter, in a given string, which is the second parameter.

The third part contains a single, yet crucial, line of Go code:

```markup
   parse, err := regexp.Compile("[Mm]ihalis") 
```

The regexp.Compile() function reads the provided regular expression and tries to parse it. If the parsing of the regular expressing is successful, then regexp.Compile() returns a value of the regexp.Regexp variable type that you can use afterward. The \[Mm\] expression in the regexp.Compile() function means that what you are looking for can begin with an uppercase M or a lowercase m. Both \[ and \] are special characters that are not part of the regular expression. So, the provided grammar is naive and only matches the words Mihalis and mihalis.

The last part uses the previous regular expression that is stored in the parse variable:

```markup
   if err != nil { 
         fmt.Printf("Error compiling RE: %s\n", err) 
   } else { 
         fmt.Println(parse.MatchString("Mihalis Tsoukalos")) 
         fmt.Println(parse.MatchString("mihalis Tsoukalos")) 
         fmt.Println(parse.MatchString("M ihalis Tsoukalos")) 
         fmt.Println(parse.ReplaceAllString("mihalis Mihalis", "MIHALIS")) 
   } 
} 
```

Running regExp.go generates the next output:

```markup
$ go run regExp.go
true
false
true
true
false
MIHALIS MIHALIS
```

So, the first call to regexp.MatchString() was a match, but the second was not because pattern matching is case-sensitive and Tsoukalos does not match tsoukalos. The parse.ReplaceAllString() function at the end searches the string that is given as an input ("mihalis Mihalis") and replaces each match with the string that is given as its second parameter ("MIHALIS").

The rest of this section will present various examples using static text because you do not know how to read text files yet. However, as the static text will be stored in an array and processed line by line, the presented code can be easily modified to support getting your input from external text files.

# Printing all the values from a given column of a line

This is a very common scenario, as you often will need to get all the data from a given column of a structured text file in order to analyze it afterward. The code of readColumn.go, which prints values in the third column, will be presented in two parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "strings" 
) 
 
func main() { 
   var s [3]string 
   s[0] = "1 2 3" 
   s[1] = "11 12 13 14 15 16" 
   s[2] = "-1 2 -3 -4 -5 6" 
```

Here, you import the required Go packages and define a string with three lines using an array with three elements.

The second part contains the following Go code:

```markup
   column := 2 
 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         if len(data) >= column { 
               fmt.Println((data[column-1])) 
         } 
   } 
} 
```

First, you define the column that interests you. Then, you start iterating over the strings stored in the array. This is similar to reading a text file line by line. The Go code inside the for loop splits the fields of the input line, stores them in the data array, verifies that the value from the desired column is present, and prints it on your screen. All of the hard work is done by the handy strings.Fields() function that splits a string based on whitespace characters, as defined in unicode.IsSpace(), and returns a slice of strings. Although readColumn.go does not use the regexp.Compile() function, the logic behind its implementation with the use of strings.Fields() is still based on the principles of regular expressions.

An important thing to remember is that you should never trust your data. Put simply, always verify that the data you expect to grab is there.

Executing readColumn.go will generate the following kind of output:

```markup
$ go run readColumn.go
2
12
2
```

[](https://subscription.imaginedevops.io/book/programming/9781787125643/6)[Chapter 6](https://subscription.imaginedevops.io/book/programming/9781787125643/6), _File Input and Output_, will show an improved version of readColumn.go that you can use as a starting point in case you want to modify the rest of the examples shown.

# Creating summaries

In this section, we will develop a program that adds all the values of a given column of text with multiple lines. To make things even more interesting, the column number will be given as a parameter in the program. The main difference between the program of this subsection and readColumn.go from the previous subsection is that you will need to convert each value into an integer number.

The name of the program that will be developed is summary.go and can be divided into three parts.

The first part is this:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "strconv" 
   "strings" 
) 
 
func main() { 
   var s [3]string 
   s[0] = "1 b 3" 
   s[1] = "11 a 1 14 1 1" 
   s[2] = "-1 2 -3 -4 -5" 
```

The second part has the following Go code:

```markup
   arguments := os.Args 
   column, err := strconv.Atoi(arguments[1]) 
   if err != nil { 
         fmt.Println("Error reading argument") 
         os.Exit(-1) 
   } 
   if column == 0 { 
         fmt.Println("Invalid column") 
         os.Exit(1) 
   } 
```

The previous code reads the index of the column that interests you. If you want to make summary.go even better, you can check for negative values in the column variable and print the appropriate error message.

The last part of summary.go is as follows:

```markup
   sum := 0 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         if len(data) >= column { 
               temp, err := strconv.Atoi(data[column-1]) 
               if err == nil { 
                     sum = sum + temp 
               } else { 
                     fmt.Printf("Invalid argument: %s\n", data[column-1]) 
               } 
         } else { 
               fmt.Println("Invalid column!") 
         } 
   } 
   fmt.Printf("Sum: %d\n", sum) 
} 
```

As you can see, most of the Go code in summary.go is about dealing with exceptions and potential errors. The core functionality of summary.go is implemented in a few lines of Go code.

Executing summary.go will give you the following output:

```markup
$ go run summary.go 0
Invalid column
exit status 1
$ go run summary.go 2
Invalid argument: b
Invalid argument: a
Sum: 2
$ go run summary.go 1
Sum: 11
```

# Finding the number of occurrences

A very common programming problem is finding out the number of times an IP address appears in a log file. So, the example in this subsection will show you how to do this using a handy map structure. The occurrences.go program will be presented in three parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "strings" 
) 
 
func main() { 
 
   var s [3]string 
   s[0] = "1 b 3 1 a a b" 
   s[1] = "11 a 1 1 1 1 a a" 
   s[2] = "-1 b 1 -4 a 1" 
```

The second part is as follows:

```markup
   counts := make(map[string]int) 
 
   for i := 0; i < len(s); i++ { 
         data := strings.Fields(s[i]) 
         for _, word := range data { 
               _, ok := counts[word] 
               if ok { 
                     counts[word] = counts[word] + 1 
               } else { 
                     counts[word] = 1 
               } 
         } 
   } 
```

Here, we use the knowledge from the previous chapter to create a map named counts and populate it with the desired data using two for loops.

The last part is pretty small as it just prints the contents of the counts map:

```markup
   for key, _ := range counts { 
         fmt.Printf("%s -> %d \n", key, counts[key]) 
   } 
} 
```

Executing occurrences.go and using the sort(1) command-line utility to sort the output of occurrences.go will generate the following kind of output:

```markup
$ go run occurrences.go | sort -n -r -t\  -k3,3
1 -> 8
a -> 6
b -> 3
3 -> 1
11 -> 1
-4 -> 1
-1 -> 1
```

As you can see, traditional Unix tools are still useful.

# Find and replace

The example in this subsection will search the provided text for two variations of a given string and replace it with another string. The program will be named findReplace.go and will actually use Go regular expressions. The main reason for using the regexp.Compile() function, in this case, is that it greatly simplifies things and allows you to access your text only once.

The first part of the findReplace.go program is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "os" 
   "regexp" 
) 
```

The next part is as follows:

```markup
func main() { 
 
   var s [3]string 
   s[0] = "1 b 3" 
   s[1] = "11 a B 14 1 1" 
   s[2] = "b 2 -3 B -5" 
 
   parse, err := regexp.Compile("[bB]") 
 
   if err != nil { 
         fmt.Printf("Error compiling RE: %s\n", err) 
         os.Exit(-1) 
   } 
```

The previous Go code will find every occurrence of an uppercase B or a lowercase b (\[bB\]). Note that there is also regexp.MustCompile() that works like regexp.Compile(). However, regexp.MustCompile() does not return an error variable; it just panics if the given expression is erroneous and cannot be parsed. As a result, regexp.Compile() is a better choice.

The last part is as follows:

```markup
   for i := 0; i < len(s); i++ { 
         temp := parse.ReplaceAllString(s[i], "C") 
         fmt.Println(temp) 
   } 
} 
```

Here you replace each match with an uppercase C using parse.ReplaceAllString().

Executing findReplace.go generates the expected output:

```markup
$ go run findReplace.go
1 C 3
11 a C 14 1 1
C 2 -3 C -5
```

The awk(1) and sed(1) command-line tools can do most of the previous tasks more easily, but sed(1) and awk(1) are not general-purpose programming languages.

Just Imagine

# Reflection

Reflection is an advanced Go feature that allows you to dynamically learn the type of an arbitrary object as well as information about its structure. You should recall that the dataStructures.go program from [Chapter 2](https://subscription.imaginedevops.io/book/programming/9781787125643/2), _Writing Programs in Go_, used reflection to find out the fields of a data structure as well as the type of each fields. All of this happened with the help of the reflect Go package and the reflect.TypeOf() function that returns a Type variable.

Reflection is illustrated in the reflection.go Go program that will be presented in four parts.

The first one is the preamble of the Go program and has the following code:

```markup
package main 
 
import ( 
   "fmt" 
   "reflect" 
) 
```

The second part is as follows:

```markup
func main() { 
 
   type t1 int 
   type t2 int 
 
   x1 := t1(1) 
   x2 := t2(1) 
   x3 := 1 
```

Here, you create two new types, named t1 and t2, that are both int and three variables, named x1, x2, and x3.

The third part has the following Go code:

```markup
   st1 := reflect.ValueOf(&x1).Elem() 
   st2 := reflect.ValueOf(&x2).Elem() 
   st3 := reflect.ValueOf(&x3).Elem() 
 
   typeOfX1 := st1.Type() 
   typeOfX2 := st2.Type() 
   typeOfX3 := st3.Type() 
 
   fmt.Printf("X1 Type: %s\n", typeOfX1) 
   fmt.Printf("X2 Type: %s\n", typeOfX2) 
   fmt.Printf("X3 Type: %s\n", typeOfX3) 
```

Here, you find the type of the x1, x2, and x3 variables using reflect.ValueOf() and Type().

The last part of reflection.go deals with a struct variable:

```markup
   type aStructure struct { 
         X    uint 
         Y    float64 
         Text string 
   } 
 
   x4 := aStructure{123, 3.14, "A Structure"} 
   st4 := reflect.ValueOf(&x4).Elem() 
   typeOfX4 := st4.Type() 
 
   fmt.Printf("X4 Type: %s\n", typeOfX4) 
   fmt.Printf("The fields of %s are:\n", typeOfX4) 
 
   for i := 0; i < st4.NumField(); i++ { 
         fmt.Printf("%d: Field name: %s ", i, typeOfX4.Field(i).Name) 
         fmt.Printf("Type: %s ", st4.Field(i).Type()) 
         fmt.Printf("and Value: %v\n", st4.Field(i).Interface()) 
   } 
} 
```

There exist some laws that govern reflection in Go, but talking about them is beyond the scope of this book. What you should remember is that your programs can examine their own structure using reflection, which is a very powerful capability.

Executing reflection.go prints the following output:

```markup
$ go run reflection.go
X1 Type: main.t1
X2 Type: main.t2
X3 Type: int
X4 Type: main.aStructure
The fields of main.aStructure are:
0: Field name: X Type: uint and Value: 123
1: Field name: Y Type: float64 and Value: 3.14
2: Field name: Text Type: string and Value: A Structure
```

The first two lines of the output show that Go does not consider the types t1 and t2 as equal, even though both t1 and t2 are aliases of the int type.

Old habits die hard!

Despite the fact that Go tries to be a safe programming language, sometimes it is forced to forget about safety and allows the programmer to do whatever he/she wants.

# Calling C code from Go

Go allows you to call C code because there are times when the only way to perform some tasks, such as communicating with a hardware device or a database server, is by using C. Nevertheless, if you find yourself using this capability many times in the same project, you might need to reconsider your approach and your choice of programming language.

Talking more about this capability in Go is beyond the scope of this book. What you should remember is that most likely, you will never need to call C code from your Go program. Nevertheless, should you wish to explore this Go feature, you can start by visiting the documentation of the cgo tool at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/) as well as by looking at the code found at [https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go](https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go).

# Unsafe code

Unsafe code is Go code that bypasses the type safety and memory security of Go and requires the use of the unsafe package. You will most likely never need to use unsafe code in your Go programs but if for some strange reason you ever need to, it will probably have to do with pointers.

Using unsafe code can be dangerous for your programs, so only use it when it is absolutely necessary. If you are not completely sure that you need it, then do not use it.

The example code in this subsection is saved as unsafe.go and will be presented in two parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "unsafe" 
) 
 
func main() { 
   var value int64 = 5 
   var p1 = &value 
   var p2 = (*int32)(unsafe.Pointer(p1)) 
```

You first create a new int64 variable that is named value. Then, you create a pointer to it named p1. Next, you create another pointer that points to p1. However, the p2 pointer that points to p1 is a pointer to an int32 integer, despite the fact that p1 points to an int64 variable. Although this is not permitted by Go rules, the unsafe.Pointer() function makes this possible.

The second part is as follows:

```markup
   fmt.Println("*p1: ", *p1) 
   fmt.Println("*p2: ", *p2) 
   *p1 = 312121321321213212 
   fmt.Println(value) 
   fmt.Println("*p2: ", *p2) 
   *p1 = 31212132 
   fmt.Println(value) 
   fmt.Println("*p2: ", *p2) 
} 
```

Executing unsafe.go will create the following output:

```markup
$ go run unsafe.go
*p1:  5
*p2:  5
312121321321213212
*p2:  606940444
31212132
*p2:  31212132
```

The output shows how dangerous an unsafe pointer can be. When the value of the value variable fits into an int32 memory space (5 and 31212132), then p2 works fine and shows the correct result. However, when the value variable holds a value (312121321321213212) that does not fit into an int32 memory space, then p2 shows an erroneous result (606940444), without giving you a warning or an error message.

Just Imagine

# Comparing Go to other programming languages

Go is not perfect, but neither are the rest of the programming languages. This section will briefly discuss other programming languages and compare them to Go in order to give you a better understanding of the choices you have. So, the list of programming languages that can be compared to Go includes:

-   **C**: C is the most popular programming language for developing systems software because the portable part of each Unix operating system is written in C. However, it has some critical drawbacks, including the fact that C pointers, which are great and fast, can lead to difficult-to-detect bugs and memory leaks. Additionally, C does not offer garbage collection; back when C was created, garbage collection was a luxury that had the ability slow down computers. However, nowadays computers are pretty fast and garbage collection does not slow things down anymore. Moreover, C programs require more code for developing a given task than other systems programming languages. Lastly, C is an old programming language that does not support modern programming paradigms, such as object-oriented and functional programming.
-   **C++**: As previously mention, I do not like C++ anymore. If you think that you should use C++, then you may want to consider using C instead. However, the main advantage of C++ over Go is that if needed, C++ can be used as if it were C. However, neither C nor C++ have good support for concurrent programming.
-   **Rust**: Rust is a new systems programming language that tries to avoid unpleasant bugs caused by unsafe code. Currently, the syntax of Rust is changing too fast, but this will end in the near feature. If for some reason you do not like Go, you should try Rust.
-   **Swift**: In its current status, Swift is more suitable for developing systems software for macOS systems. However, I am sure that in the near feature, Swift will be more popular on Linux machines, so you should keep an eye on it.
-   **Python**: Python is a scripting language, which is its main disadvantage. This is because usually, you do not want to make the source of your systems software available to everyone.
-   **Perl**: What was said about Python can be also said about Perl. However, both programming languages have a plethora of modules that will make your life a lot easier and your code a lot smaller.

If you ask my opinion, I think that Go is a modern, portable, mature, and safe programming language for writing systems software. You should try Go before looking for any alternatives. However, if you are a Go programmer and want to try something else, I suggest that you pick Rust or Swift. Yet, if you need to write reliable concurrent programs, Go should be your first choice.

If you cannot choose between Go and Rust, then just try C. Learning the basics of systems programming is more important than the programming language you select.

Despite their disadvantages, bear in mind that all scripting programming languages are perfect for writing prototypes and have the advantage that they allow you to create graphical interfaces for your software. Still, delivering systems software in a scripting language is rarely accepted, unless there is a really good reason to do so.

Just Imagine

# Analysing software

There are times that a program fails for some unknown reason or does not perform well, and you want to find out why without having to rewrite your code and add a plethora of debugging statements. So, this section will talk about strace(1) and dtrace(1) , which allow you to see what is going on behind the scenes when you execute a program on a Unix machine. Although both tools can work with the go run command, you will get less unrelated output if you first create an executable file using go build and use this file. This mainly occurs because go run makes temporary files before actually running your Go code, and you want to debug the actual program, not the compiler used to build the program.

Remember that although dtrace(1) is more powerful than strace(1) and has its own programming language, strace(1) is more versatile for watching the system calls a program makes.

# Using the strace(1) command-line utility

The strace(1) command-line utility allows you to trace system calls and signals. As strace(1) is not available on Mac machines, this section will use a Linux machine to showcase strace(1). However, as you will see in a later, macOS machines have the dtrace(1) command-line utility that can do many more things.

The number after the name of a program refers to the section of the manual its page belongs to. Although most of the names can be found only once, which means that putting the section number is not necessary, there are names that can be located in multiple sections because they have multiple meanings, such as crontab(1) and crontab(5). Therefore, if you try to retrieve such a page without specifically stating the section number, you will get the entry in the section of the manual that has the smallest section number.

To get a good sense of the output generated by strace(1), look at the following figure where strace(1) is used to examine the executable of addCLAImproved.go:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/6c0c5c81-3946-433a-bc90-4dafd085d3a0.png)

Using the strace(1) command on a Linux machine

The really interesting part of the strace(1) output is the following line, which cannot be seen in the preceding figure:

```markup
$ strace ./addCLAImproved 1 2 2>&1 | grep write
write(1, "Sum: 3\n", 7Sum: 3
```

We used the grep(1) command-line utility to extract the lines that contain the C system call that interests us, which in this case is write(2). This is because we already know that write(2) is used for printing output. So, you learned that in this case, a single write(2) C system call is used for printing all of the output on the screen; its first parameter is the file descriptor, and its second parameter is the text you want to print.

Note that you might want to use strace(1) with the \-f option in order to also trace any child processes that might get created during the execution of a program.

Bear in mind that there exist two more variations of write(2), named pwrite(2) and writev(2), which offer the same core functionality as write(2) but in a slightly different way.

The following variation of the previous command requires more calls to write(2) because it generates more output:

```markup
$ strace ./addCLAImproved 1 a b 2>&1 | grep write
write(1, "Ignoring a\n", 11Ignoring a
write(1, "Ignoring b\n", 11Ignoring b
write(1, "Sum: 1\n", 7Sum: 1
```

Unix uses file descriptors, which are positive integer values, as an internal representation for accessing all its files. By default, all Unix systems support three special and standard filenames: /dev/stdin, /dev/stdout, and /dev/stderr. They can also be accessed using file descriptors 0, 1, and 2, respectively. These three file descriptors are also called standard input, standard output, and standard error, respectively. Additionally, the file descriptor 0 can be accessed as /dev/fd/0 on a Mac machine and as /dev/pts/0 on a Debian Linux machine because everything in Unix is a file.

So, the reason for needing to put 2>&1 at the end of the command is to redirect all of the output, from standard error (file descriptor 2) to standard output (file descriptor 1), in order to be able to search it using the grep(1) command, which searches standard output only. Note that there exist many variations of grep(1), including zegrep(1), fgrep(1), and fgrep(1), that might work faster when they have to deal with large or huge text files.

What you can see here is that even if you are writing in Go, the generated executable uses C system calls and functions because apart from using machine language, C is the only way to communicate with the Unix kernel.

# The DTrace utility

Although debugging utilities, such as strace(1) and truss(1), which work on FreeBSD, can trace system calls produced by a process, they can be slow and therefore not appropriate for solving performance problems on busy Unix systems. Another tool named dtrace(1), which uses the **DTrace** facility, allows you to see what happens behind the scenes on a system-wide basis without the need to modify or recompile anything. It also allows you to work on production systems and watch running programs or server processes dynamically without introducing a big overhead.

This subsection will use the dtruss(1) command-line utility, which is just a dtrace(1) script, that shows the system calls of a process. The output that dtruss(1) generates when examining the addCLAImproved.go executable on a macOS machine looks similar to the one that you can see in the following screenshot:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/f596ddbd-3b87-454d-8eda-478318fd1014.png)

Using the dtruss(1) command on a macOS machine

Once again, the following part of the output verifies that at the end of the day, everything on Unix machines is translated into C system calls and functions because this is the only way to communicate with the Unix kernel. You can display all the calls to the write(2) system call as follows:

```markup
$ sudo dtruss -c ./addCLAImproved 2000 2>&1 | grep write
```

However, this time you are going to get lots of output because the macOS executable uses write(2) multiple times instead of just once to print the same output.

Starting to realize that not all Unix systems work the same way, despite their numerous similarities, is marvelous. But this also means that you should not make any assumptions about the way a Unix system works behind the scenes.

What is really interesting is the last part of the output of the following command:

```markup
$ sudo dtruss -c ./addCLAImproved 2000
CALL                                        COUNT
__pthread_sigmask                               1
exit                                            1
getpid                                          1
ioctl                                           1
issetugid                                       1
read                                            1
thread_selfid                                   1
ulock_wake                                      1
bsdthread_register                              2
close                                           2
csops                                           2
open                                            2
select                                          2
sysctl                                          3
mmap                                            7
mprotect                                        8
stat64                                         41
write                                          83
```

The reason you get this output is the \-c option that tells dtruss(1) to count all system calls and print a summary of them, which in this case shows that write(2) has been called 83 times and stat64(2) 41 times.

The dtrace(1) utility is much more powerful than strace(1) and has its own programming language but is more difficult to learn. Additionally, even though there is a Linux version of dtrace(1), strace(1) is more mature on Linux systems and does the job of tracing system calls in a simpler way.

You can learn more about the dtrace(1) utility by reading _DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X, and FreeBSD_ by Brendan Gregg and Jim Mauro and by visiting [http://dtrace.org/](http://dtrace.org/).

# Disabling System Integrity Protection on macOS

There is a big chance that you will have trouble running dtrace(1) and dtruss(1) on your Mac OS X machine the first time you try them and get the following error message:

```markup
$ sudo dtruss ./addCLAImproved 1 2 2>&1 | grep -i write
dtrace: error on enabled probe ID 2132 (ID 156: syscall::write:return): invalid kernel access in action #12 at DIF offset 92
```

In this case you might need to disable the DTrace restrictions but still keep System Integrity Protection active for everything else. You can learn more about System Integrity Protection by visiting [https://support.apple.com/en-us/HT204899](https://support.apple.com/en-us/HT204899).

Just Imagine

# Unreachable code

Unreachable code is code that can never be executed and is a logical kind of error. As the Go compiler itself cannot catch such logical errors, you will need to use the go tool vet command to help.

You should not confuse unreachable code with code that never gets executed intentionally, such as the code of a function that is not needed and is therefore not called in a program.

The example code in this section is saved as cannotReach.go and can be divided into two parts.

The first part has the following Go code:

```markup
package main 
 
import ( 
   "fmt" 
) 
func x() int { 
   return -1 
   fmt.Println("Exiting x()") 
   return -1 
} 
 
func y() int { 
   return -1 
   fmt.Println("Exiting y()") 
   return -1 
} 
```

The second part is as follows:

```markup
func main() { 
   fmt.Println(x()) 
   fmt.Println("Exiting program...") 
} 
```

As you can see, the unreachable code is in the first part. Both x() and y() functions have unreachable code because their return statements were put at the wrong place. However, we are not done yet because we will have to let the go tool vet tool discover the unreachable code. The process is simple and includes the execution of the following command:

```markup
$ go tool vet cannotReach.go
cannotReach.go:9: unreachable code
cannotReach.go:14: unreachable code
 
```

Additionally, you can see that go tool vet detects unreachable code even if the surrounding function is not going to be executed at all, as happens with y().

Just Imagine

# Avoiding common Go mistakes

This section will briefly talk about some common Go mistakes so that you can avoid them in your programs:

-   If you have an error in a Go function, either log it or return it; do not do both unless you have a really good reason to do so.
-   Go interfaces define behaviors, not data and data structures.
-   Use the io.Reader and io.Writer interfaces because they make your code more extensible.
-   Make sure that you pass a pointer to a variable to a function only when needed. The rest of the time, just pass the value of the variable.
-   Error variables are not strings; they are error values.
-   If you are afraid of making mistakes, you will most likely end up doing nothing useful. So experiment as much as you can.

The following are general pieces of advice that can be applied in every programming language:

-   Test your Go code and functions in small and autonomous Go programs to make sure that they behave the way you think they should
-   If you do not really know a Go feature, test it before using it for the first time, especially if you are developing a systems utility
-   Do not test systems software on production machines
-   When you deploy your systems software on a production machine, do it when the production machine is not busy and make sure that you have a backup plan

Just Imagine

# Exercises

1.  Find and visit the documentation page of the log package.
2.  Use strace(1) to examine hw.go from the previous chapter.
3.  If you are on a Mac, try to examine the hw.go executable using dtruss(1).
4.  Write a program that gets input from the user and examine its executable file using either strace(1) or dtruss(1).

5.  Visit the website of Rust at [https://www.rust-lang.org/](https://www.rust-lang.org/).
6.  Visit the website of Swift at [https://swift.org/](https://swift.org/).
7.  Visit the documentation page of the io package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
8.  Use the diff(1) command-line utility on your own in order to learn how to interpret its output better.
9.  Visit and read the main page of write(2).
10.  Visit the main page of grep(1).
11.  Play with reflection on your own by examining your own structures.
12.  Write an improved version of occurrences.go that will only display frequencies that are above a known numeric threshold, which will be given as a command-line argument.

Just Imagine

# Summary

This chapter taught you some advanced Go features, including error handling, pattern matching and regular expressions, reflection, and unsafe code. Also, it talked about the strace(1) and dtrace(1) tools.

The next chapter will cover many interesting things, including the use of the new sort.slice() Go function, which is available in the latest Go version (1.8), as well as the big O notation, sorting algorithms, Go packages, and garbage collection.

# Go Packages, Algorithms, and Data Structures

The main topics of this chapter will be Go packages, algorithms, and data structures. If you combine all of these, you will end up with a complete program because Go programs come in packages that contain algorithms that deal with data structures. These packages include both the ones that come with Go and the ones that you create on your own in order to manipulate your data.

Hence, in this chapter, you will learn about the following:

-   The Big O notation
-   Two sorting algorithms
-   The sort.Slice() function
-   Linked lists
-   Trees
-   Creating your own hash table data structure in Go
-   Go packages
-   **Garbage collection** (**GC**) in Go

Just Imagine

# About algorithms

Knowing about algorithms and the way they work will definitely help you when you have to manipulate lots of data. Additionally, if you choose to use the wrong algorithm for a given job, you might slow down the entire process and make your software unusable.

Traditional Unix command-line utilities such as awk(1), sed(1), vi(1), tar(1), and cp(1) are great examples of how good algorithms can help, and these utilities can work with files that are much bigger than the memory of a machine. This was extremely important in the early Unix days because the total amount of RAM on a Unix machine then was about 64K or even less!

# The Big O notation

The **Big O** **notation** is used for describing the complexity of an algorithm, which is directly related to its performance. The efficiency of an algorithm is judged by its computation complexity, which mainly has to do with the number of times the algorithm needs to access its input data to do its job. Usually, you would want to know about the worst-case scenario and the average situation.

So, an O(n) algorithm, where n is the size of the input, is considered better than an O(n<sup>2</sup>) algorithm, which is better than an O(n<sup>3</sup>) algorithm. However, the worst algorithms are the ones with an O(n!) running time because this makes them almost unusable for inputs with more than 300 elements. Note that the Big O notation is more about estimating and not about giving an exact value. Therefore, it is largely used as a comparative value and not an absolute value.

Also, most Go lookup operations in built-in types, such as finding the value of a map key or accessing an array element, have a constant time, which is represented by O(1). This means that built-in types are generally faster than custom types and that you should usually prefer them unless you want full control over what is going on behind the scenes. Additionally, not all data structures are created equal. Generally speaking, array operations are faster than map operations, whereas maps are more versatile than arrays!

Just Imagine

# Sorting algorithms

The most common category of algorithm has to deal with sorting data, that is, placing it in a given order. The two most famous sorting algorithms are the following:

-   **Quicksort**: This is considered one of the fastest sorting algorithms. The average time that quicksort takes to sort its data is O (n log n), but this can grow up to O(n<sup>2</sup>) in the worst-case scenario, which mainly has to do with the way the data is presented for processing.
-   **Bubble sort**: This algorithm is pretty easy to implement with an O(n<sup>2</sup>) average complexity. If you want to start learning about sorting, start with bubble sort before looking into the more difficult to develop algorithms.

Although every algorithm has its disadvantages, if you do not have lots of data, the algorithm is not really important as long as it does the job.

What you should remember is, the way Go implements sorting internally cannot be controlled by the developer and it can change in the future; so, if you want to have full control over sorting, you should write your own implementation.

# The sort.Slice() function

This section will illustrate the use of the sort.Slice() function that first came with Go version 1.8. The use of the function will be illustrated in sortSlice.go, which will be presented in three parts.

The first part is the expected preamble of the program and the definition of a new structure type, given as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "sort" 
) 
 
type aStructure struct { 
   person string 
   height int 
   weight int 
} 
```

As you might expect, you have to import the sort package to be able to use its Slice() function.

The second part contains the definition of a slice, which has four elements:

```markup
func main() { 
 
   mySlice := make([]aStructure, 0) 
   a := aStructure{"Mihalis", 180, 90} 
   mySlice = append(mySlice, a) 
   a = aStructure{"Dimitris", 180, 95} 
   mySlice = append(mySlice, a) 
   a = aStructure{"Marietta", 155, 45} 
   mySlice = append(mySlice, a) 
   a = aStructure{"Bill", 134, 40} 
   mySlice = append(mySlice, a)
```

Therefore, in the first part, you declared a slice of structure that will be sorted in two ways in the rest of the program, which contains the following code:

```markup
   fmt.Println("0:", mySlice) 
   sort.Slice(mySlice, func(i, j int) bool { 
         return mySlice[i].weight <mySlice[j].weight 
   }) 
   fmt.Println("<:", mySlice) 
   sort.Slice(mySlice, func(i, j int) bool { 
         return mySlice[i].weight >mySlice[j].weight 
   }) 
   fmt.Println(">:", mySlice) 
} 
```

This code contains all the magic: you only have to define the way you want to sort your slice and the rest is done by Go. The sort.Slice() function takes the anonymous sorting function as one of its arguments; the other argument is the name of the slice variable you want to sort. Note that the sorted slice is saved in the slice variable.

Executing sortSlice.go will generate the following output:

```markup
$ go run sortSlice.go
0: [{Mihalis 180 90} {Dimitris 180 95} {Marietta 155 45} {Bill 134 40}]
<: [{Bill 134 40} {Marietta 155 45} {Mihalis 180 90} {Dimitris 180 95}]
>: [{Dimitris 180 95} {Mihalis 180 90} {Marietta 155 45} {Bill 134 40}]
```

As you can see, you can easily sort in ascending or descending order by just changing a single character in the Go code!

Also, if your Go version does not support sort.Slice(), you will get an error message similar to the following:

```markup
$ go version
go version go1.3.3 linux/amd64
$ go run sortSlice.go
# command-line-arguments
./sortSlice.go:27: undefined: sort.Slice
./sortSlice.go:31: undefined: sort.Slice
```

Just Imagine

# Linked lists in Go

A **linked list** is a structure with a finite set of elements where each element uses at least two memory locations: one for storing the data and the other for a pointer that links the current element to the next one in the sequence of elements that make the linked list. The biggest advantages of linked lists are that they are easy to understand and implement, and generic enough to be used in many different situations and model many different kinds of data.

The first element of a linked list is called the **head**, whereas the last element of a list is often called the **tail**. The first thing you should do when defining a linked list is to keep the head of the list in a separate variable because the head is the only thing that you need to access the entire linked list.

Note that if you lose the pointer to the first node of a single linked list, there is no possible way to find it again.

The following figure shows the graphical representation of a linked list and a doubly linked list. Doubly linked lists are more flexible, but require more housekeeping:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/834e20cc-7099-4649-b740-da9fa61fbd3d.png)

The graphical representation of a linked list and a doubly linked list

So, in this section, we will present a simple implementation of a linked list in Go saved in linkedList.go.

When creating your own data structures, the single most important element is the definition of the node, which is usually implemented using a structure.

The code of linkedList.go will be presented in four parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
) 
```

The second part contains the following Go code:

```markup
type Node struct { 
   Value int 
   Next  *Node 
} 
 
func addNode(t *Node, v int) int { 
   if root == nil { 
         t = &Node{v, nil} 
         root = t 
         return 0 
   } 
 
   if v == t.Value { 
         fmt.Println("Node already exists:", v) 
         return -1 
   } 
 
   if t.Next == nil { 
         t.Next = &Node{v, nil} 
         return -2 
   } 
 
   return addNode(t.Next, v) 
} 
```

Here, you define the structure that will hold each element of the list and a function that allows you to add a new node to the list. In order to avoid duplicate entries, you should check whether a value already exists in the list or not. Note that addNode() is a recursive function because it calls itself and that this approach might be a little slower and require more memory than iterating.

The third part of the code is the traverse() function:

```markup
func traverse(t *Node) { 
   if t == nil { 
         fmt.Println("-> Empty list!") 
         return 
   } 
 
   for t != nil { 
         fmt.Printf("%d -> ", t.Value) 
         t = t.Next 
   } 
   fmt.Println() 
} 
```

The for loop implements the iterative approach for visiting all the nodes in a linked list.

The last part is as follows:

```markup
var root = new(Node)
func main() { 
   fmt.Println(root) 
   root = nil 
   traverse(root) 
   addNode(root, 1) 
   addNode(root, 1) 
   traverse(root) 
   addNode(root, 10) 
   addNode(root, 5) 
   addNode(root, 0) 
   addNode(root, 0) 
   traverse(root) 
   addNode(root, 100) 
   traverse(root) 
}
```

For the first time in this book, you see the use of a global variable that is not a constant. Global variables can be accessed and changed from anywhere in a program, which makes their use both practical and dangerous for that reason. The reason for using a global variable, which is named root, to hold the root of the linked list is to show whether the linked list is empty or not. This happens because integer values in Go are initialized as 0; so new(Node) is in fact {0 <nil>}, which makes it impossible to tell whether the head of the list is nil or not without passing an extra variable to each function that manipulates the linked list.

Executing linkedList.go will generate the following output:

```markup
$ go run linkedList.go
&{0 <nil>}
-> Empty list!
Node already exists: 1
1 ->
Node already exists: 0
1 -> 10 -> 5 -> 0 ->
1 -> 10 -> 5 -> 0 -> 100 ->
```

Just Imagine

# Trees in Go

A **graph** is a finite and nonempty set of vertices and edges. A **directed graph** is a graph whose edges have a direction associated with them. A **directed acyclic graph** is a directed graph with no cycles in it. A **tree** is a directed acyclic graph that satisfies three more principles: firstly, it has a root node: the entry point to the tree; secondly, every vertex, except the root, has one and only one entry point; and thirdly, there is a path that connects the root with each vertex and belongs to the tree.

As a result, the root is the first node of the tree. Each node can be connected to one or more nodes depending on the tree type. If each node leads to one and only one other node, then the tree is a linked list!

The most commonly used type of tree is called a binary tree because each node can have up to two children. The following figure shows a graphical representation of a binary tree's data structure:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)

A binary tree

The presented code will only show you how to create a binary tree and how to traverse it in order to print all of its elements as proof that Go can be used for creating a tree data structure. Therefore, it will not implement the full functionality of a binary tree, which also includes deleting a tree node and balancing a tree.

The code of tree.go will be presented in three parts.

The first part is the expected preamble as well as the definition of the node, as given here:

```markup
package main 
 
import ( 
   "fmt" 
   "math/rand" 
   "time" 
) 
type Tree struct { 
   Left  *Tree 
   Value int 
   Right *Tree 
} 
```

The second part contains functions that allow you to traverse a tree in order to print all of its elements, create a tree with randomly generated numbers, and insert a node into it:

```markup
func traverse(t *Tree) { 
   if t == nil { 
         return 
   } 
   traverse(t.Left) 
   fmt.Print(t.Value, " ") 
   traverse(t.Right) 
} 
 
func create(n int) *Tree { 
   var t *Tree 
   rand.Seed(time.Now().Unix()) 
   for i := 0; i< 2*n; i++ { 
         temp := rand.Intn(n) 
         t = insert(t, temp) 
   } 
   return t 
} 
 
func insert(t *Tree, v int) *Tree { 
   if t == nil { 
         return&Tree{nil, v, nil} 
   } 
   if v == t.Value { 
         return t 
   } 
   if v <t.Value { 
         t.Left = insert(t.Left, v) 
         return t 
   } 
   t.Right = insert(t.Right, v) 
   return t 
} 
```

The second if statement of insert() checks whether a value already exists in the tree, in order to not add it again. The third if statement identifies whether the new element will be on the left or right-hand side of the current node.

The last part is the implementation of the main() function:

```markup
func main() { 
   tree := create(30) 
   traverse(tree) 
   fmt.Println() 
   fmt.Println("The value of the root of the tree is", tree.Value) 
} 
```

Executing tree.go will generate the following output:

```markup
$ go run tree.go
0 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27 28 29
The value of the root of the tree is 16
```

Please note that as the values of the nodes of the tree are generated randomly, the output of the program will be different each time you run it. If you want to get the same elements all the time, then use a constant for the seed value in the create() function.

Just Imagine

# Developing a hash table in Go

Strictly speaking, a **hash table** is a data structure that stores one or more key and value pairs and uses the hashFunction of the key to compute an index into an array of buckets or slots, from which the correct value can be retrieved. Ideally, the hashFunction should assign each key to a unique bucket, provided that you have the required number of buckets.

A good hashFunction must be able to produce a uniform distribution of hash values because it is inefficient to have unused buckets or big differences in the cardinalities of the buckets. Additionally, the hashFunction should work consistently and output the same hash value for identical keys because otherwise it would be impossible to find the information you want! If you think that hash tables are not that useful, handy, or clever, you should consider the following: when a hash table has _n_ keys and _k_ buckets, its search speed goes from O (n) for a linear search to O (n/k)! Although the improvement might look small, you should realize that for a hash array with only 20 slots, the search time would be reduced by 20 times! This makes hash tables good for applications such as dictionaries or any other analogous application where you have to search lots of data. Although using lots of buckets increases the complexity and the memory usage of your program, there are times when it is worth it.

The following figure shows the graphical representation of a simple hash table with 10 buckets. It is not difficult to understand that the hashFunction is the modulo operator:

![](https://static.packt-cdn.com/products/9781787125643/graphics/assets/30731fad-6b66-43d1-8e49-25ae564255a1.png)

A simple hash table

Although the presented version of a hash table uses numbers because they are a little easier to implement and understand, you can use any data type you want as long as you can find an appropriate hashFunction to process your input. The source code of hash.go will be presented in three parts.

The first one is the following:

```markup
package main 
 
import ( 
   "fmt" 
) 
 
type Node struct { 
   Value int 
   Next  *Node 
} 
 
type HashTablestruct { 
   Table map[int]*Node 
   Size  int 
} 
```

The Node struct definition is taken from the implementation of the linked list you saw earlier. The reason for using a map for the Table variable instead of a slice is that the index of a slice can only be a natural number, whereas the key of a map can be anything.

The second part contains the following Go code:

```markup
func hashFunction(i, size int) int { 
   return (i % size) 
} 
 
func insert(hash *HashTable, value int) int { 
   index := hashFunction(value, hash.Size) 
   element := Node{Value: value, Next: hash.Table[index]} 
   hash.Table[index] = &element 
   return index 
} 
 
func traverse(hash *HashTable) { 
   for k := range hash.Table { 
         if hash.Table[k] != nil { 
               t := hash.Table[k] 
               for t != nil { 
                     fmt.Printf("%d -> ", t.Value) 
                     t = t.Next 
               } 
               fmt.Println() 
         } 
   } 
}
```

Note here that the traverse() function is using the Go code from linkedList.go in order to traverse the elements of each bucket in the hash table. Additionally, note that the insert function does not check whether or not a value already exists in the hash table in order to save book space, but this is not usually the case. Also, for reasons of speed and simplicity, new elements are inserted at the beginning of each list.

The last part contains the implementation of the main() function:

```markup
func main() { 
   table := make(map[int]*Node, 10) 
   hash := &HashTable{Table: table, Size: 10} 
   fmt.Println("Number of spaces:", hash.Size) 
   for i := 0; i< 95; i++ { 
         insert(hash, i) 
   } 
   traverse(hash) 
} 
```

Executing hash.go will generate the following output, which proves that the hash table is working as expected:

```markup
$ go run hash.go
Number of spaces: 1089 -> 79 -> 69 -> 59 -> 49 -> 39 -> 29 -> 19 -> 9 ->86 -> 76 -> 66 -> 56 -> 46 -> 36 -> 26 -> 16 -> 6 ->
92 -> 82 -> 72 -> 62 -> 52 -> 42 -> 32 -> 22 -> 12 -> 2 ->
94 -> 84 -> 74 -> 64 -> 54 -> 44 -> 34 -> 24 -> 14 -> 4 ->
85 -> 75 -> 65 -> 55 -> 45 -> 35 -> 25 -> 15 -> 5 ->
87 -> 77 -> 67 -> 57 -> 47 -> 37 -> 27 -> 17 -> 7 ->
88 -> 78 -> 68 -> 58 -> 48 -> 38 -> 28 -> 18 -> 8 ->
90 -> 80 -> 70 -> 60 -> 50 -> 40 -> 30 -> 20 -> 10 -> 0 ->
91 -> 81 -> 71 -> 61 -> 51 -> 41 -> 31 -> 21 -> 11 -> 1 ->
93 -> 83 -> 73 -> 63 -> 53 -> 43 -> 33 -> 23 -> 13 -> 3 ->
```

If you execute hash.go multiple times, you will see that the order the lines are printed in will vary. This happens because the output of range hash.Table found in the traverse() function cannot be predicted, which happens because Go has an unspecified return order for hashes.

Just Imagine

# About Go packages

Packages are for grouping related functions and constants so that you can transfer them easily and use them in your own Go programs. As a result, apart from the main package, packages are not autonomous programs.

There exist many useful Go packages that come with each Go distribution including the following:

-   The net package: This supports portable TCP and UDP connections
-   The http package: This is a part of the net package and offers HTTP server and client implementations
-   The math package: This provides mathematical functions and constants
-   The io package: This deals with primitive input and output operations
-   The os package: This gives you a portable interface to the operating system functionality
-   The time package: This allows you to work with times and dates

For the full list of standard Go packages refer to [https://golang.org/pkg/](https://golang.org/pkg/). I strongly advise you to look into all the packages that come with Go before you start developing your own functions and packages because there is a realistic chance that the functionality you are looking for is already available in a standard Go package.

# Using standard Go packages

You probably already know how to use the standard Go packages. However, what you may not be aware of is the fact that some packages have a structure. So, for example, the net package has several sub directories, named http, mail, rpc, smtp, textproto, and url, which should be imported as net/http, net/mail, net/rpc, net/smtp, net/textproto, and net/url, respectively. Go groups packages when this makes sense, but these packages could have also been isolated packages if they were grouped for distribution instead of functionality.

You can find information about a Go standard package with the help of the godoc utility. So, if you are looking for information about the net package, you should execute godoc net.

# Creating your own packages

Packages make the design, implementation, and maintenance of large software systems easier and simpler. Moreover, they allow multiple programmers to work on the same project without any overlapping. So, if you find yourselves using the same functions all the time, you should seriously consider including them in your own Go packages.

The source code of a Go package, which can contain multiple files, can be found within a single directory, which is named after the package with the exception of the main package, which can have any name.

The Go code of the aSimplePackage.go file, which will be developed in this section, will be presented in two parts.

The first part is the following:

```markup
package aSimplePackage 
 
import ( 
   "fmt" 
) 
```

There is nothing special here; you just have to define the name of the package and include the necessary import statements because a package can depend on other packages.

The second part contains the following Go code:

```markup
const Pi = "3.14159" 
 
func Add(x, y int) int { 
   return x + y 
} 
 
func Println(x int) { 
   fmt.Println(x) 
} 
```

So, the aSimplePackage package offers two functions and one constant.

After you finish writing the code of aSimplePackage.go, you should execute the following commands in order to be able to use the package in other Go programs or packages:

```markup
$ mkdir ~/go
$ mkdir ~/go/src
$ mkdir ~/go/src/aSimplePackage
$ export GOPATH=~/go
$ vi ~/go/src/aSimplePackage/aSimplePackage.go
$ go install aSimplePackage 
```

You should perform all these actions for every Go package you create, apart from the first two mkdir commands, which should only be executed once.

As you can see, each package needs its own directory inside ~/go/src. After executing the aforementioned commands, the go tool will automatically generate an ar(1) archive of the Go package you have just compiled in the pkg directory:

```markup
$ ls -lR ~/go
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 pkg
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 src
    
/Users/mtsouk/go/pkg:
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 darwin_amd64
    
/Users/mtsouk/go/pkg/darwin_amd64:
total 8
-rw-r--r--  1 mtsouk  staff  2918 Apr  4 22:35 aSimplePackage.a
    
/Users/mtsouk/go/src:
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 aSimplePackage
    
/Users/mtsouk/go/src/aSimplePackage:
total 8
-rw-r--r--  1 mtsouk  staff  148 Apr  4 22:30 aSimplePackage.go
```

Although you are now ready to use the aSimplePackage package, you cannot see the functionality of the package without having an autonomous program.

# Private variables and functions

Private variables and functions are different from public ones in that they can be used and called only internally in a package. Controlling which functions and variables are public or not is also known as encapsulation.

Go follows a simple rule which states that functions, variables, types, and so on that begin with an uppercase letter are public, whereas functions, variables, types, and so on that begin with a lowercase letter are private. However, this rule does not affect package names.

You should understand now why the fmt.Printf() function is named as it is, instead of fmt.printf().

To illustrate this, we will make some changes to the aSimplePackage.go module and add one private variable and one private function. The name of the new separate package will be anotherPackage.go. You can see the changes made to it using the diff(1) command-line utility:

```markup
$ diff aSimplePackage.go anotherPackage.go
1c1
<packageaSimplePackage
---
>packageanotherPackage
7a8
>const version = "1.1"
15a17,20
>
>func Version() {
>     fmt.Println("The version of the package is", version)
> }
```

# The init() function

Every Go package can have a function named init() that is automatically executed at the beginning of the execution. So, let's add the following init() function to the code of the anotherPackage.go package:

```markup
func init() { 
   fmt.Println("The init function of anotherPackage") 
} 
```

The current implementation of the init() function is naive and does nothing special. However, there are times when you want to perform important initializations before you start using a package such as opening database and network connections: in these relatively rare cases the init() function is invaluable.

# Using your own Go packages

This subsection will show you how to use the aSimplePackage and anotherPackage packages in your own Go programs by presenting two small Go programs named usePackage.go and privateFail.go.

In order to use the aSimplePackage package that resides under the GOPATH directory from another Go program, you will need to write the following Go code:

```markup
package main 
 
import ( 
   "aSimplePackage" 
   "fmt" 
) 
 
func main() { 
   temp := aSimplePackage.Add(5, 10) 
   fmt.Println(temp) 
   fmt.Println(aSimplePackage.Pi) 
} 
```

First of all, if aSimplePackage is not already compiled and located at the expected location, the compilation process will fail with an error message similar to the following:

```markup
$ go run usePackage.go
usePackage.go:4:2: cannot find package "aSimplePackage" in any of:
      /usr/local/Cellar/go/1.8/libexec/src/aSimplePackage (from $GOROOT)
      /Users/mtsouk/go/src/aSimplePackage (from $GOPATH)
```

However, if aSimplePackage is available, usePackage.go will be executed just fine:

```markup
$ go run usePackage.go
15
3.14159
```

Now, let's see the Go code of the other small program that uses anotherPackage:

```markup
package main 
 
import ( 
   "anotherPackage" 
   "fmt" 
) 
 
func main() { 
   anotherPackage.Version() 
   fmt.Println(anotherPackage.version) 
   fmt.Println(anotherPackage.Pi) 
} 
```

If you try to call a private function or use a private variable from anotherPackage, your Go program privateFail.go will fail to run with the following error message:

```markup
$ go run privateFail.go
# command-line-arguments
./privateFail.go:10: cannot refer to unexported name anotherPackage.version
./privateFail.go:10: undefined: anotherPackage.version
```

I really like showing error messages because most books try to hide them as if they were not there. When I was learning Go, it took me about 3 hours of debugging until I found that the reason for an error message I could not explain was the name of a variable!

However, if you remove the call to the private variable from privateFail.go, the program will be executed without errors. Additionally, you will see that the init() function actually gets executed automatically:

```markup
$ go run privateFail.go
The init function of anotherPackage
The version of the package is 1.1
3.14159
```

# Using external Go packages

Sometimes packages are available on the internet and you would prefer to use them by specifying their internet address. One such example is the Go MySQL driver that can be found at github.com/go-sql-driver/mysql.

Look at the following Go code, which is saved as useMySQL.go:

```markup
package main 
 
import ( 
   "fmt" 
   _ "github.com/go-sql-driver/mysql") 
 
func main() { 
   fmt.Println("Using the MySQL Go driver!") 
} 
```

The use of \_ as the package identifier will make the compiler ignore the fact that the package is not being used: the only sensible reason for bypassing the compiler is when you have an init function in your unused package that you want to be executed. The other sensible reason is for illustrating a Go concept!

If you try to execute useMySQL.go, the compilation process will fail:

```markup
$ go run useMySQL.go
useMySQL.go:5:2: cannot find package "github.com/go-sql-driver/mysql" in any of:
      /usr/local/Cellar/go/1.8/libexec/src/github.com/go-sql-driver/mysql (from $GOROOT)
      /Users/mtsouk/go/src/github.com/go-sql-driver/mysql (from $GOPATH)
```

In order to compile useMySQL.go, you should first perform the following steps:

```markup
$ go get github.com/go-sql-driver/mysql
$ go run useMySQL.go
Using the MySQL Go driver!
```

After successfully downloading the required package, the contents of the ~/go directory verify that the desired Go package has been downloaded:

```markup
$ ls -lR ~/go
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 pkg
drwxr-xr-x  5 mtsouk  staff  170 Apr  6 21:32 src
    
/Users/mtsouk/go/pkg:
total 0
drwxr-xr-x  5 mtsouk  staff  170 Apr  6 21:32 darwin_amd64
    
/Users/mtsouk/go/pkg/darwin_amd64:
total 24
-rw-r--r--  1 mtsouk  staff  2918 Apr  4 23:07 aSimplePackage.a
-rw-r--r--  1 mtsouk  staff  6102 Apr  4 22:50 anotherPackage.a
drwxr-xr-x  3 mtsouk  staff   102 Apr  6 21:32 github.com
    
/Users/mtsouk/go/pkg/darwin_amd64/github.com:
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  6 21:32 go-sql-driver
    
/Users/mtsouk/go/pkg/darwin_amd64/github.com/go-sql-driver:
total 728
-rw-r--r--  1 mtsouk  staff  372694 Apr  6 21:32 mysql.a
    
/Users/mtsouk/go/src:
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:35 aSimplePackage
drwxr-xr-x  3 mtsouk  staff  102 Apr  4 22:50 anotherPackage
drwxr-xr-x  3 mtsouk  staff  102 Apr  6 21:32 github.com
    
/Users/mtsouk/go/src/aSimplePackage:
total 8
-rw-r--r--  1 mtsouk  staff  148 Apr  4 22:30 aSimplePackage.go
    
/Users/mtsouk/go/src/anotherPackage:
total 8
-rw-r--r--@ 1 mtsouk  staff  313 Apr  4 22:50 anotherPackage.go
    
/Users/mtsouk/go/src/github.com:
total 0
drwxr-xr-x  3 mtsouk  staff  102 Apr  6 21:32 go-sql-driver
    
/Users/mtsouk/go/src/github.com/go-sql-driver:
total 0
drwxr-xr-x  35 mtsouk  staff  1190 Apr  6 21:32 mysql
    
/Users/mtsouk/go/src/github.com/go-sql-driver/mysql:
total 584
-rw-r--r--  1 mtsouk  staff   2066 Apr  6 21:32 AUTHORS
-rw-r--r--  1 mtsouk  staff   5581 Apr  6 21:32 CHANGELOG.md
-rw-r--r--  1 mtsouk  staff   1091 Apr  6 21:32 CONTRIBUTING.md
-rw-r--r--  1 mtsouk  staff  16726 Apr  6 21:32 LICENSE
-rw-r--r--  1 mtsouk  staff  18610 Apr  6 21:32 README.md
-rw-r--r--  1 mtsouk  staff    470 Apr  6 21:32 appengine.go
-rw-r--r--  1 mtsouk  staff   4965 Apr  6 21:32 benchmark_test.go
-rw-r--r--  1 mtsouk  staff   3339 Apr  6 21:32 buffer.go
-rw-r--r--  1 mtsouk  staff   8405 Apr  6 21:32 collations.go
-rw-r--r--  1 mtsouk  staff   8525 Apr  6 21:32 connection.go
-rw-r--r--  1 mtsouk  staff   1831 Apr  6 21:32 connection_test.go
-rw-r--r--  1 mtsouk  staff   3111 Apr  6 21:32 const.go
-rw-r--r--  1 mtsouk  staff   5036 Apr  6 21:32 driver.go
-rw-r--r--  1 mtsouk  staff   4246 Apr  6 21:32 driver_go18_test.go
-rw-r--r--  1 mtsouk  staff  47090 Apr  6 21:32 driver_test.go
-rw-r--r--  1 mtsouk  staff  13046 Apr  6 21:32 dsn.go
-rw-r--r--  1 mtsouk  staff   7872 Apr  6 21:32 dsn_test.go
-rw-r--r--  1 mtsouk  staff   3798 Apr  6 21:32 errors.go
-rw-r--r--  1 mtsouk  staff    989 Apr  6 21:32 errors_test.go
-rw-r--r--  1 mtsouk  staff   4571 Apr  6 21:32 infile.go
-rw-r--r--  1 mtsouk  staff  31362 Apr  6 21:32 packets.go
-rw-r--r--  1 mtsouk  staff   6453 Apr  6 21:32 packets_test.go
-rw-r--r--  1 mtsouk  staff    600 Apr  6 21:32 result.go
-rw-r--r--  1 mtsouk  staff   3698 Apr  6 21:32 rows.go
-rw-r--r--  1 mtsouk  staff   3609 Apr  6 21:32 statement.go
-rw-r--r--  1 mtsouk  staff    729 Apr  6 21:32 transaction.go
-rw-r--r--  1 mtsouk  staff  17924 Apr  6 21:32 utils.go
-rw-r--r--  1 mtsouk  staff   5784 Apr  6 21:32 utils_test.go
```

# The go clean command

There will be times when you are developing a big Go program that uses lots of nonstandard Go packages and you want to start the compilation process from the beginning. Go allows you to clean up the files of a package in order to recreate it later. The following command cleans up a package without affecting the code of the package:

```markup
$ go clean -x -i aSimplePackage
cd /Users/mtsouk/go/src/aSimplePackage
rm -f aSimplePackage.test aSimplePackage.test.exe
rm -f /Users/mtsouk/go/pkg/darwin_amd64/aSimplePackage.a
```

Similarly, you can also clean up a package that you have downloaded from the internet, which also requires the use of its full path:

```markup
$ go clean -x -i github.com/go-sql-driver/mysql
cd /Users/mtsouk/go/src/github.com/go-sql-driver/mysql
rm -f mysql.test mysql.test.exe appengine appengine.exe
rm -f /Users/mtsouk/go/pkg/darwin_amd64/github.com/go-sql-driver/mysql.a
```

Please note that the go clean command is also particularly useful when you want to transfer your projects to another machine without including unnecessary files.

Just Imagine

# Garbage collection

In this section, we will briefly talk about how Go deals with GC, which tries to free unused memory efficiently. The Go code of garbageCol.go can be presented in two parts.

The first part is as follows:

```markup
package main 
 
import ( 
   "fmt" 
   "runtime" 
   "time" 
) 
 
func printStats(mem runtime.MemStats) { 
   runtime.ReadMemStats(&mem) 
   fmt.Println("mem.Alloc:", mem.Alloc) 
   fmt.Println("mem.TotalAlloc:", mem.TotalAlloc) 
   fmt.Println("mem.HeapAlloc:", mem.HeapAlloc) 
   fmt.Println("mem.NumGC:", mem.NumGC) 
   fmt.Println("-----") 
} 
```

Every time you want to read the latest memory statistics, you should make a call to the runtime.ReadMemStats() function.

The second part, which contains the implementation of the main() function, has the following Go code:

```markup
func main() { 
   var memruntime.MemStats 
   printStats(mem) 
 
   for i := 0; i< 10; i++ { 
         s := make([]byte, 100000000) 
         if s == nil { 
               fmt.Println("Operation failed!") 
         } 
   } 
   printStats(mem) 
 
   for i := 0; i< 10; i++ { 
         s := make([]byte, 100000000) 
         if s == nil { 
               fmt.Println("Operation failed!") 
         } 
         time.Sleep(5 * time.Second) 
   } 
   printStats(mem) 
} 
```

Here, you try to obtain large amounts of memory in order to trigger the use of the garbage collector.

Executing garbageCol.go generates the following output:

```markup
$ go run garbageCol.go
mem.Alloc: 53944
mem.TotalAlloc: 53944
mem.HeapAlloc: 53944
mem.NumGC: 0
-----
mem.Alloc: 100071680
mem.TotalAlloc: 1000146400
mem.HeapAlloc: 100071680
mem.NumGC: 10
-----
mem.Alloc: 66152
mem.TotalAlloc: 2000230496
mem.HeapAlloc: 66152
mem.NumGC: 20-----
```

So, the output presents information about properties related to the memory used by the garbageCol.go program. If you want to get an even more detailed output, you can execute garbageCol.go, as shown here:

```markup
$ GODEBUG=gctrace=1 go run garbageCol.go
```

This version of the command will give you information in the following format:

```markup
gc 11 @0.101s 0%: 0.003+0.083+0.020 ms clock, 0.030+0.059/0.033/0.006+0.16 mscpu, 95->95->0 MB, 96 MB goal, 8 P
```

The 95->95->0 MB part contains information about the various heap sizes that also show how well or how badly the garbage collector is doing. The first value is the heap size when the GC starts, whereas the middle value shows the heap size when the GC ends. The third value is the size of the live heap.

Just Imagine

# Your environment

In this section, we will show how to find out things about your environment using the runtime package: this can be useful when you have to take certain actions depending on the OS and the Go version you are using.

The use of the runtime package for finding out about your environment is straightforward and is illustrated in runTime.go:

```markup
package main 
 
import ( 
   "fmt" 
   "runtime" 
) 
 
func main() { 
   fmt.Print("You are using ", runtime.Compiler, " ") 
   fmt.Println("on a", runtime.GOARCH, "machine") 
   fmt.Println("with Go version", runtime.Version()) 
   fmt.Println("Number of Goroutines:", runtime.NumGoroutine())
} 
```

As long as you know what you want to call from the runtime package, you can get the information you desire. The last fmt.Println() command here displays information about **goroutines**: you will learn more about goroutines in [Chapter 9](https://subscription.imaginedevops.io/book/programming/9781787125643/9)_,_ _Goroutines - Basic Features_.

Executing runTime.go on a macOS machine generates the following output:

```markup
$ go run runTime.go
You are using gc on a amd64 machine
with Go version go1.8
Number of Goroutines: 1  
```

Executing runTime.go on a Linux machine that uses an older Go version gives the following:

```markup
$ go run runTime.go
You are using gc on a amd64 machine
with Go version go1.3.3
Number of Goroutines: 4
```

Just Imagine

# Go gets updated frequently!

As I came to the end of writing this chapter, Go was updated a little. So, I decided to include this information in this book in order to give a better sense of how often Go gets updated:

```markup
$ date
Sat Apr  8 09:16:46 EEST 2017
$ go version
go version go1.8.1 darwin/amd64
```

Just Imagine

# Exercises

1.  Visit the documentation of the runtime package.
2.  Create your own structure, make a slice and use the sort.Slice() to sort the elements of the slice you created.
3.  Implement the quicksort algorithm in Go and sort some randomly-generated numeric data.
4.  Implement a doubly linked list.
5.  The implementation of tree.go is far from complete! Try to implement a function that checks whether a value can be found in the tree and another function that allows you to delete a tree node.
6.  Similarly, the implementation of the linkedList.go file is also incomplete. Try to implement a function for deleting a node and another one for inserting a node somewhere inside the linked list.
7.  Once again, the hash table implementation of hash.go is incomplete as it allows duplicate entries. So, implement a function that searches the hash table for a key before inserting it.

Just Imagine

# Summary

In this chapter, you learned many things related to algorithms and data structures. You also learned how to use existing Go packages and how to develop your own Go packages. This chapter also talked about garbage collection in Go and how to find information about your environment.

In the next chapter, we will start talking about systems programming and present even more Go code. More precisely, [](https://subscription.imaginedevops.io/book/programming/9781787125643/5)[Chapter 5](https://subscription.imaginedevops.io/book/programming/9781787125643/5), _Files and Directories_, will talk about how to work with files and directories in Go, how to painlessly traverse directory structures, and how to process command-line arguments using the flag package. But more importantly, we will start developing Go versions of various Unix command-line utilities.

Just Imagine

Previous Chapter

End of Chapter 4
